<!DOCTYPE html>
<html lang="en">

<head>
    <title>Space Harrier VR</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <style>
    body {
        width: 100%;
        height: 100%;
        background-color: #bd8ef8;
        color: #fff;
        margin: 0px;
        padding: 0;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    #info {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 101;
    }
    
    #score {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 102;
    }

 
    /*
* {cursor: none;}
*/
    </style>
</head>

<body>
    <a href="#" id="reset"><div id='info'></div></a>
    <div id='score'></div>
   
</body>
<!--
<script id="vertexShader" type="x-shader/x-vertex">
    varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }
</script>
<script id="fragmentShader" type="x-shader/x-fragment">
    uniform vec3 color1; uniform vec3 color2; uniform float scale; varying vec2 vUv; void main() { vec2 center = -1.0 + 2.0 * vUv; vec2 uv = floor(center.xy * scale); if(mod(uv.x + uv.y, 2.0) > 0.5){ gl_FragColor = vec4(color1, 1.0); }else{ gl_FragColor = vec4(color2, 1.0); } }
</script>

-->

<script id="vertexShader" type="x-shader/x-vertex">
      varying vec2 vUv;
      uniform float time;
      uniform float speed;
      uniform float scale;
      //varying float z;

      void main() {
        vUv = uv;

        //float z = scale;
        //float y = scale;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);

      }
  </script>
  
  <script id="fragmentShader" type="x-shader/x-fragment">

      uniform vec3 color1; 
      uniform vec3 color2;


      uniform float speed;
      uniform float scale;
      uniform float delta;

      uniform float time;
      varying vec2 vUv;
      uniform vec2 u_resolution;



      void main() {


        
        float delta = time * speed;

        vec2 center = -1.0 + 2.0 * vUv;

        vec2 uv = center.xy * scale;

        uv.y+=delta;

        gl_FragColor = vec4(color1, 1.0);
    
        if (floor(mod(uv.y, 2.0)) < 1.0) {
            if (mod(uv.x, 2.0) > 1.0)
                gl_FragColor = vec4(color2, 1.0);
        } else {
            if (mod(uv.x, 2.0) < 1.0)
                gl_FragColor = vec4(color2, 1.0);
        }

      }
  </script>
<script>
/*
 * Debug parameters.
 */
WebVRConfig = {
    /**
     * webvr-polyfill configuration
     */

    // Forces availability of VR mode.
    // FORCE_ENABLE_VR: true, // Default: false.
    // Complementary filter coefficient. 0 for accelerometer, 1 for gyro.
    //K_FILTER: 0.98, // Default: 0.98.
    // How far into the future to predict during fast motion.
    //PREDICTION_TIME_S: 0.040, // Default: 0.040 (in seconds).
    // Flag to disable touch panner. In case you have your own touch controls
    // TOUCH_PANNER_DISABLED: true, // Default: false.
    // Enable yaw panning only, disabling roll and pitch. This can be useful for
    // panoramas with nothing interesting above or below.
    YAW_ONLY: false, // Default: false.
    // Enable the deprecated version of the API (navigator.getVRDevices).
    //ENABLE_DEPRECATED_API: true, // Default: false.
    // Scales the recommended buffer size reported by WebVR, which can improve
    // performance. Making this very small can lower the effective resolution of
    // your scene.
    BUFFER_SCALE: 1, // default: 1.0
    // Allow VRDisplay.submitFrame to change gl bindings, which is more
    // efficient if the application code will re-bind it's resources on the
    // next frame anyway.
    // Dirty bindings include: gl.FRAMEBUFFER_BINDING, gl.CURRENT_PROGRAM,
    // gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING,
    // and gl.TEXTURE_BINDING_2D for texture unit 0
    // Warning: enabling this might lead to rendering issues.
    //DIRTY_SUBMIT_FRAME_BINDINGS: true // default: false
};
</script>
<!--
  A polyfill for Promises. Needed for IE and Edge.
  -->
<script src="node_modules/es6-promise/dist/es6-promise.js"></script>
<!--
  three.js 3d library
  -->
<script src="node_modules/three/build/three.min.js"></script>
<script src="../../bower_components/three.js/examples/js/libs/ammo.js"></script>
<script src="../../bower_components/three.js/examples/js/Detector.js"></script>
<script src="../../bower_components/three.js/examples/js/libs/stats.min.js"></script>
<script src="../../bower_components/three.js/examples/js/ConvexObjectBreaker.js"></script>
<script src="../../bower_components/three.js/examples/js/QuickHull.js"></script>
<script src="../../bower_components/three.js/examples/js/geometries/ConvexGeometry.js"></script>
<script src="../../bower_components/three.js/examples/js/utils/GeometryUtils.js"></script>
<script src="../../bower_components/gsap/src/minified/TweenMax.min.js"></script>
<!--
  VRControls.js acquires positional information from connected VR devices and applies the transformations to a three.js camera object.
   -->
<script src="node_modules/three/examples/js/controls/VRControls.js"></script>
<!--
<script src="node_modules/three/examples/js/controls/DeviceOrientationControls.js"></script>
-->
<!--
  VREffect.js handles stereo camera setup and rendering.
  -->
<script src="node_modules/three/examples/js/effects/VREffect.js"></script>
<!--
  A polyfill for WebVR using the Device{Motion,Orientation}Event API.
  -->
<script src="node_modules/webvr-polyfill/build/webvr-polyfill.js"></script>
<!--
  Helps enter and exit VR mode, provides best practices while in VR.
  -->
<script src="build/webvr-manager.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.19.0/TweenMax.min.js"></script>
<!--
<script src="build/threejs-texture-checkerboard.js"></script>
-->
<script src="node_modules/howler/dist/howler.min.js"></script>
<script src="../../bower_components/three.js/examples/js/libs/pnltri.min.js"></script>
        <script>
            THREE.ShapeUtils.triangulateShape = ( function () {
                var pnlTriangulator = new PNLTRI.Triangulator();
                function removeDupEndPts(points) {

                    var l = points.length;

                    if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

                        points.pop();

                    }

                }

                return function triangulateShape( contour, holes ) {
                    // console.log("new Triangulation: PnlTri.js " + PNLTRI.REVISION );

                    removeDupEndPts( contour );
                    holes.forEach( removeDupEndPts );

                    return pnlTriangulator.triangulate_polygon( [ contour ].concat(holes) );
                };
            } )();
        </script>
<script>
var forceVR = true;//false; //true;
var debug = false; //true;

var renderer, scene, camera, controls, effect, manager, loader, stats, title;
var playerblock, playerBody, playerState;
var pivot, player, player_sprite;
var mouse = new THREE.Vector2();
var uTime;
var helper;
var blasterArr = [];
var letterArr = [];
var explosionArr = [];
var enemyPool = [];
var blasterSpeed = .3; //5;
var info = document.getElementById('info');
var touchEnabled = false;
var gameOn = false;
var pressTimer = false;
var pressCounter = 0;

var annie, hero;

var score_display = document.getElementById('score');
var score = 0;
var sound, getReady, explode, argh, bkgdMusic;

var textureLoader;
var clock = new THREE.Clock();
var playerVector = new THREE.Vector3();
var camVector = new THREE.Vector3();
var camDir = new THREE.Vector3();
var heroTexture;

var direction = new THREE.Vector3();

var mouseCoords = new THREE.Vector2();
var raycaster = new THREE.Raycaster();
var ballMaterial = new THREE.MeshPhongMaterial({
    color: 0x000000,
    wireframe: false,
    //transparent:true, opacity:0.5
});

var hemisphereLight, shadowLight;
var floorMaterial, floorPlane;
var floor = [];
//var checkerTexture;
var xA = 0;
var yA = 0;
var accX = 0;
var accY = 0;
var accZ = 0;

// Physics variables
var gravityConstant = 0; //0.1; //7.8;
var collisionConfiguration;
var dispatcher;
var broadphase;
var solver;
var physicsWorld;
var margin = 0.05;

var convexBreaker = new THREE.ConvexObjectBreaker();

// Rigid bodies include all movable objects
var rigidBodies = [];

var pos = new THREE.Vector3();
var quat = new THREE.Quaternion();
var transformAux1 = new Ammo.btTransform();
var tempBtVec3_1 = new Ammo.btVector3(0, 0, 0);

var time = 0;

var objectsToRemove = [];
for (var i = 0; i < 500; i++) {
    objectsToRemove[i] = null;
}
var numObjectsToRemove = 0;

var impactPoint = new THREE.Vector3();
var impactNormal = new THREE.Vector3();

// Request animation frame loop function
var lastRender = 0;

var vrDisplay;

var accZsmooth = 0;
var accYsmooth = 0;
var factor = .98;

var _v3 = new THREE.Vector3;

var arrowArr = [];
 var group, textMesh1, textMesh2, textGeo, materials;

 var text = "VR",

        height = 20,
        size = 70,
        hover = 30,

        curveSegments = 4,

        bevelThickness = 20,
        bevelSize = 1.5,
        bevelSegments = 3,
        bevelEnabled = true,

        font = undefined,

        fontName = "Slukoni";//"optimer", // helvetiker, optimer, gentilis, droid sans, droid serif
        fontWeight = "Medium";//"bold"; // normal bold

    var mirror = false;

    var fontMap = {

        "helvetiker": 0,
        "optimer": 1,
        "gentilis": 2,
        "droid/droid_sans": 3,
        "droid/droid_serif": 4,
        "slukoni": 5

    };

    var weightMap = {

        "regular": 0,
        "bold": 1

    };


var Colors = {
    red: 0xf25346,
    white: 0xd8d0d1,
    brown: 0x59332e,
    pink: 0xF5986E,
    brownDark: 0x23190f,
    blue: 0x68c3c0,
};

// shader for checkerboard

var options  = {
                

        speed            : 10.0,

        segments         : 324,

        checker_color1     : '#76c876',

        checker_color2     : '#a7f9a7',

        scale            : 50,

      //  perlin_passes    : 1,

        wireframe        : true,

      //  floor_visible    : true

    };


var uniforms = {
      "time": {
          type: "f",
          value: 0.0
      },
      "speed": {
          type: "f",
          value: options.speed
      },

  
      "color1" : {
        type : "c",
        value : new THREE.Color(0x76c876)
      },
      "color2" : {
        type : "c",
        value : new THREE.Color(0xa7f9a7)
      },
     
      "scale" : {
        type : "f",
        value : options.scale,
        min : 1, // only used for dat.gui, not needed for production
        max : 100 // only used for dat.gui, not needed for production
      },
    }
var vertexShader = document.getElementById('vertexShader').text;
var fragmentShader = document.getElementById('fragmentShader').text;

var defines = {};
defines[ "USE_MAP" ] = "";
var checkerTexture = new THREE.ShaderMaterial({
    defines: defines,
    uniforms: uniforms,
    vertexShader: vertexShader,
    fragmentShader: fragmentShader,
    side: THREE.DoubleSide,
   // lights:true
        // doubleSide: true,
});



// custom global variables
var annie, hero; // animators




var volume = 0.4;

function loadBkgd() {
    bkgdMusic = new Howl({
        src: ['audio/sh-theme.mp3'],
        volume: volume
    });
   // sound.play();

}

function playBkgd() {
    bkgdMusic.play();
}

function loadSound() {
    sound = new Howl({
        src: ['../_audio/boing.mp3'],
        volume: volume
    });
   // sound.play();

}



function playSound() {
    sound.play();
}

function loadGetReady() {

    getReady = new Howl({
        src: ['audio/ready.mp3'],
        volume: volume
    });
    //getReady.play();

}

function playGetReady() {
    getReady.play();
}


function loadExplode() {

    explode = new Howl({
        src: ['audio/explode.mp3'],
        volume: volume
    });
    //explode.play();

}

function playExplode() {
    explode.play();
}

function loadArgh() {

    argh = new Howl({
        src: ['audio/sharrierAAArg.mp3'],
        volume: volume
    });
    //explode.play();

}


function playArgh() {
    argh.play();
}

function muteAll() {
    howler.mute();
}


function init() {

    setDebug(true)

    renderer = new THREE.WebGLRenderer({
        antialias: true,
        precision: "mediump"
    });
    renderer.setClearColor(0xffff00);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;

    // Append the canvas element created by the renderer to document body element.
    document.body.appendChild(renderer.domElement);

    // Create a three.js scene.
    scene = new THREE.Scene();

    scene.background = new THREE.Color(0xbd8ef8);



    // Create a three.js camera.
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
    //var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 100);

    controls = new THREE.VRControls(camera);
    controls.standing = true;
    controls.standing = true;

    // Apply VR stereo rendering to renderer.
    effect = new THREE.VREffect(renderer);
    effect.setSize(window.innerWidth, window.innerHeight);

    // Create a VR manager helper to enter and exit VR mode.
    var params = {
        hideButton: false, // Default: false.
        isUndistorted: false // Default: false.
    };
    manager = new WebVRManager(renderer, effect, params);


    /*
        loader = new THREE.TextureLoader();
        //setPlayerTexture calls setupStage which triggers animate
        loader.load('img/Space_Harrier_player_sprite.png', setPlayerTexture);
    */
    




    setupStage();


    var loader2 = new THREE.TextureLoader();
    loader2.load('img/blaster.png', function(texture) {
        blasterMaterial = new THREE.SpriteMaterial({
            map: texture,
            color: 0xffffff
        });
        // createBlaster();

        // needs a delay??
        if (forceVR && manager.isVRCompatible) {
            manager.enterVRMode_();
            console.log(manager)
        }

    });
    /*
        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        renderer.domElement.appendChild(stats.domElement);
    */


    createLights();
    createTitleScreen();
   // createLetter('V');
    
    // setupGround();

    window.addEventListener('resize', onResize, true);
    window.addEventListener('vrdisplaypresentchange', onResize, true);


}

function createTitleScreen(){
    var loader = new THREE.TextureLoader();
    loader.load('img/spaceharrier_title.png', function(texture) {
      //  var titleTexture = texture;
      //  console.log(texture.image.width)// and texture.image.height
        var titleMaterial = new THREE.SpriteMaterial({
            map: texture,
            color: 0xffffff
        });

        title = new THREE.Sprite(titleMaterial);
        title.scale.set(2, 1, 1)
        title.position.set(0, controls.userHeight, -5)
        scene.add(title);


        TweenMax.to(title.position, 1,{

            z:-2,

            ease:"Power3.easeOut",
            onUpdate:function(){
               // no_geom.verticesNeedUpdate = true;
                
          //  console.log('tweened');
        }});

        loadFont();
    });
}

function removeTitleScreen(){
    for (var n=0; n<letterArr.length;n++){
        scene.remove(letterArr[n])
    }
    scene.remove(title)
}

function initPhysics() {

    // Physics configuration

    collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
    dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
    broadphase = new Ammo.btDbvtBroadphase();
    solver = new Ammo.btSequentialImpulseConstraintSolver();
    physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);
    physicsWorld.setGravity(new Ammo.btVector3(0, -gravityConstant, 0));

}

function addPlayer() {
    player = new Player("img/hero-spritesheet.png", 0, true);


    pivot = new THREE.Object3D();
    pivot.position.set(0, controls.userHeight, 0);
    scene.add(pivot);

    // createPlayer(playerTexture);

    createPlayerHelper();
}

function Explosion(vector) {

    var explosionTexture = new THREE.TextureLoader().load("img/explosion_sprite_small.png");
    var expSprite = new TextureAnimator(explosionTexture, 7, 1, 7, 75);
    expSprite.animBehavior = "loop";

    explosionblock = new THREE.Mesh(new THREE.BoxGeometry(.5, .5, .5, 1, 1, 1), createMaterial(0xff0000, true, 0));
    explosionblock.castShadow = true;
    explosionblock.receiveShadow = true;
    explosionblock.name = "explosion";




    //annie = new TextureAnimator( explosionTexture, 10, 1, 10, 75 ); // texture, #horiz, #vert, #total, duration.
   /* var explosionMaterial = new THREE.MeshBasicMaterial({
        map: explosionTexture,
        side: THREE.DoubleSide,
        color: 0xffffff
    });*/
   
        // var explosionGeometry = new THREE.PlaneGeometry(1.16, .78, 1, 1);
        //  var explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);

    var explosionMaterial = new THREE.SpriteMaterial({
        map: explosionTexture,
        color: 0xffffff
    });
     explosionMaterial.transparent = true;
    explosionMaterial.depthTest = true
    explosionMaterial.depthWrite = false
    explosionMaterial.polygonOffset = true
    explosionMaterial.polygonOffsetFactor = -4
    var explosion = new THREE.Sprite(explosionMaterial);


    // explosion.position.set(0,controls.userHeight,-5);
    explosion.scale.set(2, 2, 1.0); 
    explosionblock.position.copy(vector);
    scene.add(explosionblock);
    explosionblock.add(explosion)

    explosionArr.push(this);

    this.mesh = explosion;
    this.block = explosionblock;
    this.sprite = expSprite;
    this.start = 0;
    //  this.shadow = new Shadow(player.position);
    this.dist = Math.random() * 60;

    // this.flicker();

    this.update = function() {
      //  console.log('explosion update')

    }

    this.animate = function(state, loops) {
        // console.log('player animate')
        //this.tilesHorizontal =3;


    }

    this.flicker = function() {
        TweenMax.to(this.mesh.material, .1, {
            opacity: 0,
            delay: .4,
            repeat: 7,
            yoyo: true
        });
    }

    this.fadeOut = function() {
    //    console.log('fadeOut')
        var _this = this;
        TweenMax.to(this.mesh.material, .3, {
            opacity: 0,
            delay: .5,
            onComplete:function(){
                _this.destroy();
                        }
        });
    }


    this.destroy = function() {
       // console.log('destroy')
       // console.log(this)
        scene.remove(this.block);
        explosionArr.splice(this, 1);
        // console.log(enemyPool)

    }

    this.fadeOut();

}



function createPlayerHelper() {
    var r = 1;
    helper = new THREE.BoxHelper(new THREE.Mesh(new THREE.BoxGeometry(r, r, r)));
    helper.material.color.setHex(0x080808);
    helper.material.blending = THREE.AdditiveBlending;
    //helper.position.set(0, controls.userHeight, 0);
    helper.position.z = -1;
    helper.scale.set(.2, .2, .2);
    pivot.add(helper);

    if (debug == false) helper.visible = false;
}


function animate() {


    var deltaTime = clock.getDelta();

    //animate checkerboard texture
    uniforms.time.value = clock.getElapsedTime();

    if (gameOn){
        hero.update(700 * deltaTime);
        //  if (annie) annie.update(700 * deltaTime);
        for (var n = 0; n < explosionArr.length; n++) {
           // console.log(explosionArr[n])
            explosionArr[n].sprite.update(700 * deltaTime);

        }

        for (var n = 0; n < enemyPool.length; n++) {
           // console.log(explosionArr[n])
            enemyPool[n].update();


        }

        playerFollow();


    }

    if (pressTimer) {
        pressCounter++;
       // console.log(pressCounter)
        if (pressCounter > 200){
            resetGame();
            pressTimer=false;
        }
    }

    updatePhysics(deltaTime);

    controls.update(deltaTime);

    time += deltaTime;


    // Render the scene through the manager.
    manager.render(scene, camera);
    effect.render(scene, camera);

    

    if (pivot) {
        pivot.rotation.copy(camera.rotation);
       // console.log(camera.rotation)
        pivot.updateMatrix();
    }

    /*

        for (var i = 0; i < floor.length; i++) {

            ground = floor[i];

            // move it forward by a 10th of its array position each time 
            ground.position.z += 0.5;

            // once the star is too close, reset its z position
            if (ground.position.z > 400) ground.position.z -= 1600;
        }

    */

    // stats.update();

    vrDisplay.requestAnimationFrame(animate);
}

function playerFollow() {
    var camDir = camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(1);
    var camVect = new THREE.Vector3(camDir.x, camDir.y, camDir.z);


    // get mouse position and add some accelerometer
    var vector;
    if (touchEnabled) {
        vector = new THREE.Vector3(-accYsmooth, accZsmooth, -1).unproject(camera);


    } else {

        vector = new THREE.Vector3(-mouse.x * 10, -mouse.y * 10, -1).unproject(camera);
        //  vector = new THREE.Vector3(-mouse.x * 10 - accYsmooth, -mouse.y * 10 + accZsmooth, -1).unproject(camera);
    }


    var direction = camVect.clone().sub(playerblock.position).add(vector);

    var speed = 5;
    var xpos = direction.x * speed;
    var ypos = direction.y * speed;
    var zpos = direction.z * speed;


    playerBody.setLinearVelocity(new Ammo.btVector3(xpos, ypos, zpos));

}

function onResize(e) {
    effect.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

}



// Get the HMD, and if we're dealing with something that specifies
// stageParameters, rearrange the scene.
function setupStage() {
    navigator.getVRDisplays().then(function(displays) {
        if (displays.length > 0) {
            vrDisplay = displays[0];
            if (vrDisplay.stageParameters) {
                setStageDimensions(vrDisplay.stageParameters);
                if (forceVR && manager.isVRcompatible) {
                    manager.enterVRMode_();
                    console.log(manager)
                }
            }
            vrDisplay.requestAnimationFrame(animate);
        }
        //   console.log(vrDisplay.orientation_);
        // window.addEventListener("devicemotion", function(event) 

        // is mobile? has accelerometer?
        //if(window.DeviceMotionEvent) { 
        //   var util = new Util;
        //    console.log(util.isMobile)
        // bad mobile detection
        if (window.innerWidth < 769) {
            console.log('isDeviceMotion')

            window.addEventListener("devicemotion", function(event) {

                //accX = Math.round(event.accelerationIncludingGravity.x*10) / 10;  
                //accY = Math.round(event.accelerationIncludingGravity.y*10) / 10;  
                // accY = event.accelerationIncludingGravity.y;
                // if (manager.mode == 1){

                accZ = event.accelerationIncludingGravity.z;
                accY = event.accelerationIncludingGravity.y;
                accZsmooth = factor * accZsmooth + (1 - factor) * accZ;
                accYsmooth = factor * accYsmooth + (1 - factor) * accY;


                if (gameOn){
                    if (accZsmooth < -1) {
                            player.animate('run')
                        
                    } else {
                       // player.animate('fly');
                        if (accYsmooth < -.15) {
                             player.animate('right')
                         } else if (accYsmooth >.15) {
                             player.animate('left')
                         } else {
                             player.animate('fly')
                         }
                       
                      
                    }
                }

                //if VR mode
                if (manager.mode == 3) {
                    //  info.innerHTML += ' mode 1'
                    // info.innerHTML += ' player='+player.position;
                    //  ?????????????????????
                    //  accZsmooth =-7.75;
                    accYsmooth = accYsmooth*-1;


                    mouse.x = 0;
                    mouse.y = 0;

                }


                if (debug) {
                    info.innerHTML = 'accZ:' + accZ.toFixed(2) + ', accZsm:' + accZsmooth.toFixed(2) + ', accY:' + accYsmooth.toFixed(2);
                    info.innerHTML += ' mode:' + manager.mode;
                }

                

            }, true);



        }
    });

}
/*
function doOnOrientationChange() {
    switch(window.orientation) {  
      case -90 || 90:
        alert('landscape');
        break; 
      default:
        alert('portrait');
        break; 
    }
}
  
*/

function onDocumentKeyPress(event) {
    player.animate('run');
    var keyCode = event.which;
    console.log(keyCode)

    // press ''

    if (keyCode == 100) {

        if (debug == true) {
            setDebug(false);
        } else {
            setDebug(true);
        }

        event.preventDefault();

    }

}


function onDocumentMouseMove(event) {

    if (gameOn){
        event.preventDefault();

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;



        if (mouse.y > .3) {
            if (camera.rotation.x < 0.05 ){
                player.animate('run')
            }
        } else {
            player.animate('fly');
             if (mouse.x < -.4) {
                 player.animate('right')
             } else if (mouse.x > .4) {
                 player.animate('left')
             } else {
                 player.animate('fly')
             }
          
        }
        /*
            mouseCoords.set(
                (event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1
            );
        */

        if (debug) info.innerHTML = 'x:' + mouse.x.toFixed(2) + ', y:' + mouse.y.toFixed(2);

    }
}





function setupGround() {

    loader.load('img/checkerboard.jpg', function(texture) {
        var floorTexture = texture;
        floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
        floorTexture.repeat.set(10, 10);
        var floorMaterial = new THREE.MeshBasicMaterial({
            map: floorTexture,
            side: THREE.DoubleSide
        });
        addGround(floorMaterial);
    });






}


function addGround(floorMaterial) {

    //create the ground material using MeshLambert Material
    //   var groundMat = new THREE.MeshLambertMaterial( {color: 0xffffff, side: THREE.DoubleSide}  );
    //create the plane geometry
    var geometry = new THREE.PlaneGeometry(400, 800, 300, 300);
    // var geometry = new THREE.BoxGeometry(400, 10, 800);

    //create the ground form the geometry and material


    for (var z = -1600; z < 1600; z += 800) {


        /*  //make the terrain bumpy
          for (var i = 0, l = geometry.vertices.length; i < l; i++) {
            var vertex = geometry.vertices[i];
            var value = pn.noise(vertex.x / 10, vertex.y /10, 0);
            vertex.z = value *6;
          }
          //ensure light is computed correctly
          geometry.computeFaceNormals();
          geometry.computeVertexNormals();
        */


        //   var ground = new THREE.Mesh(geometry,groundMat); 

        //  var ground = new THREE.Mesh(geometry,floorMaterial); 
        var ground = new THREE.Mesh(geometry, checkerTexture);
        //rotate 90 degrees around the xaxis so we can see the terrain 
        ground.rotation.x = -Math.PI / -2;
        // Then set the z position to where it is in the loop (distance of camera)
        ground.position.z = z;


        //add the ground to the scene
        scene.add(ground);
        //finally push it to the stars array 
        floor.push(ground);
    }



}


function createLights() {
    var ambientLight = new THREE.AmbientLight(0x707070);
    scene.add(ambientLight);

    var light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(-10, 18, 5);
    light.castShadow = true;
    var d = 14;
    light.shadow.camera.left = -d;
    light.shadow.camera.right = d;
    light.shadow.camera.top = d;
    light.shadow.camera.bottom = -d;

    light.shadow.camera.near = 2;
    light.shadow.camera.far = 50;

    light.shadow.mapSize.x = 1024;
    light.shadow.mapSize.y = 1024;

    scene.add(light);
}

function createParalellepipedWithPhysics(sx, sy, sz, mass, pos, quat, material) {

    var object = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1), material);
    var shape = new Ammo.btBoxShape(new Ammo.btVector3(sx * 0.5, sy * 0.5, sz * 0.5));
    shape.setMargin(margin);


    var ballBody = createRigidBody(object, shape, mass, pos, quat);

    return object;

}


function createGround(){
    pos.set(0, -0.5, 0);
    quat.set(0, 0, 0, 1);
    var ground = createParalellepipedWithPhysics(40, 1, 40, 0, pos, quat, checkerTexture);
    ground.receiveShadow = true;
    ground.name = "ground";
}

function createObjects() {
    

    var towerMass = 1000;
    var towerHalfExtents = new THREE.Vector3(2, 5, 2);
    pos.set(-3, 2, -10);
    quat.set(0, 0, 0, 1);
    //  createObject( towerMass, towerHalfExtents, pos, quat, createMaterial( 0xF0A024 ), 'tower' );

    var tower = createParalellepipedWithPhysics(2, 5, 2, towerMass, pos, quat, createMaterial());
    tower.receiveShadow = true;
    tower.castShadow = true;
    tower.name = "tower";



    pos.set(0, 1, -5);
    quat.set(0, 0, 0, 1);
    var brick = createParalellepipedWithPhysics(.6, .6, 1.2, 1000, pos, quat, createMaterial());


    brick.castShadow = true;
    brick.receiveShadow = true;
    brick.name = "brick";

    pos.set(Math.random()*4-2, Math.random()*10, Math.random()*10 - 5);
    quat.set(0, 0, 0, 1);
    var brick = createParalellepipedWithPhysics(.6, .6, 1.2, 1000, pos, quat, createMaterial());


    brick.castShadow = true;
    brick.receiveShadow = true;
    brick.name = "brick";


    createWall(0,0);
    createWall(-10, 20);
    
    createEnemies();
}

function createWall(xpos, zpos) {
    // Wall
    var brickMass = 100; //0.5;
    var brickLength = 1.2;
    var brickDepth = 0.6;
    var brickHeight = brickLength * 0.5;
    var numBricksLength = 6;
    var numBricksHeight = 8;
    var z0 = -10 - numBricksLength * brickLength * 0.5 +zpos;
    pos.set(3+xpos, brickHeight * 0.5, z0);
    quat.set(0, 0, 0, 1);
    for (var j = 0; j < numBricksHeight; j++) {

        var oddRow = (j % 2) == 1;

        pos.z = z0;

        if (oddRow) {
            pos.z -= 0.25 * brickLength;
        }

        var nRow = oddRow ? numBricksLength + 1 : numBricksLength;
        for (var i = 0; i < nRow; i++) {

            var brickLengthCurrent = brickLength;
            var brickMassCurrent = brickMass;
            if (oddRow && (i == 0 || i == nRow - 1)) {
                brickLengthCurrent *= 0.5;
                brickMassCurrent *= 0.5;
            }

            var brick = createParalellepipedWithPhysics(brickDepth, brickHeight, brickLengthCurrent, brickMassCurrent, pos, quat, createMaterial());


            brick.castShadow = true;
            brick.receiveShadow = true;
            brick.name = "brick";

            if (oddRow && (i == 0 || i == nRow - 2)) {
                pos.z += 0.75 * brickLength;
            } else {
                pos.z += brickLength;
            }

        }
        pos.y += brickHeight;
    }

}


function createEnemies() {

   // var ballMass = 30; //.35;
   // var ballRadius = 1; //0.4;

    for (var j = 0; j < 10; j++) {

        var enemy = new Enemy();
    }
}




function Player(img, xpos, sprite) {

    //var playerTexture = new THREE.TextureLoader().load( "img/player_small_128.png" );
    var playerTexture = new THREE.TextureLoader().load(img);
    if (sprite) hero = new TextureAnimator(playerTexture, 4, 4, 3, 75);
    //annie = new TextureAnimator( playerTexture, 10, 1, 10, 75 ); // texture, #horiz, #vert, #total, duration.

    pos.set(0, controls.userHeight, -1);
    quat.set(0, 0, 0, 1);

    var playerMass = 2000;

    var sx = .25;
    var sy = .25;
    var sz = .25;

  //  playerblock = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1), createMaterial(0xff0000, true));
    playerblock = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1), createMaterial(0xff0000, true,0));
    playerblock.castShadow = true;
    playerblock.receiveShadow = true;
    playerblock.name = "player";

   // playerblock.visible = false;

    var playerMaterial = new THREE.SpriteMaterial({
        map: playerTexture,
        color: 0xffffff
    });
    /*
        var playerMaterial = new THREE.MeshBasicMaterial({
            map: playerTexture,
            side: THREE.DoubleSide,
            color: 0xffffff
        });
        */
    playerMaterial.transparent = true;

    // playerMaterial.map.offset = new THREE.Vector2(0.25 * 1, 0);
    // playerMaterial.map.repeat = new THREE.Vector2(1 / 4, 1);
    //fixes flicker when planes intersect
    playerMaterial.depthTest = true
    playerMaterial.depthWrite = false
    playerMaterial.polygonOffset = true
    playerMaterial.polygonOffsetFactor = -4
        /// end fix

    /// the actual character ////      
    // var playerGeometry = new THREE.PlaneGeometry(1, 1, 10, 10);
    //  var player = new THREE.Mesh(playerGeometry, playerMaterial);

    var player = new THREE.Sprite(playerMaterial);

    player.scale.set(.5, .5, 1.0); // imageWidth, imageHeight
    playerblock.add(player);

    var playerShape = new Ammo.btBoxShape(new Ammo.btVector3(sx * 0.5, sy * 0.5, sz * 0.5));
    playerShape.setMargin(margin);

    /* var playerShape = new Ammo.btSphereShape(playerRadius);
     playerShape.setMargin(margin);
     */

    playerBody = createRigidBody(playerblock, playerShape, playerMass, pos, quat);
    playerBody.setFriction(0.9);

   // physicsBodies.push(playerBody);


  //  console.log(playerblock)
  //  console.log(playerblock.name)
  //  console.log(playerBody)




    /////////
    /*
      // playerblock = new THREE.Mesh(new THREE.SphereGeometry(playerRadius, 14, 10), ballMaterial);
        playerblock = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1), createMaterial(0xff0000, true));
        playerblock.castShadow = true;
        playerblock.receiveShadow = true;
        playerblock.name = "player";

        var playerMaterial = new THREE.SpriteMaterial({
            map: texture,
            color: 0xffffff
        });
        var player = new THREE.Sprite(playerMaterial);
        player.scale.set(.5, .5, 1.0); // imageWidth, imageHeight
        playerblock.add(player)
    */
    /////

    this.mesh = player;
    this.start = 0;
    //  this.shadow = new Shadow(player.position);
    this.dist = Math.random() * 60;

    this.update = function() {
     //   console.log('player update')

    }

    this.animate = function(state, loops) {
        // console.log('player animate')
        //this.tilesHorizontal =3;

       // console.log('state=' + state + ',pState=' + playerState)
        if (state != playerState) {
            hero.currentTile = 0;
            hero.numberOfTiles = 3;
           // console.error('state=' + state + ',pState=' + playerState)
            playerState = state;
            if (state == "fly") {
               // console.log("fly")

                hero.setFrame(0, 3, 'freeze');

            } else if (state == "left") {
              //  console.log("left")
                hero.setFrame(1, 3, 'freeze');

            } else if (state == "right") {
              //  console.log("right")
                hero.setFrame(2, 3, 'freeze');

            } else if (state == "run") {
              //  console.log("run")
                hero.setFrame(0, 2, 'loop');

            } else if (state == "fall") {
              // console.log("fall")
                hero.setFrame(0, 1, 'once');
                this.flicker();

            } else if (state == "die") {
              //+  console.log("die")
                    //this.tilesHorizontal =4;
                hero.numberOfTiles = 4;
                hero.setFrame(0, 0, 'once');
                this.flicker();

            }
        }
    }

    this.flicker = function() {
        TweenMax.to(this.mesh.material, .1, {
            opacity: 0,
            delay: .4,
            repeat: 7,
            yoyo: true
        });
    }





    /*
      this.update = function(){
            this.mesh.position.y = 80 + Math.sin(this.start)*40;
            this.mesh.position.z = Math.cos(this.start)*this.dist;
            this.shadow.update();
            this.start+=options.speed;


      }

      this.destroy = function(){
        console.log('destroy')
        this.shadow.destroy();
        scene.remove(this.mesh);
        //playerPool.splice(this, 1);
       // console.log(enemyPool)

      }
      */
}

function Enemy() {


    var enemyTexture = new THREE.TextureLoader().load( "img/enemy.png" );
 
    pos.set(Math.random() * 10 - 5, controls.userHeight, Math.random()*10 -20);
    quat.set(0, 0, 0, 1);

    var enemyMass = 10;

    var sx = .4;
    var sy = .25;
    var sz = .25;

    enemyblock = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1), createMaterial(0xff0000, true, 0));
    enemyblock.castShadow = true;
    enemyblock.receiveShadow = true;
    enemyblock.name = "player";

    var enemyMaterial = new THREE.SpriteMaterial({
        map: enemyTexture,
        color: 0xffffff
    });

    enemyMaterial.transparent = true;

    enemyMaterial.depthTest = true
    enemyMaterial.depthWrite = false
    enemyMaterial.polygonOffset = true
    enemyMaterial.polygonOffsetFactor = -4

    var enemy = new THREE.Sprite(enemyMaterial);

    enemy.scale.set(.75, .5, 1.0); // imageWidth, imageHeight
    enemyblock.add(enemy);

    var enemyShape = new Ammo.btBoxShape(new Ammo.btVector3(sx * 0.5, sy * 0.5, sz * 0.5));
    enemyShape.setMargin(margin);

    var enemyBody = createRigidBody(enemyblock, enemyShape, enemyMass, pos, quat);
    enemyBody.setFriction(0.9);

    var direction = new THREE.Vector3();
    direction.subVectors(new THREE.Vector3(0, 4, 0), pos).normalize();


    pos.copy(direction);
    pos.multiplyScalar(2 + Math.random()*3);
    enemyBody.setLinearVelocity(new Ammo.btVector3(0, 0, pos.z));

    enemyPool.push(this)


    this.mesh = enemy;
    this.block = enemyblock;
    this.body = enemyBody;
    this.start = 0;

    this.dist = Math.random() * 60;

    this.update = function() {
      //  console.log('enemy update: pos.z = '+ this.block.position.z)
        if (this.block.position.z>0){

                //////
          var tr = new Ammo.btTransform();
            tr.setOrigin(new Ammo.btVector3(Math.random() * 20 - 10, controls.userHeight, -20));
            this.body.setWorldTransform( tr ); 
        
            // apply your new transform to the rigid body //  
           // rigidBody->getMotionState()->setWorldTransform( tr ); 
          //  console.error('reset')
           // pos.set(0, controls.userHeight, -10);
           // this.body.position.copy(pos);
        }

    }

    this.animate = function(state, loops) {

        
    }

    this.shoot = function() {

    }

    this.flicker = function() {
        TweenMax.to(this.mesh.material, .1, {
            opacity: 0,
            delay: .4,
            repeat: 7,
            yoyo: true
        });
    }





    /*
      this.update = function(){
            this.mesh.position.y = 80 + Math.sin(this.start)*40;
            this.mesh.position.z = Math.cos(this.start)*this.dist;
            this.shadow.update();
            this.start+=options.speed;


      }

      this.destroy = function(){
        console.log('destroy')
        this.shadow.destroy();
        scene.remove(this.mesh);
        //playerPool.splice(this, 1);
       // console.log(enemyPool)

      }
      */
}

function createRigidBody(object, physicsShape, mass, pos, quat, vel, angVel) {

    if (pos) {
        object.position.copy(pos);
    } else {
        pos = object.position;
    }
    if (quat) {
        object.quaternion.copy(quat);
    } else {
        quat = object.quaternion;
    }

    var transform = new Ammo.btTransform();
    transform.setIdentity();
    transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
    transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
    var motionState = new Ammo.btDefaultMotionState(transform);


    //////

    var localInertia = new Ammo.btVector3(0, 0, 0);
    physicsShape.calculateLocalInertia(mass, localInertia);

    var rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, physicsShape, localInertia);
    var body = new Ammo.btRigidBody(rbInfo);


    body.setFriction(0.5);

    if (vel) {
        body.setLinearVelocity(new Ammo.btVector3(vel.x, vel.y, vel.z));
    }
    if (angVel) {
        body.setAngularVelocity(new Ammo.btVector3(angVel.x, angVel.y, angVel.z));
    }

    object.userData.physicsBody = body;
    object.userData.collided = false;


    scene.add(object);



    if (mass > 0) {
        rigidBodies.push(object);

        // Disable deactivation
        body.setActivationState(4);
    }

    var btVecUserData = new Ammo.btVector3(0, 0, 0);
    btVecUserData.threeObject = object;
    body.setUserPointer(btVecUserData);


    physicsWorld.addRigidBody(body);

    return body;
}

function createRandomColor() {
    return Math.floor(Math.random() * (1 << 24));
}

function createMaterial(color, wire= false, fade=1) {
    color = color || createRandomColor();
    return new THREE.MeshPhongMaterial({
        color: color,
        wireframe: wire,
        transparent:true,
        opacity: fade

    });
}

function initInput() {

    
    document.addEventListener('mousemove', onDocumentMouseMove, false);

    document.addEventListener('keypress', onDocumentKeyPress, false);
    window.addEventListener('touchstart', shoot, false);
    window.addEventListener('mousedown', shoot, false);
    window.addEventListener('touchend', endCounter, false);
    window.addEventListener('mouseup', endCounter, false);


}

function endCounter(){
    pressTimer = false;
    pressCounter = 0;

}

function shoot(e) {
    pressTimer = true;
    if (gameOn == false){
        startGame();
    }else{


        console.log(pressCounter)
        // alert(e)
        //alert(e.type);
        if (e.type == "touchstart") touchEnabled = true;
        //  e.preventDefault();
        //  e.stopPropagation();

        // console.log(playerBody)

        var dir = Math.random() * 2 - 1;

        var bulletDir = camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(20);
        //  var camVect = new THREE.Vector3(bulletDir.x, controls.userHeight, bulletDir.z);
        var bulletVect = new THREE.Vector3(bulletDir.x, bulletDir.y + controls.userHeight, bulletDir.z);

        var direction = bulletVect.clone().sub(playerblock.position).normalize();
        var length = direction.length();

        //  addArrowHelper(direction, length);

        // Creates a ball and throws it
        var ballMass = 35;
        var ballRadius = 0.2;

        // var ball = new THREE.Mesh(new THREE.SphereGeometry(ballRadius, 14, 10), ballMaterial);
        var ball = new THREE.Mesh(new THREE.SphereGeometry(ballRadius, 2, 2), createMaterial(0x33ffff, true, 0));
        ball.castShadow = true;
        ball.receiveShadow = true;
        ball.name = "bullet";



        var blaster = new THREE.Sprite(blasterMaterial);
        blaster.scale.set(.8, .8, 1.0);
        ball.add(blaster)


        var ballShape = new Ammo.btSphereShape(ballRadius);
        ballShape.setMargin(margin);
        // pos.copy(raycaster.ray.direction);
        // pos.add(raycaster.ray.origin);

        pos.copy(direction);
        // pos.add(playerVector);
        pos.add(playerblock.position);


        quat.set(0, 0, 0, 1);
        var ballBody = createRigidBody(ball, ballShape, ballMass, pos, quat);

        ///  playerblock.position.copy(pos)


        // pos.copy(raycaster.ray.direction);
        pos.copy(direction);
        pos.multiplyScalar(24);
        ballBody.setLinearVelocity(new Ammo.btVector3(pos.x, pos.y, pos.z));

        playSound();
    }

}

function addArrowHelper(direction, length) {
    var arrowHelper = new THREE.ArrowHelper(direction, playerblock.position, length, 0xff0000);


    arrowHelper.time = lastRender;
    arrowArr.push(arrowHelper);
    scene.add(arrowHelper);
}


function setDebug(bool) {
    debug = bool;
    if (debug == false) {
        info.innerHTML = null;
    }
}


function setStageDimensions(stage) {

    // Place the cube in the middle of the scene, at user height.
    player.position.set(0, controls.userHeight, -1);
}

function updatePhysics(deltaTime) {

    // Step world
    physicsWorld.stepSimulation(deltaTime, 10);

    // Update rigid bodies
    for (var i = 0, il = rigidBodies.length; i < il; i++) {
        var objThree = rigidBodies[i];
        var objPhys = objThree.userData.physicsBody;
        var ms = objPhys.getMotionState();
        //  console.log(objThree.name )
        if (ms) {

            ms.getWorldTransform(transformAux1);
            var p = transformAux1.getOrigin();
            var q = transformAux1.getRotation();
            objThree.position.set(p.x(), p.y(), p.z());
            objThree.quaternion.set(q.x(), q.y(), q.z(), q.w());

            objThree.userData.collided = false;

        }
        /*

                if (objThree.name == "player"){ 
                    console.log('player here')
                    objThree.position.set(p.x()+Math.Random()*4, p.y(), p.z());
                }

        */


    }



    for (var i = 0, il = dispatcher.getNumManifolds(); i < il; i++) {

        var contactManifold = dispatcher.getManifoldByIndexInternal(i);



        var rb0 = contactManifold.getBody0();
        var rb1 = contactManifold.getBody1();

        var threeObject0 = Ammo.castObject(rb0.getUserPointer(), Ammo.btVector3).threeObject;
        var threeObject1 = Ammo.castObject(rb1.getUserPointer(), Ammo.btVector3).threeObject;

        if (!threeObject0 && !threeObject1) {
            continue;
        }

        //  console.log('continuing')

        var userData0 = threeObject0 ? threeObject0.userData : null;
        var userData1 = threeObject1 ? threeObject1.userData : null;

        var breakable0 = userData0 ? userData0.breakable : false;
        var breakable1 = userData1 ? userData1.breakable : false;

        var collided0 = userData0 ? userData0.collided : false;
        var collided1 = userData1 ? userData1.collided : false;

        //if ( ( ! breakable0 && ! breakable1 ) || ( collided0 && collided1 ) ) {
        if (collided0 && collided1) {
            continue;
        }

        var contact = false;
        var maxImpulse = 0;
        for (var j = 0, jl = contactManifold.getNumContacts(); j < jl; j++) {
            var contactPoint = contactManifold.getContactPoint(j);
            if (contactPoint.getDistance() < 0) {
                contact = true;


                var impulse = contactPoint.getAppliedImpulse();
                if (impulse > maxImpulse) {
                    //console.log(contactPoint)
                    maxImpulse = impulse;
                    var pos = contactPoint.get_m_positionWorldOnB();
                    var normal = contactPoint.get_m_normalWorldOnB();
                    impactPoint.set(pos.x(), pos.y(), pos.z());
                    impactNormal.set(normal.x(), normal.y(), normal.z());
                }
                //console.log('break')
                break;
            }
        }

        // If no point has contact, abort
        if (!contact) {
            continue;
        }

        if (!collided0 && maxImpulse > 5) {

            //threeObject0.scale.set(.5,.5,.5)
            //  threeObject0.material = createMaterial()
            testCollisionRules(threeObject1, threeObject0)
            userData0.collided = true;
            //objectsToRemove[ numObjectsToRemove++ ] = threeObject0;
        }


    }

    for (var i = 0; i < numObjectsToRemove; i++) {

        removeDebris(objectsToRemove[i]);

    }
    numObjectsToRemove = 0;

}

function testCollisionRules(attacker, victim) {

    // console.log('break it')
    /*      //console.log(contactPoint)
    console.log(attacker.name + " hit " + victim.name);

    console.log(victim)
    console.log(attacker)
    console.log('----------')
*/
    if (attacker.name == "bullet") {
        console.warn(attacker.name + " hit " + victim.name);
        if (victim.name != "ground") {
            victim.material = createMaterial()
            objectsToRemove[numObjectsToRemove++] = victim;
            objectsToRemove[numObjectsToRemove++] = attacker;
            playExplode();
            // addExplosion(victim.position);
            var exp = new Explosion(victim.position);
        }

        objectsToRemove[numObjectsToRemove++] = attacker;
        score++;
        score_display.innerHTML = score;

    } else {
        // console.log(attacker.name + " hit " + victim.name);
    }


    if (victim.name == "player" || attacker.name == "player") {

        
        if (attacker.name != "bullet" && victim.name != "tower" && victim.name != "brick") {
            console.error('OUCH!!!!!')
           // console.log(victim.name)
            console.log(attacker.name + " hit " + victim.name);
            console.log(victim.position)
            objectsToRemove[numObjectsToRemove++] = attacker;
            playArgh();
            player.animate('fall');
        }
    }

 //   attacker.material = createMaterial()


}



function removeDebris(object) {

   // console.log(object)

    scene.remove(object);

    physicsWorld.removeRigidBody(object.userData.physicsBody);

}
/*
function removePlayer() {

    //console.log(object)
    alert('removePlayer')

    scene.remove(playerblock);

    physicsWorld.removeRigidBody(playerBody);

}
*/


function TextureAnimator(texture, tilesHoriz, tilesVert, numTiles, tileDispDuration) {
    // note: texture passed by reference, will be updated by the update function.

    this.tilesHorizontal = tilesHoriz;
    this.tilesVertical = tilesVert;
    // how many images does this spritesheet contain?
    //  usually equals tilesHoriz * tilesVert, but not necessarily,
    //  if there at blank tiles at the bottom of the spritesheet. 
    this.numberOfTiles = numTiles;
    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(1 / this.tilesHorizontal, 1 / this.tilesVertical);



    // how long should each image be displayed?
    this.tileDisplayDuration = tileDispDuration;

    // how long has the current image been displayed?
    this.currentDisplayTime = 0;

    // which image is currently being displayed?
    this.currentTile = 0;

    this.animBehavior = false;
    /*
      this.setFrame = function( frame ){
        this.currentTile = frame;
        var currentColumn = this.currentTile % this.tilesHorizontal;
        texture.offset.x = currentColumn / this.tilesHorizontal;

      }
     */

    this.setFrame = function(xpos, ypos, state) {
        this.animBehavior = state;
        // console.log(xpos, ypos)
        var currentColumn = xpos % this.tilesHorizontal;
        texture.offset.x = currentColumn / this.tilesHorizontal;
        var currentRow = ypos % this.tilesVertical;
        //  console.log('currentRow =' + currentRow)
        texture.offset.y = currentRow / this.tilesVertical;

    }

    this.update = function(milliSec) {
        this.currentDisplayTime += milliSec;

        if (this.animBehavior == "once") {
            this.playOnce();
        } else if (this.animBehavior == "loop") {
            this.playLoop();
        }


    };

    this.playOnce = function() {
        while (this.currentDisplayTime > this.tileDisplayDuration) {
            this.currentDisplayTime -= this.tileDisplayDuration;
            if (this.currentTile < this.numberOfTiles - 1) {
                this.currentTile++;
                //   if (this.currentTile == this.numberOfTiles)
                //   this.currentTile = 0;
                var currentColumn = this.currentTile % this.tilesHorizontal;
                texture.offset.x = currentColumn / this.tilesHorizontal;
                //  var currentRow = Math.floor( this.currentTile / this.tilesHorizontal );
                // texture.offset.y = currentRow / this.tilesVertical;
            } else {
                //flash player
                //console.log(this.currentDisplayTime)
                // (Math.floor(this.currentDisplayTime)% 2 == 0)? this.opacity=.2 : this.opacity= 1;
            }
        }
    }

    this.playLoop = function() {
        while (this.currentDisplayTime > this.tileDisplayDuration) {

            this.currentDisplayTime -= this.tileDisplayDuration;
            this.currentTile++;
            if (this.currentTile == this.numberOfTiles)
                this.currentTile = 0;
            var currentColumn = this.currentTile % this.tilesHorizontal;
            texture.offset.x = currentColumn / this.tilesHorizontal;
            //  var currentRow = Math.floor( this.currentTile / this.tilesHorizontal );
            // texture.offset.y = currentRow / this.tilesVertical;
        }
    }



}

function loadFont() {

                var loader = new THREE.FontLoader();
                var typefile = 'fonts/' + fontName + '_' + fontWeight + '.typeface.json';
                console.log(typefile);
                loader.load( typefile, function ( response ) {

                    font = response;

                   // refreshText();

                    //generateLetters();
                    createLetter('V')
                    createLetter('R')

                } );

            }

function createLetter(letter, speed){
                console.log(letter)
                textGeo = new THREE.TextGeometry( letter, {

                    font: font,

                    size: size,
                    height: height,
                    curveSegments: curveSegments,

                    bevelThickness: bevelThickness,
                    bevelSize: bevelSize,
                    bevelEnabled: bevelEnabled,

                    material: 0,
                    extrudeMaterial: 1

                });

                textGeo.computeBoundingBox();
                textGeo.computeVertexNormals();


                var centerOffset = -0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );

              /*  textMesh1 = new THREE.Mesh( textGeo, materials );

                textMesh1.position.x = centerOffset;
               // textMesh1.position.y = hover+ height*8;
               // textMesh1.position.z = 0;

                textMesh1.rotation.x = 0;
                textMesh1.rotation.y = Math.PI * 2;
                */
                var xpos;
                if(letter=='R') {
                        xpos = .45; 
                    }else{
                        xpos=.1;
                    }

                var letter = new THREE.Mesh( textGeo, createMaterial( 0x333333 ) );
                letterArr.push(letter);

                scene.add(letter);
                
                    console.log(xpos)
                    letter.position.x = Math.random()*4- 2;
                    letter.position.y = Math.random()*8 - 4;
                    letter.position.z = Math.random()*20;

                    letter.rotation.x = (Math.PI/180)*(Math.random()*180);
                    letter.rotation.y = (Math.PI/180)*(Math.random()*180);
                    letter.rotation.z = (Math.PI/180)*(Math.random()*180);

                    letter.scale.set(.005,.005,.005)

                    var dur;
                    if (speed){
                        dur = speed;
                    }else{
                        dur = 1+ Math.random()*10;
                    }
                    var delay = Math.random();
                    dur = 1;

                    

                    TweenMax.to(letter.position, dur,{
                       // z:depth,
                        x:xpos,
                        y:1.1,
                        z:-2,
                        delay: 1,//delay,
                        ease:"Power3.easeOut",
                        onUpdate:function(){
                           // no_geom.verticesNeedUpdate = true;
                            
                      //  console.log('tweened');
                    }});

                    TweenMax.to(letter.rotation, dur,{
                       // z:depth,
                        x:0,
                        y:0,
                        z:0,
                        delay: 1,//delay,
                        ease:"Power3.easeOut",
                        onUpdate:function(){
                           // no_geom.verticesNeedUpdate = true;
                            
                      //  console.log('tweened');
                    }});
                  
            }

function cleanupPhysics(){

     for (var i = 0; i < rigidBodies.length; i++) {

        removeDebris(rigidBodies[i]);

    }
    rigidBodies = [];
    
}

function startGame(){
    gameOn = true;
    playGetReady()
    addPlayer();
    createObjects();
    
   // document.getElementById('intro').style.display = "none";
    removeTitleScreen();
    player.animate('fly');
 

}

function resetGame(){
    gameOn = false;
  //  console.log(rigidBodies.length)
    cleanupPhysics();
    scene.remove(pivot);
   // camera.rotation.set(0,0,0)
   // document.getElementById('intro').style.display = "flex";
    createTitleScreen();
   // console.log(physicsWorld)
}

loadBkgd();
loadGetReady();
//playBkgd();
loadSound();
loadArgh();
loadExplode();
init();
initPhysics();
initInput();
createGround();
/*
addPlayer();
createObjects();
initInput();
*/

//addExplosion();

document.getElementById('reset').addEventListener('click', resetGame, false)

//
</script>

</html>
