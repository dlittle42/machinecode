<!DOCTYPE html>

<html lang="en">
<head>
<title>Space Harrier VR</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<style>
body {
  width: 100%;
  height: 100%;
  background-color: #bd8ef8;
  color: #fff;
  margin: 0px;
  padding: 0;
  overflow: hidden;
}
#info{
  position: absolute;
  top: 10px;
  left: 10px;
  z-index: 101;
}
/*
* {cursor: none;}
*/
</style>
</head>

<body>
<div id='info'></div>
<div id='tally'></div>

</body>

<script id="vertexShader" type="x-shader/x-vertex">
varying vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
}
  </script>
  
  <script id="fragmentShader" type="x-shader/x-fragment">
uniform vec3 color1;
uniform vec3 color2;
uniform float scale;
varying vec2 vUv;
void main() {
  vec2 center = -1.0 + 2.0 * vUv;
  vec2 uv = floor(center.xy * scale);
  if(mod(uv.x + uv.y, 2.0) > 0.5){
    gl_FragColor = vec4(color1, 1.0);
  }else{
    gl_FragColor = vec4(color2, 1.0);
  }
}
  </script>

<script>
/*
 * Debug parameters.
 */
WebVRConfig = {
  /**
   * webvr-polyfill configuration
   */

  // Forces availability of VR mode.
 // FORCE_ENABLE_VR: true, // Default: false.
  // Complementary filter coefficient. 0 for accelerometer, 1 for gyro.
  //K_FILTER: 0.98, // Default: 0.98.
  // How far into the future to predict during fast motion.
  //PREDICTION_TIME_S: 0.040, // Default: 0.040 (in seconds).
  // Flag to disable touch panner. In case you have your own touch controls
  //TOUCH_PANNER_DISABLED: true, // Default: false.
  // Enable yaw panning only, disabling roll and pitch. This can be useful for
  // panoramas with nothing interesting above or below.
  YAW_ONLY: true, // Default: false.
  // Enable the deprecated version of the API (navigator.getVRDevices).
  //ENABLE_DEPRECATED_API: true, // Default: false.
  // Scales the recommended buffer size reported by WebVR, which can improve
  // performance. Making this very small can lower the effective resolution of
  // your scene.
  BUFFER_SCALE: 1, // default: 1.0
  // Allow VRDisplay.submitFrame to change gl bindings, which is more
  // efficient if the application code will re-bind it's resources on the
  // next frame anyway.
  // Dirty bindings include: gl.FRAMEBUFFER_BINDING, gl.CURRENT_PROGRAM,
  // gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING,
  // and gl.TEXTURE_BINDING_2D for texture unit 0
  // Warning: enabling this might lead to rendering issues.
  //DIRTY_SUBMIT_FRAME_BINDINGS: true // default: false
};
</script>

<!--
  A polyfill for Promises. Needed for IE and Edge.
  -->
<script src="node_modules/es6-promise/dist/es6-promise.js"></script>

<!--
  three.js 3d library
  -->
<script src="node_modules/three/build/three.min.js"></script>

<!--
  VRControls.js acquires positional information from connected VR devices and applies the transformations to a three.js camera object.
 -->
<script src="node_modules/three/examples/js/controls/VRControls.js"></script>


<!--
<script src="node_modules/three/examples/js/controls/OrbitControls.js"></script>
-->

<!--
<script src="node_modules/three/examples/js/controls/DeviceOrientationControls.js"></script>
-->
<!--
  VREffect.js handles stereo camera setup and rendering.
  -->
<script src="node_modules/three/examples/js/effects/VREffect.js"></script>

<!--
  A polyfill for WebVR using the Device{Motion,Orientation}Event API.
  -->
<script src="node_modules/webvr-polyfill/build/webvr-polyfill.js"></script>

<!--
  Helps enter and exit VR mode, provides best practices while in VR.
  -->
<script src="build/webvr-manager.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.19.0/TweenMax.min.js"></script>
<!--
<script src="build/threejs-texture-checkerboard.js"></script>
-->
<script src="node_modules/howler/dist/howler.min.js"></script>


<script src="../../bower_components/three.js/examples/js/libs/stats.min.js"></script>

<script src="../../bower_components/dat.gui/dat.gui.js"></script>



<script>

var forceVR = false;//true;
var debug = true;

var renderer, scene, camera, controls, effect, manager, loader;
var pivot, player, player_sprite;

var mouse = new THREE.Vector2();
var uTime;
var helper;
var blaster;
var blasterMaterial;
var blasterArr = [];
var arrowArr = [];

var info = document.getElementById('info');
var tally = document.getElementById('tally');
var sound, getReady, explode;

var shadowMaterial;

var hemisphereLight, shadowLight;
var floorMaterial, floorPlane;
var floor = [];
var checkerTexture;
var xA = 0;
var yA = 0;
var accX = 0;
var accY= 0;
var accZ = 0;

var vantagePoint = 1;
var playerDepth = -2;

// Request animation frame loop function
var lastRender = 0;

var vrDisplay;

var accZsmooth = 0;
var accYsmooth = 0;
var factor = .98;

//var gui = new dat.GUI();


// Keeps track of time
//    var clock = new THREE.Clock();

var playerVector = new THREE.Vector3();
var camVector = new THREE.Vector3();


//var raycaster, INTERSECTED;
var raycaster = new THREE.Raycaster();


var Colors = {
  red:0xf25346,
  white:0xd8d0d1,
  brown:0x59332e,
  pink:0xF5986E,
  brownDark:0x23190f,
  blue:0x68c3c0,
};


//from textureAnimation
// standard global variables
//var container, scene, camera, renderer, controls, stats;
//var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();

// custom global variables
var annie, hero; // animators

var enemyPool=[];
var enemyRaygunArr=[];

var gui;

var player;

var sceneHUD, cameraHUD;

var windowWidth, windowHeight;
var mouseX = 0, mouseY = 0;

var options  = {
                

        speed            : 0.1,

        sprite_horizontal : 0,

        sprite_vertical : 0,

       // segments         : 324,
        attack: false,

        flicker: false,

        checker_color1     : '#76c876',

        checker_color2     : '#a7f9a7',

        die: false,

        run: false,

        fall: false,

        fly: false,

      //  scale            : 1,

      //  perlin_passes    : 1,

        numEnemies        : 10,

      //  floor_visible    : true

    };

// GAME VARIABLES
var game;
var deltaTime = 0;
var newTime = new Date().getTime();
var oldTime = new Date().getTime();
var enemiesPool = [];
var particlesPool = [];
var particlesInUse = [];

var collidableMeshList = [];

// shader for checkerboard

var uniforms = {
      "color1" : {
        type : "c",
        value : new THREE.Color(0x76c876)
      },
      "color2" : {
        type : "c",
        value : new THREE.Color(0xa7f9a7)
      },
      "scale" : {
        type : "f",
        value : 80,
        min : 1, // only used for dat.gui, not needed for production
        max : 100 // only used for dat.gui, not needed for production
      },
    }
var vertexShader = document.getElementById('vertexShader').text;
var fragmentShader = document.getElementById('fragmentShader').text;
var checkerTexture = new THREE.ShaderMaterial(
        {
          uniforms : uniforms,
          vertexShader : vertexShader,
          fragmentShader : fragmentShader,
          side: THREE.DoubleSide
         // doubleSide: true,
        });

var views = [
        {
          left: 0,
          bottom: 0,
          width: 0.5,
          height: 1.0,
          background: new THREE.Color().setRGB( 0.5, 0.5, 0.7 ),
          eye: [ 0, 300, 1800 ],
          up: [ 0, 1, 0 ],
          fov: 30,
          updateCamera: function ( camera, scene, mouseX, mouseY ) {
            camera.position.x += mouseX * 0.05;
            camera.position.x = Math.max( Math.min( camera.position.x, 2000 ), -2000 );
            camera.lookAt( scene.position );
          }
        },
        {
          left: 0.5,
          bottom: 0,
          width: 0.5,
          height: 0.5,
          background: new THREE.Color().setRGB( 0.7, 0.5, 0.5 ),
          eye: [ 0, 1800, 0 ],
          up: [ 0, 0, 1 ],
          fov: 45,
          updateCamera: function ( camera, scene, mouseX, mouseY ) {
            camera.position.x -= mouseX * 0.05;
            camera.position.x = Math.max( Math.min( camera.position.x, 2000 ), -2000 );
            camera.lookAt( camera.position.clone().setY( 0 ) );
          }
        },
        {
          left: 0.5,
          bottom: 0.5,
          width: 0.5,
          height: 0.5,
          background: new THREE.Color().setRGB( 0.5, 0.7, 0.7 ),
          eye: [ 1400, 800, 1400 ],
          up: [ 0, 1, 0 ],
          fov: 60,
          updateCamera: function ( camera, scene, mouseX, mouseY ) {
            camera.position.y -= mouseX * 0.05;
            camera.position.y = Math.max( Math.min( camera.position.y, 1600 ), -1600 );
            camera.lookAt( scene.position );
          }
        }
      ];


function resetGame(){
  game = {speed:0,
          initSpeed:.00035,
          baseSpeed:.00035,
          targetBaseSpeed:.00035,
          incrementSpeedByTime:.0000025,
          incrementSpeedByLevel:.000005,
          distanceForSpeedUpdate:100,
          speedLastUpdate:0,

          distance:0,
          ratioSpeedDistance:50,
          energy:100,
          ratioSpeedEnergy:3,

          level:1,
          levelLastUpdate:0,
          distanceForLevelUpdate:1000,

          enemyDistanceTolerance:10,
          enemyValue:10,
          enemiesSpeed:.6,
          enemyLastSpawn:0,
          distanceForenemiesSpawn:50,

          status : "playing",
         };
  //fieldLevel.innerHTML = Math.floor(game.level);
}

function loadSound(){
  sound = new Howl({
    src: ['../_audio/boing.mp3'],
    volume: 0.5
  });
  //sound.play();

}

function playSound(){
  sound.play();
}

function loadGetReady(){

  getReady = new Howl({
    src: ['audio/ready.mp3']
  });
 // getReady.play();

}

function playGetReady(){
  getReady.play();
}

function loadExplode(){

  explode = new Howl({
    src: ['audio/explode.mp3']
  });
  //explode.play();

}

function playExplode(){
  explode.play();
}

function muteAll(){
  howler.mute();
}

function init(){



    // Setup three.js WebGL renderer. Note: Antialiasing is a big performance hit.
    // Only enable it if you actually need to.
    renderer = new THREE.WebGLRenderer({antialias: false});
    renderer.setPixelRatio(window.devicePixelRatio);


    // Append the canvas element created by the renderer to document body element.
    document.body.appendChild(renderer.domElement);

    // Create a three.js scene.
    scene = new THREE.Scene();

    scene.background = new THREE.Color( 0xbd8ef8 );


    for (var ii =  0; ii < views.length; ++ii ) {
          var view = views[ii];
          camera = new THREE.PerspectiveCamera( view.fov, window.innerWidth / window.innerHeight, 1, 10000 );
          camera.position.x = view.eye[ 0 ];
          camera.position.y = view.eye[ 1 ];
          camera.position.z = view.eye[ 2 ];
          camera.up.x = view.up[ 0 ];
          camera.up.y = view.up[ 1 ];
          camera.up.z = view.up[ 2 ];
          view.camera = camera;
        }


    // Create a three.js camera.
   // camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);


    let helper = new THREE.CameraHelper(camera);
    scene.add(helper);

    controls = new THREE.VRControls(camera);
    controls.userHeight = vantagePoint;
    controls.standing = true;
    //controls.standing = true;

    // Apply VR stereo rendering to renderer.
    effect = new THREE.VREffect(renderer);
    effect.setSize(window.innerWidth, window.innerHeight);

    // Create a VR manager helper to enter and exit VR mode.
    var params = {
      hideButton: false, // Default: false.
      isUndistorted: false // Default: false.
    };
    manager = new WebVRManager(renderer, effect, params);

    
    var blasterTexture = new THREE.TextureLoader().load( "img/blaster.png" );
  //annie = new TextureAnimator( shadowTexture, 10, 1, 10, 75 ); // texture, #horiz, #vert, #total, duration.
    blasterMaterial = new THREE.MeshBasicMaterial( { map: blasterTexture, side:THREE.DoubleSide, color: 0xffffff, opacity: 1, transparent: true } );
 


    setupStage();
    createLights();

   // setupGround();

    setupFloor();
    spawnEnemies(10);
   // player = new Player("img/hero-spritesheet.png", 0, true);

    window.addEventListener('resize', onResize, true);
    window.addEventListener('vrdisplaypresentchange', onResize, true);

    document.addEventListener( 'click', createBlaster, true );
    document.addEventListener( 'touchstart', createBlaster, true );

    document.addEventListener( 'mousemove', onDocumentMouseMove, false );
  
      
}

function onDocumentMouseMove( event ) {
        mouseX = ( event.clientX - windowWidth / 2 );
        mouseY = ( event.clientY - windowHeight / 2 );
      }





// Create 3D objects.
/*
var geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
//var material = new THREE.MeshNormalMaterial();
var cube = new THREE.Mesh(geometry, material);

// Position cube mesh to be right in front of you.
cube.position.set(0, controls.userHeight, -1);

// Add cube mesh to your three.js scene
scene.add(cube);
*/


function addWorldBox(){
  var r = 1;
  worldBox = new THREE.BoxHelper( new THREE.Mesh( new THREE.BoxGeometry( r, r, r)));
  worldBox.material.color.setHex( 0x080808);
  //worldBox.material.blending = THREE.AdditiveBlending;
  //worldBox.position.set(0, controls.userHeight, 0);
 // worldBox.position.z = -1;
 // worldBox.scale.set( .2, .2, .2);

  scene.add(worldBox)
}


function createShadow(){
  console.log('createShadow')
  //var shadowMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff, side: THREE.DoubleSide } );
  var shadowMaterial = new THREE.MeshPhongMaterial( { color: 0x43e206, specular: 0x009900, opacity: 0.5, transparent: true,shininess: 10, shading: THREE.FlatShading } )
  var geometry = new THREE.PlaneGeometry(2,1,30,30);

  var shadow = new THREE.Mesh( geometry,shadowMaterial );
  //shadow.position.z = playerDepth;
  //shadow.position.y=1;
  player.add(shadow);
    //plane.position.y = -2;
  shadow.rotation.x = -Math.PI/2;
  shadow.position.y = - controls.userHeight;
}
/*
function setPlayerTexture(playerTexture){
  console.log('createPlayer')
  //var playerTexture = THREE.ImageUtils.loadTexture( 'img/Space_Harrier_player_sprite.png' );
 // var playerMaterial = new THREE.SpriteMaterial( { map: playerTexture, color: 0xffffff } );
  var playerMaterial = new THREE.MeshBasicMaterial( { map: playerTexture, color: 0xffffff, side: THREE.DoubleSide } );
  playerMaterial.transparent = true;
  var geometry = new THREE.PlaneGeometry(1,1,30,30);
  player = new THREE.Mesh( geometry, playerMaterial );
  //player.rotation.x = Math.PI/10;
  player.castShadow = true;


 // player = new THREE.Sprite( playerMaterial );


  //player.position.set(0, controls.userHeight, -1);
  player.position.z = playerDepth;

//  player.scale.set( .5, .5, 1.0 ); // imageWidth, imageHeight

  pivot = new THREE.Object3D();
  pivot.position.set(0, controls.userHeight, 0);
  scene.add(pivot);
  pivot.add(player);




  var material = new THREE.MeshLambertMaterial( { color: 0x42f445, opacity: 0.2, transparent: true, side: THREE.DoubleSide, wireframe: false } );

 // var material = new THREE.MeshLambertMaterial( { color: 0x42f445, wireframe: false } );

  var geometry = new THREE.BoxGeometry(1,1,1);
  var helper = new THREE.Mesh(geometry, material);
  helper.position.z = playerDepth;

 //  helper.scale.set( .2, .2, .2);
   helper.castShadow = true;


  pivot.add(helper);

  if (debug ==false) helper.visible = false;

  
  // position the object on the pivot, so that it appears 5 meters 
  // in front of the user.

  //controlPlayer(0,0);


  //scene.add( player );

  setupStage();

}
*/

function Player(img, xpos, sprite){

  console.log("New Player")

  //var playerTexture = new THREE.TextureLoader().load( "img/player_small_128.png" );
  var playerTexture = new THREE.TextureLoader().load( img);
  if (sprite) hero = new TextureAnimator( playerTexture, 4, 4, 3, 75 );
  //annie = new TextureAnimator( playerTexture, 10, 1, 10, 75 ); // texture, #horiz, #vert, #total, duration.
  var playerMaterial = new THREE.MeshBasicMaterial( { map: playerTexture, side:THREE.DoubleSide, color: 0xffffff } );
  playerMaterial.transparent = true;

 // playerMaterial.map.offset = new THREE.Vector2(0.25 * 1, 0);
 // playerMaterial.map.repeat = new THREE.Vector2(1 / 4, 1);
  //fixes flicker when planes intersect
  playerMaterial.depthTest= true
  playerMaterial.depthWrite= false
  playerMaterial.polygonOffset= true
  playerMaterial.polygonOffsetFactor= -4
  /// end fix
  var playerGeometry = new THREE.PlaneGeometry(1, 1, 10, 10);
  var player = new THREE.Mesh(playerGeometry, playerMaterial);
  player.position.set(0,controls.userHeight,playerDepth);
  scene.add(player);

  this.mesh = player;
  this.start=0;
  this.shadow = new Shadow(player.position);
  this.dist = Math.random()*60;

  this.update = function(){
    //console.log('player update')

  }

  this.animate = function(state, loops){
    console.log('player animate')
    //this.tilesHorizontal =3;
    hero.currentTile = 0;
    hero.numberOfTiles =3;
    if (state=="fly"){
      console.log("fly")
      hero.setFrame(0,3, 'freeze');

    }else if (state=="run"){
      console.log("run")
      hero.setFrame(0,2, 'loop');

    }else if (state=="fall"){
      console.log("fall")
      hero.setFrame(0,1, 'once');
      this.flicker();

    }else if(state=="die"){
      console.log("die")
      //this.tilesHorizontal =4;
      hero.numberOfTiles =4;
      hero.setFrame(0,0, 'once');
      this.flicker();

    }
  }

  this.flicker = function(){
    TweenMax.to(this.mesh.material, .1, {opacity: 0, delay: .4,repeat: 7, yoyo: true });
  }

}

function animate(timestamp) {

  var delta = clock.getDelta();

  getWorldRotation();
 // var delta = Math.min(timestamp - lastRender, 500);
 // lastRender = timestamp;
  //uTime = timestamp;

  // Apply rotation to cube mesh
 // cube.rotation.y += delta * 0.0006;
// playerVector.setFromMatrixPosition( player.matrixWorld );

//console.log(blasterArr)
//console.log(collidableMeshList)

 for(var i=0; i<blasterArr.length; i++) {

   // console.log(blasterArr[i].raycaster)
    blasterArr[i].raycaster.set(blasterArr[i].from, blasterArr[i].to);


    raycaster.set(blasterArr[i].from, blasterArr[i].to);
    var blasterCollision = blasterArr[i].raycaster.intersectObjects( collidableMeshList );

    
    //if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) 
    if ( blasterCollision.length > 0) {
        tally.innerHTML = "bullet hit"
        console.log('-//------')
        console.log(" BLASTED " + blasterCollision[0].object.name);
        console.log(" EXploded at "+blasterCollision[0].object.position.z);
        console.log(blasterCollision[0].distance)
        blasterCollision[0].object.material.color = new THREE.Color(0x0066CC);
       // blasterArr[i].active=false;
       // scene.remove(blasterCollision[0].object);
        console.log('------//-')
        console.log(blasterCollision[0].object)
       // scene.remove(blasterCollision[0]);
       // collidableMeshList.splice(collidableMeshList.indexOf(blasterCollision[0].object), 1);
        collidableMeshList.splice(collidableMeshList.indexOf(blasterCollision[0].object), 1);
      //  console.log(collidableMeshList);
        scene.remove(blasterArr[i]);
        blasterArr.splice(i, 1);
      //  playExplode();
    }else{
     
    //  blasterArr[i].position.x += blasterArr[i].blasterDir.x * options.blasterSpeed;
      //blasterArr[i].position.y += blasterArr[i].blasterDir.y * blasterSpeed;
     // blasterArr[i].position.y += (blasterArr[i].blasterDir.y - blasterArr[i].position.y) * blasterSpeed;
    //  blasterArr[i].position.z += blasterArr[i].blasterDir.z * options.blasterSpeed;

     // if (i==0) console.log(blasterArr[i].position.z);
     // if (timestamp - blasterArr[i].time > 1000) {
      //  scene.remove(blasterArr[i]);
     //   blasterArr.splice(i, 1);
//
     // }
      
      
    }
    



 }

/*
  for(var i=0; i<arrowArr.length; i++) {
      if (timestamp - arrowArr[i].time > 3000) {
          scene.remove(arrowArr[i]);
          arrowArr.splice(i, 1);

        }
  }
*/
 //if (enemiesPool.length > 0 ) updateEnemies();
// annie.update(700 * delta);
//  hero.update(700*delta);

  for (var i=0; i<enemyPool.length; i++){
    var nEnemy = enemyPool[i];
    nEnemy.update();
  }

  controls.update(delta);
  // Render the scene through the manager.
 // manager.render(scene, camera, timestamp);
 // effect.render(scene, camera);

  // Update the scene through the manager.
 // manager.render(scene, camera);
 // manager.render(sceneHUD, cameraHUD);
 renderer.render( scene, camera );
/*
  for ( var ii = 0; ii < views.length; ++ii ) {
          view = views[ii];
          camera = view.camera;
          view.updateCamera( camera, scene, mouseX, mouseY );
          var left   = Math.floor( windowWidth  * view.left );
          var bottom = Math.floor( windowHeight * view.bottom );
          var width  = Math.floor( windowWidth  * view.width );
          var height = Math.floor( windowHeight * view.height );
          renderer.setViewport( left, bottom, width, height );
          renderer.setScissor( left, bottom, width, height );
          renderer.setScissorTest( true );
          renderer.setClearColor( view.background );
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
         // renderer.render( scene, camera );
        //  manager.render( scene, camera );
        }
*/



  // effect.render(scene, camera);

  // Call the render function again
//  requestAnimationFrame( render );

  
  //player.position.set(0, controls.userHeight, -1);
 // pivot.rotation.y = camera.rotation.y;
  //console.log(camera.rotation.y)

 // pivot.rotation.copy( camera.rotation );
//  pivot.updateMatrix();


  //pivot.applyQuaternion(camera.quaternion);
/*
  var yaxis = new THREE.Vector3(0, 1, 0);
var zaxis = new THREE.Vector3(0, 0, 1);
var direction = zaxis.clone();
// Apply the camera's quaternion onto the unit vector of one of the axes
// of our desired rotation plane (the z axis of the xz plane, in this case).
direction.applyQuaternion(camera.quaternion);
// Project the direction vector onto the y axis to get the y component
// of the direction.
var ycomponent = yaxis.clone().multiplyScalar(direction.dot(yaxis));
// Subtract the y component from the direction vector so that we are
// left with the x and z components.
direction.sub(ycomponent);
// Normalize the direction into a unit vector again.
direction.normalize();
// Set the pivot's quaternion to the rotation required to get from the z axis
// to the xz component of the camera's direction.
pivot.quaternion.setFromUnitVectors(zaxis, direction);
*/
/*
  var vec = new THREE.Vector3( 0, 0, -1 );
  vec.applyQuaternion( camera.quaternion );

  pivot.rotation.copy( vec );


  var vector = camera.getWorldDirection();
  var theta = Math.atan2(vector.x,vector.z);
*/
/*
  var startRotation = new THREE.Euler().copy( camera.rotation );
  pivot.rotation.copy(startRotation)
  */
 // pivot.rotation.z = camera.rotation.z;


 // helper.rotation.y = camera.rotation.y;
 // helper.rotation.x = camera.rotation.x;
/*
  for(var i=0; i<floor.length; i++) {
      
      ground = floor[i]; 
        
      // move it forward by a 10th of its array position each time 
      ground.position.z +=  0.5;
        
      // once the star is too close, reset its z position
      if(ground.position.z>400) ground.position.z-=1600;   
  }

*/
 // console.log(camera.rotation)

/*
 var camDir = camera.getWorldDirection();

 for(var i=0; i<blasterArr.length; i++) {
    blasterArr[i].position.x += camDir.x * blasterSpeed;
    blasterArr[i].position.y += camDir.y * blasterSpeed;
    blasterArr[i].position.z += camDir.z * blasterSpeed;
    if (timestamp - blasterArr[i].time > 1000) {
      scene.remove(blasterArr[i]);
      blasterArr.splice(i, 1);
    }

 }
*/
// player.position.x = xA;
 //player.position.y = yA;  



//console.log(yA)
 
 //info.textContent = "x:"+vrDisplay.orientation_.x.toFixed(2)+",y:"+vrDisplay.orientation_.y.toFixed(2)+",z:"+vrDisplay.orientation_.z.toFixed(2);

 

// console.log(vrDisplay.orientation_)

  vrDisplay.requestAnimationFrame(animate);
}

function onResize(e) {
  effect.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
}



// Get the HMD, and if we're dealing with something that specifies
// stageParameters, rearrange the scene.
function setupStage() {
  navigator.getVRDisplays().then(function(displays) {
    if (displays.length > 0) {
      vrDisplay = displays[0];
      if (vrDisplay.stageParameters) {
        setStageDimensions(vrDisplay.stageParameters);
        // if (forceVR && manager.isVRcompatible){
          //  manager.enterVRMode_();
           // console.log(manager)
        // }
      }
      vrDisplay.requestAnimationFrame(animate);
    }
 //   console.log(vrDisplay.orientation_);
     // window.addEventListener("devicemotion", function(event) 
      
    // is mobile? has accelerometer?
    //if(window.DeviceMotionEvent) { 
   //   var util = new Util;
  //    console.log(util.isMobile)
  // bad mobile detection
    if(window.innerWidth < 769) { 
      console.log('isDeviceMotion')

      window.addEventListener("devicemotion", function(event) 
      {
        
          //accX = Math.round(event.accelerationIncludingGravity.x*10) / 10;  
          //accY = Math.round(event.accelerationIncludingGravity.y*10) / 10;  
         // accY = event.accelerationIncludingGravity.y;
        // if (manager.mode == 1){

          accZ = event.accelerationIncludingGravity.z; 
          accY = event.accelerationIncludingGravity.y;
          accZsmooth = factor * accZsmooth + (1 - factor) * accZ;
          accYsmooth = factor * accYsmooth + (1 - factor) * accY;

          if (debug) info.innerHTML = 'accZ:'+accZ.toFixed(2)+', accZsm:'+accZsmooth.toFixed(2)+', accY:'+accYsmooth.toFixed(2);
          
          movement = 2;
          
          if (manager.mode == 1){
            xA = -accYsmooth * movement;
            yA = - accZsmooth * .4;// *movement;
          }else{
            yA = accZsmooth * .5;// *movement;
            xA = -accYsmooth * .5
          }
          
       /*   }else{
            xA = 0;
            yA = 0;
            player.position.set(0,0,-2)

          }
          */
          
          //run();
      }, true);
      /*
      window.addEventListener("deviceorientation", function(event) 
      {
          
          var xValue = Math.round(event.gamma);
          var yValue = Math.round(event.beta);
          var Rotation = Math.round(event.alpha);

          info.innerHTML = 'x:'+xValue+', y:'+yValue+' ,rot:'+Rotation;
        //  info.innerHTML = "x:"+vrDisplay.orientation_.x.toFixed(2)+",y:"+vrDisplay.orientation_.y.toFixed(2)+",z:"+vrDisplay.orientation_.z.toFixed(2);
          var halfwidth= window.innerWidth/2;
          var newYPos = yValue/5;
          info.innerHTML += ' n:'+newYPos.toFixed(2);

          //for landscape, reverse x and y
          controlPlayer(newYPos, 0);



          
        }, true);
        */



    }    
  });
  
}


function onDocumentMouseMove( event ) {

  event.preventDefault();

  mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
  mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

  if (debug) info.innerHTML = 'x:'+mouse.x.toFixed(2)+', y:'+mouse.y.toFixed(2);

  //controlPlayer(-mouse.x.toFixed(2)*10)
  controlPlayer(mouse.x, mouse.y/2)

}

function controlPlayer(xAcc, yAcc){

   // accX = (xAcc*10) / 10;  
   // accY = (yAcc*10) / 10;  

    accX = xAcc*2;
    accY = yAcc;
    
    movement = 10;
    
    xA = -(accX);
    yA = -(accY / 10) * movement;



   //   player.position.x = xpos;
/*
     TweenMax.to(player.position ,50,{
            x:xpos,
           // y:0,
            ease:"Power3.easeOut",
            onUpdate:function(){
                      //  console.log('tweened');
            }
      });
      */
}
/*
function addLights() {
    var dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(100, 100, 50);
    scene.add(dirLight);
}
*/



function createBlaster(event){

  console.log('createBlaster')

//  var geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
//  var material = new THREE.MeshNormalMaterial();
//blaster = new THREE.Mesh(geometry, material);
var blasterTexture = new THREE.TextureLoader().load( "img/blaster.png" );
  //annie = new TextureAnimator( shadowTexture, 10, 1, 10, 75 ); // texture, #horiz, #vert, #total, duration.
    blasterMaterial = new THREE.MeshBasicMaterial( { map: blasterTexture, side:THREE.DoubleSide, color: 0xffffff, opacity: 1, transparent: true } );
 



  if (manager.mode == 3) event.preventDefault();
 // manager.enterVRMode_();
 // console.log(manager.mode)
 // console.log('createBlaster')
  /*
  if (manager.mode == 3){
    camera.fov = 25;

    camera.updateProjectionMatrix();
  }else{
    camera.fov = 75;
    camera.updateProjectionMatrix();

  }
  */
 // console.log(camera.getWorldDirection());

  //blaster = new THREE.Sprite( blasterMaterial );

  var blasterGeometry = new THREE.PlaneGeometry(.3, .2, 1, 1);
  var blaster = new THREE.Mesh(blasterGeometry, blasterMaterial);
  //blaster.position.z = -10;
  //blaster.position.x = 0;//player.position.x;
  //blaster.position.y = 0;//player.position.y;
 // blaster.scale.set( .2, .2, 1.0 );
  blaster.time = lastRender;
  
  //var distVector = playerVector.multiplyScalar(2);


  //projector.unprojectVector( vector, camera );
  //blaster.raycaster = new THREE.Raycaster(new THREE.Vector3(playerVector.x, playerVector.y, playerVector.z), new THREE.Vector3(distVector.x, playerVector.y, distVector.z));

  //var camDir = camera.getWorldDirection();
//  var scaleCam = camDir.multiplyScalar(1.1);

 // blaster.position.set(player.position.x, controls.userHeight + player.position.y, player.position.z - .1);


//  var vector = new THREE.Vector3();
//  vector.setFromMatrixPosition( player.matrixWorld );

  //blaster.position.set(playerVector.x , playerVector.y, playerVector.z );
  

  var camVector = new THREE.Vector3();

 // var origin = camera.getWorldDirection(camVector);
  var camDir1 = camera.getWorldDirection(camVector).multiplyScalar(10);
  
  var camDir = new THREE.Vector3(camDir1.x, camDir1.y + controls.userHeight, camDir1.z);


//console.log(origin)
  blaster.position.set(camera.position.x,camera.position.y,camera.position.z);
 // blaster.position.set(0,controls.userHeight,playerDepth);
  scene.add(blaster);
  console.log(blaster.position)


  blaster.blasterDir = camDir;//scaleCam;
  blaster.lookAt(camDir)


 blaster.raycaster = new THREE.Raycaster(new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z), new THREE.Vector3(camDir.x, camDir.y, camDir.z));

 console.log(blaster.raycaster)

  blaster.from = blaster.position;//new THREE.Vector3( 2, 2, 2 );
  blaster.to = blaster.blasterDir;//new THREE.Vector3( 0, controls.userHeight, -40);
  var direction = blaster.to.clone().sub(blaster.from);
  var length = direction.length();



  blasterArr.push(blaster);

 // blaster.lookAt(camDir)

  

  TweenMax.to(blaster.position,1, {
    x: camDir.x, 
    y: camDir.y,
    z: camDir.z,
    ease:"linear",
    onComplete:function(){

      scene.remove( blaster);
      var i = blasterArr.indexOf(blaster);
      blasterArr.splice(i, 1);
      
  }});

/*
  var camVector = new THREE.Vector3();

  var camDir1 = camera.getWorldDirection(camVector).multiplyScalar(20);
  var camDir = new THREE.Vector3(camDir1.x, controls.userHeight, camDir1.z);//.multiplyScalar(20);
 // camDir.setY(controls.userHeight)
 // console.log(camDir)
 //var camDir = new THREE.Vector3(0, .1, -4)
// var horizon = new THREE.Vector3(camDir.x, .02, camDir.z);
 //var scaleCam = horizon.multiplyScalar(2);

 blaster.blasterDir = camDir;//scaleCam;
 blaster.lookAt(camDir)

 blaster.raycaster = new THREE.Raycaster(new THREE.Vector3(playerVector.x, playerVector.y, playerVector.z),  blaster.blasterDir);

  blaster.from = blaster.position;//new THREE.Vector3( 2, 2, 2 );
  blaster.to = blaster.blasterDir;//new THREE.Vector3( 0, controls.userHeight, -40);
  var direction = blaster.to.clone().sub(blaster.from);
  var length = direction.length();


*/

  //blaster.raycaster = new THREE.Raycaster(new THREE.Vector3(playerVector.x, playerVector.y, playerVector.z),  blaster.blasterDir);

 // var direction = blaster.to.clone().sub(blaster.from);
//  var length = direction.length();

//  var arrowHelper = new THREE.ArrowHelper(new THREE.Vector3( 2, 2, 2 ), new THREE.Vector3( 0, 0, 0 ), 20, 0xff0000 );

   var originV3 = new THREE.Vector3(blaster.position.x, controls.userHeight-.01, blaster.position.z); 

   var arrowHelper = new THREE.ArrowHelper(direction.normalize(), originV3, 20, 0xff0000 );
  //  arrowHelper.time = lastRender;
  arrowHelper.line.material.linewidth = 5;

/*
  var directionV3 = new THREE.Vector3(1, 0, -10);
var originV3 = new THREE.Vector3(0, controls.userHeight-1, 0);

var arrowHelper = new THREE.ArrowHelper(directionV3, originV3, 100, 0xff0000, 20, 10); // 100 is length, 20 and 10 are head length and width

*/



  scene.add( arrowHelper );

  arrowArr.push( arrowHelper);




  //playSound();

}


function checkCollisions(b, vec, objects) {
    this.ray.set(b.position.clone(), vec);
    var collResults = this.ray.intersectObjects(objects, true);
    if (collResults.length > 0 && collResults[0].distance < 5) {
      console.log(collResults)
      var object = collResults[0].object;
      object.hit = true;
      this.removeBullet(b);
      return object;
    }
  }


function setupFloor(){
/*
   var geometry = new THREE.PlaneGeometry(5,5,30,30);

   var mesh = THREE.SceneUtils.createMultiMaterialObject( geometry, [

      new THREE.MeshLambertMaterial( { color: 0xff0000, opacity: 0.5, transparent: true} ),
      new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true} )

  ]);
   mesh.rotation.x = Math.PI/-2;
  // mesh.position.z=-10;
  scene.add(mesh);
  */

/*
  var planeGeometry = new THREE.PlaneGeometry( 20, 20, 32, 32 );
   // var planeMaterial = new THREE.MeshPhongMaterial( { color: 0x00dddd, specular: 0x009900, opacity: 0.5, transparent: true,shininess: 10, shading: THREE.FlatShading } )
    var planeMaterial = new THREE.MeshLambertMaterial( { color: 0xff0000, opacity: 0.5, transparent: true} )
    var plane = new THREE.Mesh( planeGeometry, planeMaterial );
  //  plane.receiveShadow = true;
    plane.opacity = .7;
    scene.add( plane );
    //plane.position.y = -2;
    plane.rotation.x = -Math.PI/2;

*/
    var floorGeometry = new THREE.PlaneGeometry(20, 20, 10, 10);
 // var floor = new THREE.Mesh(floorGeometry, floorMaterial);

  var floor = new THREE.Mesh(floorGeometry,checkerTexture)
 // floor.position.y = -0.5;
  floor.rotation.x = Math.PI / 2;
  scene.add(floor);
  

}

function createEnemy(ang){

  enemy = new Enemy();
  console.log('new enemy')

  enemy.mesh.scale.set( .65, .65, 1.0 ); // imageWidth, imageHeight

 // enemy.mesh.position.z = -1;//-Math.sin(enemy.angle)*enemy.distance;
  enemy.mesh.position.y = controls.userHeight;// + Math.random()*controls.userHeight ;
 // enemy.mesh.position.x = (Math.random()*10) - 5;// Math.cos(enemy.angle)*enemy.distance;
  //player.position.set(0, controls.userHeight, -1);
  //var ang = Math.random() * 10;
  enemy.angle = Math.random()*360;
  enemy.mesh.lookAt(camera);
  enemy.mesh.name = "enemy"+ang;
 // enemy.angle = - (ang*0.1);
 // enemy.distance = game.seaRadius + game.planeDefaultHeight + (-1 + Math.random() * 2) * (game.planeAmpHeight-20);
  enemy.mesh.position.z = Math.sin(enemy.angle)*10;//-5 + Math.sin(enemy.angle)*10;
  enemy.mesh.position.x = Math.random()*4 - 2;
 // enemy.mesh.position.x = Math.cos(enemy.angle)*10;
/*
  var r = 1;
  var geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
  var material = new THREE.MeshBasicMaterial({color:0xff0000, transparent:true, opacity:0.4, side: THREE.DoubleSide})
  //var material = new THREE.MeshNormalMaterial();
  var nhelper = new THREE.Mesh(geometry, material);
 
  
  enemy.mesh.add(nhelper);
  */
/*
  var nhelper = new THREE.BoxHelper( new THREE.Mesh( new THREE.BoxGeometry( r, r, r)));
  nhelper.material.color.setHex( 0x080808);
  nhelper.material.blending = THREE.AdditiveBlending;
  //helper.position.set(0, controls.userHeight, 0);
  
  enemy.mesh.add(nhelper);
  */

  scene.add(enemy.mesh);
  enemiesPool.push(enemy);
  collidableMeshList.push(enemy.mesh);
  console.log(collidableMeshList)
  //collidableMeshList.push(nhelper);
 
}

function spawnEnemies(num){
  for (var i=0; i<num; i++){
    var alien = new Enemy();
  }
}

function destroyAll(){
  console.log('destroyAll')
  for (var i=0; i<enemyPool.length; i++){
    console.log(enemyPool[i])
    enemyPool[i].destroy();

  }
  enemyPool=[];
}


function Enemy(){
  var enemyTexture = new THREE.TextureLoader().load( "img/enemy.png" );
  //annie = new TextureAnimator( enemyTexture, 10, 1, 10, 75 ); // texture, #horiz, #vert, #total, duration.
  var enemyMaterial = new THREE.MeshBasicMaterial( { map: enemyTexture, side:THREE.DoubleSide, color: 0xffffff } );
  enemyMaterial.transparent = true;
  //fixes flicker when planes intersect
  enemyMaterial.depthTest= true
  enemyMaterial.depthWrite= false
  enemyMaterial.polygonOffset= true
  enemyMaterial.polygonOffsetFactor= -4
  /// end fix
  var enemyGeometry = new THREE.PlaneGeometry(2, 1, 10, 10);
  var enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
  enemy.position.set((Math.random()*10) - 5,1,-5);
  scene.add(enemy);


  var bboxHelper = new THREE.BoxHelper(enemy, 0xffffff);
  scene.add(bboxHelper);




  this.mesh = enemy;
  enemyPool.push(this)
  this.start=0;
  this.shadow = new Shadow(enemy.position);
  this.dist = 5;//Math.random()*6;
  this.blaster = null;
  this.blasterInterval = Math.random()*50;


  collidableMeshList.push(this.mesh);

  this.update = function(){
   //   this.mesh.position.y = Math.sin(this.start)+2;
   //   this.mesh.position.z = -2+  (Math.cos(this.start)*this.dist)- this.dist/2;
      this.shadow.update();
      this.start+=options.speed;
      //console.log(this.start % this.blasterInterval)
    //  if (Math.floor(this.start % this.blasterInterval)==0) this.shoot();


  }

  this.destroy = function(){
    console.log('destroy')
    this.shadow.destroy();
    scene.remove(this.mesh);
    this.blaster =null;
    //enemyPool.splice(this, 1);
   // console.log(enemyPool)

  }

  this.shoot = function(){
    if (this.blaster==null) this.blaster = new Blaster(this);
  }

}


function Shadow(pos){

  var shadowTexture = new THREE.TextureLoader().load( "img/shadow.png" );
  //annie = new TextureAnimator( shadowTexture, 10, 1, 10, 75 ); // texture, #horiz, #vert, #total, duration.
  var shadowMaterial = new THREE.MeshBasicMaterial( { map: shadowTexture, side:THREE.DoubleSide, color: 0xffffff, opacity: 0.5, transparent: true } );

  var shadowGeometry = new THREE.PlaneGeometry(.01, .01, 1, 1);
  var shadow = new THREE.Mesh(shadowGeometry, shadowMaterial);
  shadow.position.set(pos.x,.1,-5);
  shadow.rotation.x = Math.PI / 2;
  scene.add(shadow);

  this.mesh = shadow;

  this.update = function(){
      this.mesh.position.x = pos.x;
      this.mesh.position.z = pos.z;
      var shadowScale = 1 + (40/pos.y);
      this.mesh.scale.set( shadowScale, shadowScale, 1.0 )
  


  }

  this.destroy = function(){
    scene.remove(this.mesh);

  }

}





function setupGround(){


    

    loader.load('img/checkerboard.jpg', function(texture){
        var floorTexture = texture;
        floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
        floorTexture.repeat.set( 10, 10 );
        var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
        addGround(floorMaterial);
    });


    


   
}


function addGround(floorMaterial){

    //create the ground material using MeshLambert Material
 //   var groundMat = new THREE.MeshLambertMaterial( {color: 0xffffff, side: THREE.DoubleSide}  );
    //create the plane geometry
   // var geometry = new THREE.PlaneGeometry(400,800,300,300);
    var geometry = new THREE.PlaneGeometry(5,5,300,300);
   // var geometry = new THREE.BoxGeometry(400, 10, 800);

          //create the ground form the geometry and material


    // for ( var z= -1600; z < 1600; z+=800 ) {
    
          
        /*  //make the terrain bumpy
          for (var i = 0, l = geometry.vertices.length; i < l; i++) {
            var vertex = geometry.vertices[i];
            var value = pn.noise(vertex.x / 10, vertex.y /10, 0);
            vertex.z = value *6;
          }
          //ensure light is computed correctly
          geometry.computeFaceNormals();
          geometry.computeVertexNormals();
        */
    

       //   var ground = new THREE.Mesh(geometry,groundMat); 

           var ground = new THREE.Mesh(geometry,floorMaterial); 
         // var ground = new THREE.Mesh(geometry,checkerTexture); 
          //rotate 90 degrees around the xaxis so we can see the terrain 
          ground.rotation.x = -Math.PI/-2;
          // Then set the z position to where it is in the loop (distance of camera)
        //  ground.position.y = -1;

          ground.receiveShadow = true;
          //add the ground to the scene
          scene.add(ground); 
          //finally push it to the stars array 
          floor.push(ground); 
   //   }


      /// alt versions
      /*
       // var geometry = new THREE.BoxGeometry(200, 200, 200);
        var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
       // material = new THREE.MeshBasicMaterial();
        //var floor = new THREE.Mesh(floorGeometry, material);
        var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
        floor.position.y = -0.5;
       floor.rotation.x = Math.PI / 2;
        scene.add(floor);
      */
    /*
    var floorTexture = new THREE.ImageUtils.loadTexture( 'img/checkerboard.jpg' );
    floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
    floorTexture.repeat.set( 10, 10 );
    var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
    var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
    var floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.position.y = -0.5;
    floor.rotation.x = Math.PI / 2;
    scene.add(floor);
    */
  }
function shadowLights(){
  //shadows
      var light = new THREE.PointLight( 0xffffff, 1, 100 );
      light.position.set( 0, 12, 0 );
      light.castShadow = true;
      light.shadow.mapSize.width = 1024;
      light.shadow.mapSize.height = 1024;

      light.shadow.camera.left = 500
      scene.add( light );

      var ambientLight = new THREE.AmbientLight( 0x151515 ); // soft white light
      scene.add( ambientLight );
}

function createLights() {
  // A hemisphere light is a gradient colored light; 
  // the first parameter is the sky color, the second parameter is the ground color, 
  // the third parameter is the intensity of the light
  hemisphereLight = new THREE.HemisphereLight(0xaaaaaa,0x000000, .9)
  
  // A directional light shines from a specific direction. 
  // It acts like the sun, that means that all the rays produced are parallel. 
  shadowLight = new THREE.DirectionalLight(0xffffff, .9);

  // Set the direction of the light  
  shadowLight.position.set(150, 350, 350);
  
  // Allow shadow casting 
  shadowLight.castShadow = true;

  // define the visible area of the projected shadow
  shadowLight.shadow.camera.left = -400;
  shadowLight.shadow.camera.right = 400;
  shadowLight.shadow.camera.top = 400;
  shadowLight.shadow.camera.bottom = -400;
  shadowLight.shadow.camera.near = 1;
  shadowLight.shadow.camera.far = 1000;

  // define the resolution of the shadow; the higher the better, 
  // but also the more expensive and less performant
  shadowLight.shadow.mapSize.width = 2048;
  shadowLight.shadow.mapSize.height = 2048;
  
  // to activate the lights, just add them to the scene
  scene.add(hemisphereLight);  
  scene.add(shadowLight);
}

function TextureAnimator(texture, tilesHoriz, tilesVert, numTiles, tileDispDuration) 
{ 
  // note: texture passed by reference, will be updated by the update function.
    
  this.tilesHorizontal = tilesHoriz;
  this.tilesVertical = tilesVert;
  // how many images does this spritesheet contain?
  //  usually equals tilesHoriz * tilesVert, but not necessarily,
  //  if there at blank tiles at the bottom of the spritesheet. 
  this.numberOfTiles = numTiles;
  texture.wrapS = texture.wrapT = THREE.RepeatWrapping; 
  texture.repeat.set( 1 / this.tilesHorizontal, 1 / this.tilesVertical );



  // how long should each image be displayed?
  this.tileDisplayDuration = tileDispDuration;

  // how long has the current image been displayed?
  this.currentDisplayTime = 0;

  // which image is currently being displayed?
  this.currentTile = 0;

  this.animBehavior=false;


  this.setFrame = function( xpos, ypos, state ){
    this.animBehavior = state;
    console.log(xpos, ypos)
    var currentColumn = xpos % this.tilesHorizontal;
    texture.offset.x = currentColumn / this.tilesHorizontal;
    var currentRow = ypos % this.tilesVertical;
    console.log('currentRow ='+ currentRow)
    texture.offset.y = currentRow / this.tilesVertical;

  }
    
  this.update = function( milliSec )
  {
    this.currentDisplayTime += milliSec;

    if (this.animBehavior == "once") {
      this.playOnce();
    }else if (this.animBehavior == "loop") {
      this.playLoop();
    }


  };

  this.playOnce = function(){
      while (this.currentDisplayTime > this.tileDisplayDuration)
    {
          this.currentDisplayTime -= this.tileDisplayDuration;
          if (this.currentTile < this.numberOfTiles-1){
              this.currentTile++;
           //   if (this.currentTile == this.numberOfTiles)
             //   this.currentTile = 0;
              var currentColumn = this.currentTile % this.tilesHorizontal;
              texture.offset.x = currentColumn / this.tilesHorizontal;
            //  var currentRow = Math.floor( this.currentTile / this.tilesHorizontal );
             // texture.offset.y = currentRow / this.tilesVertical;
           }else{
            //flash player
            //console.log(this.currentDisplayTime)
            // (Math.floor(this.currentDisplayTime)% 2 == 0)? this.opacity=.2 : this.opacity= 1;
           }
    }
  }

  this.playLoop = function(){
      while (this.currentDisplayTime > this.tileDisplayDuration)
    {

          this.currentDisplayTime -= this.tileDisplayDuration;
          this.currentTile++;
          if (this.currentTile == this.numberOfTiles)
            this.currentTile = 0;
          var currentColumn = this.currentTile % this.tilesHorizontal;
          texture.offset.x = currentColumn / this.tilesHorizontal;
        //  var currentRow = Math.floor( this.currentTile / this.tilesHorizontal );
         // texture.offset.y = currentRow / this.tilesVertical;
       }
  } 


  
}   

//function createBlaster(event){
function Blaster(shooter){


 // console.log(shooter)
 // var blasterTexture = new THREE.TextureLoader().load( "img/blaster.png" );
  //annie = new TextureAnimator( shadowTexture, 10, 1, 10, 75 ); // texture, #horiz, #vert, #total, duration.
 // var blasterMaterial = new THREE.MeshBasicMaterial( { map: blasterTexture, side:THREE.DoubleSide, color: 0xffffff, opacity: 1, transparent: true } );

  var blasterGeometry = new THREE.PlaneGeometry(.3, .2, 1, 1);
  var blaster = new THREE.Mesh(blasterGeometry, blasterMaterial);
  blaster.position.set(shooter.mesh.position.x , shooter.mesh.position.y, shooter.mesh.position.z );

  enemyRaygunArr.push(blaster);
  
  scene.add(blaster);


  TweenMax.to(blaster.position,1, {
  //  x: 0, 
   // y: 0,
    z: 5,
    ease:"linear",
    onComplete:function(){

      scene.remove( blaster);
      var i = enemyRaygunArr.indexOf(blaster);
      enemyRaygunArr.splice(i, 1);
      shooter.blaster =null;
  }});
  

 





 // blaster.time = lastRender;
  
/*

  blaster.position.set(playerVector.x , playerVector.y, playerVector.z );
  scene.add(blaster);

  blasterArr.push(blaster);

  var camVector = new THREE.Vector3();

  var camDir1 = camera.getWorldDirection(camVector).multiplyScalar(20);
  var camDir = new THREE.Vector3(camDir1.x, controls.userHeight, camDir1.z);//.multiplyScalar(20);


 blaster.blasterDir = camDir;//scaleCam;
 blaster.lookAt(camDir)

 blaster.raycaster = new THREE.Raycaster(new THREE.Vector3(playerVector.x, playerVector.y, playerVector.z),  blaster.blasterDir);

  blaster.from = blaster.position;//new THREE.Vector3( 2, 2, 2 );
  blaster.to = blaster.blasterDir;//new THREE.Vector3( 0, controls.userHeight, -40);
  var direction = blaster.to.clone().sub(blaster.from);
  var length = direction.length();

*/

}

function setDebug(bool){
    debug = bool;
    if (bool ==false) info.innerHTML = null;
}


function setStageDimensions(stage) {
  // Make the skybox fit the stage.
  /*
  var material = skybox.material;
 // scene.remove(skybox);

  // Size the skybox according to the size of the actual stage.
  var geometry = new THREE.BoxGeometry(stage.sizeX, boxSize, stage.sizeZ);
  skybox = new THREE.Mesh(geometry, material);

  // Place it on the floor.
  skybox.position.y = boxSize/2;
 // scene.add(skybox);
*/
  // Place the cube in the middle of the scene, at user height.
  player.position.set(0, controls.userHeight, -1);
}

/*
window.ondevicemotion = function(event) {
        
    accX = Math.round(event.accelerationIncludingGravity.x*10) / 10;  
    accY = Math.round(event.accelerationIncludingGravity.y*10) / 10;  
    
    movement = 1;
    
    xA = -(accX / 10) * movement;
    yA = -(accY / 10) * movement;
    
    
    //run();
    
}  
*/

/*
var shootDirection = new THREE.Vector3();
var shootVelo = 15;
var projector = new THREE.Projector();
function getShootDir(targetVec){
    var vector = targetVec;
    targetVec.set(0,0,1);
    projector.unprojectVector(vector, camera);
    var ray = new THREE.Ray(sphereBody.position, vector.sub(sphereBody.position).normalize() );
    targetVec.copy(ray.direction);
}

            window.addEventListener("click",function(e){
                if(controls.enabled==true){
                    var x = sphereBody.position.x;
                    var y = sphereBody.position.y;
                    var z = sphereBody.position.z;
                    var ballBody = new CANNON.Body({ mass: 1 });
                    ballBody.addShape(ballShape);
                    var ballMesh = new THREE.Mesh( ballGeometry, material );
                    world.add(ballBody);
                    scene.add(ballMesh);
                    ballMesh.castShadow = true;
                    ballMesh.receiveShadow = true;
                    balls.push(ballBody);
                    ballMeshes.push(ballMesh);
                    getShootDir(shootDirection);
                    ballBody.velocity.set(  shootDirection.x * shootVelo,
                                            shootDirection.y * shootVelo,
                                            shootDirection.z * shootVelo);

                    // Move the ball outside the player sphere
                    x += shootDirection.x * (sphereShape.radius*1.02 + ballShape.radius);
                    y += shootDirection.y * (sphereShape.radius*1.02 + ballShape.radius);
                    z += shootDirection.z * (sphereShape.radius*1.02 + ballShape.radius);
                    ballBody.position.set(x,y,z);
                    ballMesh.position.set(x,y,z);
                }
            });

*/

function getWorldRotation(){
  if (debug) info.innerHTML = camera.rotation.y;
}


function initHUD() {
    sceneHUD = new THREE.Scene();
    cameraHUD = new THREE.OrthographicCamera(-10.5, 10.5, 10.5, -10.5, -10, 10);
    cameraHUD.position.z = 5;
    sceneHUD.add(cameraHUD);

    var lineGeometry = new THREE.Geometry();
    lineGeometry.vertices.push(new THREE.Vector3(-10, -10, 0),
    new THREE.Vector3(10, -10, 0),
    new THREE.Vector3(10, 10, 0),
    new THREE.Vector3(-10, 10, 0),
    new THREE.Vector3(-10, -10, 0));
    var line = new THREE.Line(lineGeometry,
    new THREE.LineBasicMaterial({
        color: 0xffffff
    }));
    sceneHUD.add(line);
}

function initGUI() {

    gui = new dat.GUI();

    gui.values = {};

    gui.values.speed            = gui.add(options,'speed',0,1).step(0.1);

    gui.values.sprite_horizontal  = gui.add(options,'sprite_horizontal',0,3).step(1);

    gui.values.sprite_vertical  = gui.add(options,'sprite_vertical',0,3).step(1);

   // gui.values.scale            = gui.add(options,'scale',1,100).step(1.0);

    gui.values.attack = gui.add(options, 'attack');

    gui.values.flicker = gui.add(options, 'flicker');

    gui.values.numEnemies         = gui.add(options,'numEnemies',0,40).step(1);


    gui.values.checker_color1     = gui.addColor(options,'checker_color1');

    gui.values.checker_color2     = gui.addColor(options,'checker_color2');

    gui.values.run = gui.add(options, 'run');

    gui.values.fall = gui.add(options, 'fall');

    gui.values.die = gui.add(options, 'die');

    gui.values.fly = gui.add(options, 'fly');

  //  gui.values.wireframe = gui.add(options, 'wireframe');

  //  gui.values.floor_visible = gui.add(options, 'floor_visible');


/*
    gui.values.elevation.onChange(value => {

        uniforms.elevation.value = value;

    }
    );


    gui.values.wireframe.onChange(value => {

        plane_material.wireframe = value;

    }
    );

    gui.values.floor_visible.onChange(value => {

        groundMaterial.visible = value;

    }
    );

*/

  gui.values.attack.onChange(value => {

        //player.flicker()

       // spawnEnemies(options.numEnemies);

        for (var i=0; i<options.numEnemies; i++){
          //console.log(enemyPool[i]);
          var blast = new Blaster(enemyPool[i]);
        }
  
       // player.mesh.material.opacity = .5

      // var attacker = new Blaster(enemyPool[0].mesh)

    }
    );


  gui.values.flicker.onChange(value => {

        player.flicker()
       // player.mesh.material.opacity = .5

    }
    );

  gui.values.fly.onChange(value => {

        player.animate('fly');

    }
    );

    gui.values.run.onChange(value => {

        player.animate('run');

    }
    );

    gui.values.fall.onChange(value => {

        player.animate('fall');

    }
    );

    gui.values.die.onChange(value => {

        player.animate('die');

    }
    );

    gui.values.speed.onChange(value => {

        options.speed.value = value;

    }
    );

    gui.values.sprite_horizontal.onChange(value => {
      console.log('sprite change')
        options.sprite_horizontal.value = value;
        
       // hero.setFrame(value);
        hero.setFrame(value, options.sprite_vertical);

      //  hero.update();
       // console.log(hero.currentTile)

    }
    );

    gui.values.sprite_vertical.onChange(value => {
      console.log('sprite change')
        options.sprite_vertical.value = value;
        
       // hero.setFrame(value);
        hero.setFrame(options.sprite_horizontal, value);

      //  hero.update();
       // console.log(hero.currentTile)

    }
    );



    gui.values.checker_color1.onChange(value => {
        console.log('value');
        uniforms.color1.value = new THREE.Color(value);
    }
    );

    gui.values.checker_color2.onChange(value => {
        console.log('value');
        uniforms.color2.value = new THREE.Color(value);
    }
    );

    return gui.values.numEnemies.onFinishChange(value => {

      console.log(value);

      destroyAll();

      spawnEnemies(value);

       // scene.remove(plane_mesh);

      //  buildPlanes(value);

      //  scene.add(plane_mesh);
    }
    );
}
 // loadGetReady();
 // loadSound();
// resetGame();
//  loadGetReady();
//  loadSound();
 // loadExplode()
  initGUI();
  init();
  //initHUD();

</script>

</html>
