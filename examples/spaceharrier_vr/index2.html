<!DOCTYPE html>

<html lang="en">
<head>
<title>Space Harrier VR</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<style>
body {
  width: 100%;
  height: 100%;
  background-color: #bd8ef8;
  color: #fff;
  margin: 0px;
  padding: 0;
  overflow: hidden;
}
#info{
  position: absolute;
  top: 10px;
  left: 10px;
  z-index: 101;
}
/*
* {cursor: none;}
*/
</style>
</head>

<body>
<div id='info'></div>
<div id='tally'></div>

</body>

<script id="vertexShader" type="x-shader/x-vertex">
varying vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
}
  </script>
  
  <script id="fragmentShader" type="x-shader/x-fragment">
uniform vec3 color1;
uniform vec3 color2;
uniform float scale;
varying vec2 vUv;
void main() {
  vec2 center = -1.0 + 2.0 * vUv;
  vec2 uv = floor(center.xy * scale);
  if(mod(uv.x + uv.y, 2.0) > 0.5){
    gl_FragColor = vec4(color1, 1.0);
  }else{
    gl_FragColor = vec4(color2, 1.0);
  }
}
  </script>

<script>
/*
 * Debug parameters.
 */
WebVRConfig = {
  /**
   * webvr-polyfill configuration
   */

  // Forces availability of VR mode.
 // FORCE_ENABLE_VR: true, // Default: false.
  // Complementary filter coefficient. 0 for accelerometer, 1 for gyro.
  //K_FILTER: 0.98, // Default: 0.98.
  // How far into the future to predict during fast motion.
  //PREDICTION_TIME_S: 0.040, // Default: 0.040 (in seconds).
  // Flag to disable touch panner. In case you have your own touch controls
  //TOUCH_PANNER_DISABLED: true, // Default: false.
  // Enable yaw panning only, disabling roll and pitch. This can be useful for
  // panoramas with nothing interesting above or below.
  YAW_ONLY: true, // Default: false.
  // Enable the deprecated version of the API (navigator.getVRDevices).
  //ENABLE_DEPRECATED_API: true, // Default: false.
  // Scales the recommended buffer size reported by WebVR, which can improve
  // performance. Making this very small can lower the effective resolution of
  // your scene.
  BUFFER_SCALE: 1, // default: 1.0
  // Allow VRDisplay.submitFrame to change gl bindings, which is more
  // efficient if the application code will re-bind it's resources on the
  // next frame anyway.
  // Dirty bindings include: gl.FRAMEBUFFER_BINDING, gl.CURRENT_PROGRAM,
  // gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING,
  // and gl.TEXTURE_BINDING_2D for texture unit 0
  // Warning: enabling this might lead to rendering issues.
  //DIRTY_SUBMIT_FRAME_BINDINGS: true // default: false
};
</script>

<!--
  A polyfill for Promises. Needed for IE and Edge.
  -->
<script src="node_modules/es6-promise/dist/es6-promise.js"></script>

<!--
  three.js 3d library
  -->
<script src="node_modules/three/build/three.min.js"></script>

<!--
  VRControls.js acquires positional information from connected VR devices and applies the transformations to a three.js camera object.
 -->
<script src="node_modules/three/examples/js/controls/VRControls.js"></script>



<script src="node_modules/three/examples/js/controls/OrbitControls.js"></script>


<!--
<script src="node_modules/three/examples/js/controls/DeviceOrientationControls.js"></script>
-->
<!--
  VREffect.js handles stereo camera setup and rendering.
  -->
<script src="node_modules/three/examples/js/effects/VREffect.js"></script>

<!--
  A polyfill for WebVR using the Device{Motion,Orientation}Event API.
  -->
<script src="node_modules/webvr-polyfill/build/webvr-polyfill.js"></script>

<!--
  Helps enter and exit VR mode, provides best practices while in VR.
  -->
<script src="build/webvr-manager.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.19.0/TweenMax.min.js"></script>
<!--
<script src="build/threejs-texture-checkerboard.js"></script>
-->
<script src="node_modules/howler/dist/howler.min.js"></script>

<script src="node_modules/three/examples/js/utils/ShadowMapViewer.js"></script>

<script src="../../bower_components/dat.gui/dat.gui.js"></script>



<script>

var forceVR = false;//true;
var debug = true;

var renderer, scene, camera, controls, effect, manager, loader;
var pivot, player, player_sprite;

var mouse = new THREE.Vector2();
var uTime;
var helper;
var blaster;
var blasterArr = [];
var arrowArr = [];

var info = document.getElementById('info');
var tally = document.getElementById('tally');
var sound, getReady, explode;

var shadowMaterial;

var hemisphereLight, shadowLight;
var floorMaterial, floorPlane;
var floor = [];
var checkerTexture;
var xA = 0;
var yA = 0;
var accX = 0;
var accY= 0;
var accZ = 0;

var vantagePoint = 1;
var playerDepth = -2;

// Request animation frame loop function
var lastRender = 0;

var vrDisplay;

var accZsmooth = 0;
var accYsmooth = 0;
var factor = .98;

var gui = new dat.GUI();


// Keeps track of time
    var clock = new THREE.Clock();

var playerVector = new THREE.Vector3();
var camVector = new THREE.Vector3();


//var raycaster, INTERSECTED;
var raycaster = new THREE.Raycaster();


var Colors = {
  red:0xf25346,
  white:0xd8d0d1,
  brown:0x59332e,
  pink:0xF5986E,
  brownDark:0x23190f,
  blue:0x68c3c0,
};

var options  = {
                

                
                
    blasterSpeed: .03,//5;
    enemySpeed: .01,//5;

   // segments         : 324,

   // wireframe_color     : '#00e6ff',//'#e25cfe',

    helpers        : true,

  //  floor_visible    : true

};

// GAME VARIABLES
var game;
var deltaTime = 0;
var newTime = new Date().getTime();
var oldTime = new Date().getTime();
var enemiesPool = [];
var particlesPool = [];
var particlesInUse = [];

var collidableMeshList = [];

// shader for checkerboard

var uniforms = {
      "color1" : {
        type : "c",
        value : new THREE.Color(0x76c876)
      },
      "color2" : {
        type : "c",
        value : new THREE.Color(0xa7f9a7)
      },
      "scale" : {
        type : "f",
        value : 80,
        min : 1, // only used for dat.gui, not needed for production
        max : 100 // only used for dat.gui, not needed for production
      },
    }
var vertexShader = document.getElementById('vertexShader').text;
var fragmentShader = document.getElementById('fragmentShader').text;
var checkerTexture = new THREE.ShaderMaterial(
        {
          uniforms : uniforms,
          vertexShader : vertexShader,
          fragmentShader : fragmentShader,
          side: THREE.DoubleSide
         // doubleSide: true,
        });


function resetGame(){
  game = {speed:0,
          initSpeed:.00035,
          baseSpeed:.00035,
          targetBaseSpeed:.00035,
          incrementSpeedByTime:.0000025,
          incrementSpeedByLevel:.000005,
          distanceForSpeedUpdate:100,
          speedLastUpdate:0,

          distance:0,
          ratioSpeedDistance:50,
          energy:100,
          ratioSpeedEnergy:3,

          level:1,
          levelLastUpdate:0,
          distanceForLevelUpdate:1000,

          enemyDistanceTolerance:10,
          enemyValue:10,
          enemiesSpeed:.6,
          enemyLastSpawn:0,
          distanceForenemiesSpawn:50,

          status : "playing",
         };
  //fieldLevel.innerHTML = Math.floor(game.level);
}

function loadSound(){
  sound = new Howl({
    src: ['../_audio/boing.mp3'],
    volume: 0.5
  });
  //sound.play();

}

function playSound(){
  sound.play();
}

function loadGetReady(){

  getReady = new Howl({
    src: ['audio/ready.mp3']
  });
 // getReady.play();

}

function playGetReady(){
  getReady.play();
}

function loadExplode(){

  explode = new Howl({
    src: ['audio/explode.mp3']
  });
  //explode.play();

}

function playExplode(){
  explode.play();
}

function muteAll(){
  howler.mute();
}


function init(){



    // Setup three.js WebGL renderer. Note: Antialiasing is a big performance hit.
    // Only enable it if you actually need to.
    renderer = new THREE.WebGLRenderer({antialias: false});
    renderer.setPixelRatio(window.devicePixelRatio);

    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFShadowMap;

    // Append the canvas element created by the renderer to document body element.
    document.body.appendChild(renderer.domElement);

    // Create a three.js scene.
    scene = new THREE.Scene();

    scene.background = new THREE.Color( 0xbd8ef8 );



    // Create a three.js camera.
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
    //var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 100);

   // camera.y = 5;

    let helper = new THREE.CameraHelper(camera);
    scene.add(helper);

    controls = new THREE.VRControls(camera);
    controls.userHeight = vantagePoint;
    controls.standing = true;
    //controls.standing = true;

/*
       // This helps move the camera
    dolly = new THREE.Group();
    dolly.position.set( 0, 0, 0 );
    scene.add( dolly );
    dolly.add( camera );
*/

    // Apply VR stereo rendering to renderer.
    effect = new THREE.VREffect(renderer);
    effect.setSize(window.innerWidth, window.innerHeight);

    // Create a VR manager helper to enter and exit VR mode.
    var params = {
      hideButton: false, // Default: false.
      isUndistorted: false // Default: false.
    };
    manager = new WebVRManager(renderer, effect, params);

    

    loader = new THREE.TextureLoader();
    //setPlayerTexture calls setupStage which triggers animate
    loader.load('img/player_small_128.png', setPlayerTexture);

    var loader2 = new THREE.TextureLoader();
    loader2.load('img/blaster.png', function(texture){
        blasterMaterial = new THREE.SpriteMaterial( { map: texture, color: 0xffffff } );
       // createBlaster();

       // needs a delay??
       if (forceVR && manager.isVRCompatible){
          manager.enterVRMode_();
          console.log(manager)
       }

    });

    var loader3 = new THREE.TextureLoader();
    loader3.load('img/enemy.png', function(texture){
        enemyMaterial = new THREE.SpriteMaterial( { map: texture, color: 0xffffff } );
       // createEnemy();
        spawnEnemies();

    });


    var loaderShadow = new THREE.TextureLoader();
    loaderShadow.load('img/shadow.png', function(texture){
      //  shadowMaterial = new THREE.SpriteMaterial( { map: texture, color: 0xffffff } );
         shadowMaterial = new THREE.MeshBasicMaterial( { map: texture, color: '0xff0000', side: THREE.DoubleSide, transparent: true} );
        createShadow();
        

    });

    //createLights();
    shadowLights();
   // setupGround();

    setupGridHelper();
    addWorldBox();
   // addGround();

    

    window.addEventListener('resize', onResize, true);
    window.addEventListener('vrdisplaypresentchange', onResize, true);
    document.addEventListener( 'mousemove', onDocumentMouseMove, false );
    document.addEventListener( 'click', createBlaster, true );
    document.addEventListener( 'touchstart', createBlaster, true );

    


}





/*
// Add a repeating grid as a skybox.
var boxSize = 5;
var loader = new THREE.TextureLoader();
loader.load('img/box.png', onTextureLoaded);

function onTextureLoaded(texture) {
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(boxSize, boxSize);

  var geometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
  var material = new THREE.MeshBasicMaterial({
    map: texture,
    color: 0x01BE00,
    side: THREE.BackSide
  });
*/




/*
  // Align the skybox to the floor (which is at y=0).
  skybox = new THREE.Mesh(geometry, material);
  skybox.position.y = boxSize/2;
  scene.add(skybox);
*/

  // Floor
  //var floor = new THREE.Mesh(cube, floorMat );
  //scene.add( floor );

 // createSea();


  // For high end VR devices like Vive and Oculus, take into account the stage
  // parameters provided.
 // setupStage();
//}


// Create 3D objects.
/*
var geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
//var material = new THREE.MeshNormalMaterial();
var cube = new THREE.Mesh(geometry, material);

// Position cube mesh to be right in front of you.
cube.position.set(0, controls.userHeight, -1);

// Add cube mesh to your three.js scene
scene.add(cube);
*/


function addWorldBox(){
  var r = 1;
  worldBox = new THREE.BoxHelper( new THREE.Mesh( new THREE.BoxGeometry( r, r, r)));
  worldBox.material.color.setHex( 0x080808);
  //worldBox.material.blending = THREE.AdditiveBlending;
  //worldBox.position.set(0, controls.userHeight, 0);
 // worldBox.position.z = -1;
 // worldBox.scale.set( .2, .2, .2);

  scene.add(worldBox)
}


function createShadow(){
  console.log('createShadow')
  //var shadowMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff, side: THREE.DoubleSide } );
  var shadowMaterial = new THREE.MeshPhongMaterial( { color: 0x43e206, specular: 0x009900, opacity: 0.5, transparent: true,shininess: 10, shading: THREE.FlatShading } )
  var geometry = new THREE.PlaneGeometry(2,1,30,30);

  var shadow = new THREE.Mesh( geometry,shadowMaterial );
  //shadow.position.z = playerDepth;
  //shadow.position.y=1;
  player.add(shadow);
    //plane.position.y = -2;
  shadow.rotation.x = -Math.PI/2;
  shadow.position.y = - controls.userHeight;
}

function setPlayerTexture(playerTexture){
  console.log('createPlayer')
  //var playerTexture = THREE.ImageUtils.loadTexture( 'img/Space_Harrier_player_sprite.png' );
 // var playerMaterial = new THREE.SpriteMaterial( { map: playerTexture, color: 0xffffff } );
  var playerMaterial = new THREE.MeshBasicMaterial( { map: playerTexture, color: 0xffffff, side: THREE.DoubleSide } );
  playerMaterial.transparent = true;
  var geometry = new THREE.PlaneGeometry(1,1,30,30);
  player = new THREE.Mesh( geometry, playerMaterial );
  //player.rotation.x = Math.PI/10;
  player.castShadow = true;


 // player = new THREE.Sprite( playerMaterial );


  //player.position.set(0, controls.userHeight, -1);
  player.position.z = playerDepth;

//  player.scale.set( .5, .5, 1.0 ); // imageWidth, imageHeight

  pivot = new THREE.Object3D();
  pivot.position.set(0, controls.userHeight, 0);
  scene.add(pivot);
  pivot.add(player);



 // var shadow = new THREE.Sprite( shadowMaterial );

 

/*
  var r = 1;
  helper = new THREE.BoxHelper( new THREE.Mesh( new THREE.BoxGeometry( r, r, r)));
  helper.material.color.setHex( 0x080808);
  helper.material.blending = THREE.AdditiveBlending;
  //helper.position.set(0, controls.userHeight, 0);
  helper.position.z = -1;
  helper.scale.set( .2, .2, .2);
*/

  var material = new THREE.MeshLambertMaterial( { color: 0x42f445, opacity: 0.2, transparent: true, side: THREE.DoubleSide, wireframe: false } );

 // var material = new THREE.MeshLambertMaterial( { color: 0x42f445, wireframe: false } );

  var geometry = new THREE.BoxGeometry(1,1,1);
  var helper = new THREE.Mesh(geometry, material);
  helper.position.z = playerDepth;

 //  helper.scale.set( .2, .2, .2);
   helper.castShadow = true;


  pivot.add(helper);

  if (debug ==false) helper.visible = false;

  
  // position the object on the pivot, so that it appears 5 meters 
  // in front of the user.

  //controlPlayer(0,0);


  //scene.add( player );

  setupStage();

}


function animate(timestamp) {

  var delta = clock.getDelta();
 // var delta = Math.min(timestamp - lastRender, 500);
 // lastRender = timestamp;
  //uTime = timestamp;

  // Apply rotation to cube mesh
 // cube.rotation.y += delta * 0.0006;
 playerVector.setFromMatrixPosition( player.matrixWorld );

 for(var i=0; i<blasterArr.length; i++) {

    //console.log(blasterArr[i].raycaster)
    blaster.raycaster.set(blaster.from, blaster.to);
    var blasterCollision = blasterArr[i].raycaster.intersectObjects( collidableMeshList );

   // console.log(blasterCollision)
    //if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) 
    if ( blasterCollision.length > 0) {
        tally.innerHTML = "bullet hit"
        console.log('-//------')
        console.log(" BLASTED " + blasterCollision[0].object.name);
        console.log(" EXploded at "+blasterCollision[0].object.position.z);
        console.log(blasterCollision[0].distance)
        blasterCollision[0].object.material.color = new THREE.Color(0x0066CC);
       // blasterArr[i].active=false;
       // scene.remove(blasterCollision[0].object);
        console.log('------//-')
       // console.log(blasterCollision[0].object)
       // scene.remove(blasterCollision[0]);
       // collidableMeshList.splice(collidableMeshList.indexOf(blasterCollision[0].object), 1);
        collidableMeshList.splice(collidableMeshList.indexOf(blasterCollision[0].object), 1);
      //  console.log(collidableMeshList);
        scene.remove(blasterArr[i]);
        blasterArr.splice(i, 1);
        playExplode();
    }else{
     
      blasterArr[i].position.x += blasterArr[i].blasterDir.x * options.blasterSpeed;
      //blasterArr[i].position.y += blasterArr[i].blasterDir.y * blasterSpeed;
     // blasterArr[i].position.y += (blasterArr[i].blasterDir.y - blasterArr[i].position.y) * blasterSpeed;
      blasterArr[i].position.z += blasterArr[i].blasterDir.z * options.blasterSpeed;

     // if (i==0) console.log(blasterArr[i].position.z);
   /*   if (timestamp - blasterArr[i].time > 1000) {
        scene.remove(blasterArr[i]);
        blasterArr.splice(i, 1);

      }
      */
      
    }
    



 }

  for(var i=0; i<arrowArr.length; i++) {
      if (timestamp - arrowArr[i].time > 3000) {
          scene.remove(arrowArr[i]);
          arrowArr.splice(i, 1);

        }
  }

 if (enemiesPool.length > 0 ) updateEnemies();

  controls.update(delta);
  // Render the scene through the manager.
 // manager.render(scene, camera, timestamp);
 // effect.render(scene, camera);

  // Update the scene through the manager.
  manager.render(scene, camera);
  // effect.render(scene, camera);

  // Call the render function again
//  requestAnimationFrame( render );

  
  //player.position.set(0, controls.userHeight, -1);
 // pivot.rotation.y = camera.rotation.y;
  //console.log(camera.rotation.y)

 // pivot.rotation.copy( camera.rotation );
//  pivot.updateMatrix();


  //pivot.applyQuaternion(camera.quaternion);
/*
  var yaxis = new THREE.Vector3(0, 1, 0);
var zaxis = new THREE.Vector3(0, 0, 1);
var direction = zaxis.clone();
// Apply the camera's quaternion onto the unit vector of one of the axes
// of our desired rotation plane (the z axis of the xz plane, in this case).
direction.applyQuaternion(camera.quaternion);
// Project the direction vector onto the y axis to get the y component
// of the direction.
var ycomponent = yaxis.clone().multiplyScalar(direction.dot(yaxis));
// Subtract the y component from the direction vector so that we are
// left with the x and z components.
direction.sub(ycomponent);
// Normalize the direction into a unit vector again.
direction.normalize();
// Set the pivot's quaternion to the rotation required to get from the z axis
// to the xz component of the camera's direction.
pivot.quaternion.setFromUnitVectors(zaxis, direction);
*/
/*
  var vec = new THREE.Vector3( 0, 0, -1 );
  vec.applyQuaternion( camera.quaternion );

  pivot.rotation.copy( vec );


  var vector = camera.getWorldDirection();
  var theta = Math.atan2(vector.x,vector.z);
*/
/*
  var startRotation = new THREE.Euler().copy( camera.rotation );
  pivot.rotation.copy(startRotation)
  */
 // pivot.rotation.z = camera.rotation.z;


 // helper.rotation.y = camera.rotation.y;
 // helper.rotation.x = camera.rotation.x;
/*
  for(var i=0; i<floor.length; i++) {
      
      ground = floor[i]; 
        
      // move it forward by a 10th of its array position each time 
      ground.position.z +=  0.5;
        
      // once the star is too close, reset its z position
      if(ground.position.z>400) ground.position.z-=1600;   
  }

*/
 // console.log(camera.rotation)

/*
 var camDir = camera.getWorldDirection();

 for(var i=0; i<blasterArr.length; i++) {
    blasterArr[i].position.x += camDir.x * blasterSpeed;
    blasterArr[i].position.y += camDir.y * blasterSpeed;
    blasterArr[i].position.z += camDir.z * blasterSpeed;
    if (timestamp - blasterArr[i].time > 1000) {
      scene.remove(blasterArr[i]);
      blasterArr.splice(i, 1);
    }

 }
*/
 player.position.x = xA;
 player.position.y = yA;  



//console.log(yA)
 
 //info.textContent = "x:"+vrDisplay.orientation_.x.toFixed(2)+",y:"+vrDisplay.orientation_.y.toFixed(2)+",z:"+vrDisplay.orientation_.z.toFixed(2);

 

// console.log(vrDisplay.orientation_)

  vrDisplay.requestAnimationFrame(animate);
}

function onResize(e) {
  effect.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
}



// Get the HMD, and if we're dealing with something that specifies
// stageParameters, rearrange the scene.
function setupStage() {
  navigator.getVRDisplays().then(function(displays) {
    if (displays.length > 0) {
      vrDisplay = displays[0];
      if (vrDisplay.stageParameters) {
        setStageDimensions(vrDisplay.stageParameters);
        // if (forceVR && manager.isVRcompatible){
          //  manager.enterVRMode_();
           // console.log(manager)
        // }
      }
      vrDisplay.requestAnimationFrame(animate);
    }
 //   console.log(vrDisplay.orientation_);
     // window.addEventListener("devicemotion", function(event) 
      
    // is mobile? has accelerometer?
    //if(window.DeviceMotionEvent) { 
   //   var util = new Util;
  //    console.log(util.isMobile)
  // bad mobile detection
    if(window.innerWidth < 769) { 
      console.log('isDeviceMotion')

      window.addEventListener("devicemotion", function(event) 
      {
        
          //accX = Math.round(event.accelerationIncludingGravity.x*10) / 10;  
          //accY = Math.round(event.accelerationIncludingGravity.y*10) / 10;  
         // accY = event.accelerationIncludingGravity.y;
        // if (manager.mode == 1){

          accZ = event.accelerationIncludingGravity.z; 
          accY = event.accelerationIncludingGravity.y;
          accZsmooth = factor * accZsmooth + (1 - factor) * accZ;
          accYsmooth = factor * accYsmooth + (1 - factor) * accY;

          if (debug) info.innerHTML = 'accZ:'+accZ.toFixed(2)+', accZsm:'+accZsmooth.toFixed(2)+', accY:'+accYsmooth.toFixed(2);
          
          movement = 2;
          
          if (manager.mode == 1){
            xA = -accYsmooth * movement;
            yA = - accZsmooth * .4;// *movement;
          }else{
            yA = accZsmooth * .5;// *movement;
            xA = -accYsmooth * .5
          }
          
       /*   }else{
            xA = 0;
            yA = 0;
            player.position.set(0,0,-2)

          }
          */
          
          //run();
      }, true);
      /*
      window.addEventListener("deviceorientation", function(event) 
      {
          
          var xValue = Math.round(event.gamma);
          var yValue = Math.round(event.beta);
          var Rotation = Math.round(event.alpha);

          info.innerHTML = 'x:'+xValue+', y:'+yValue+' ,rot:'+Rotation;
        //  info.innerHTML = "x:"+vrDisplay.orientation_.x.toFixed(2)+",y:"+vrDisplay.orientation_.y.toFixed(2)+",z:"+vrDisplay.orientation_.z.toFixed(2);
          var halfwidth= window.innerWidth/2;
          var newYPos = yValue/5;
          info.innerHTML += ' n:'+newYPos.toFixed(2);

          //for landscape, reverse x and y
          controlPlayer(newYPos, 0);



          
        }, true);
        */



    }    
  });
  
}


function onDocumentMouseMove( event ) {

  event.preventDefault();

  mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
  mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

  if (debug) info.innerHTML = 'x:'+mouse.x.toFixed(2)+', y:'+mouse.y.toFixed(2);

  //controlPlayer(-mouse.x.toFixed(2)*10)
  controlPlayer(mouse.x, mouse.y/2)

}

function controlPlayer(xAcc, yAcc){

   // accX = (xAcc*10) / 10;  
   // accY = (yAcc*10) / 10;  

    accX = xAcc*2;
    accY = yAcc;
    
    movement = 10;
    
    xA = -(accX);
    yA = -(accY / 10) * movement;



   //   player.position.x = xpos;
/*
     TweenMax.to(player.position ,50,{
            x:xpos,
           // y:0,
            ease:"Power3.easeOut",
            onUpdate:function(){
                      //  console.log('tweened');
            }
      });
      */
}
/*
function addLights() {
    var dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(100, 100, 50);
    scene.add(dirLight);
}
*/



function createBlaster(event){

  var geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
var material = new THREE.MeshNormalMaterial();
//blaster = new THREE.Mesh(geometry, material);



  if (manager.mode == 3) event.preventDefault();
 // manager.enterVRMode_();
 // console.log(manager.mode)
 // console.log('createBlaster')
  /*
  if (manager.mode == 3){
    camera.fov = 25;

    camera.updateProjectionMatrix();
  }else{
    camera.fov = 75;
    camera.updateProjectionMatrix();

  }
  */
 // console.log(camera.getWorldDirection());

  blaster = new THREE.Sprite( blasterMaterial );
  //blaster.position.z = -10;
  //blaster.position.x = 0;//player.position.x;
  //blaster.position.y = 0;//player.position.y;
  blaster.scale.set( .2, .2, 1.0 );
  blaster.time = lastRender;
  
  //var distVector = playerVector.multiplyScalar(2);


  //projector.unprojectVector( vector, camera );
  //blaster.raycaster = new THREE.Raycaster(new THREE.Vector3(playerVector.x, playerVector.y, playerVector.z), new THREE.Vector3(distVector.x, playerVector.y, distVector.z));

  //var camDir = camera.getWorldDirection();
//  var scaleCam = camDir.multiplyScalar(1.1);

 // blaster.position.set(player.position.x, controls.userHeight + player.position.y, player.position.z - .1);


//  var vector = new THREE.Vector3();
//  vector.setFromMatrixPosition( player.matrixWorld );

  blaster.position.set(playerVector.x , playerVector.y, playerVector.z );
  scene.add(blaster);

  blasterArr.push(blaster);

  var camVector = new THREE.Vector3();

  var camDir1 = camera.getWorldDirection(camVector).multiplyScalar(20);
  var camDir = new THREE.Vector3(camDir1.x, controls.userHeight, camDir1.z);//.multiplyScalar(20);
 // camDir.setY(controls.userHeight)
 // console.log(camDir)
 //var camDir = new THREE.Vector3(0, .1, -4)
// var horizon = new THREE.Vector3(camDir.x, .02, camDir.z);
 //var scaleCam = horizon.multiplyScalar(2);

 blaster.blasterDir = camDir;//scaleCam;
 blaster.lookAt(camDir)

 blaster.raycaster = new THREE.Raycaster(new THREE.Vector3(playerVector.x, playerVector.y, playerVector.z),  blaster.blasterDir);

  blaster.from = blaster.position;//new THREE.Vector3( 2, 2, 2 );
  blaster.to = blaster.blasterDir;//new THREE.Vector3( 0, controls.userHeight, -40);
  var direction = blaster.to.clone().sub(blaster.from);
  var length = direction.length();

  //blaster.raycaster = new THREE.Raycaster(new THREE.Vector3(playerVector.x, playerVector.y, playerVector.z),  blaster.blasterDir);
 
  var arrowHelper = new THREE.ArrowHelper(direction.normalize(), blaster.from, length, 0xff0000 );
  arrowHelper.time = lastRender;
  scene.add( arrowHelper );

  arrowArr.push( arrowHelper);




  playSound();

}



function setupGridHelper(){
/*
   var geometry = new THREE.PlaneGeometry(5,5,30,30);

   var mesh = THREE.SceneUtils.createMultiMaterialObject( geometry, [

      new THREE.MeshLambertMaterial( { color: 0xff0000, opacity: 0.5, transparent: true} ),
      new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true} )

  ]);
   mesh.rotation.x = Math.PI/-2;
  // mesh.position.z=-10;
  scene.add(mesh);
  */


  var planeGeometry = new THREE.PlaneGeometry( 20, 20, 32, 32 );
    var planeMaterial = new THREE.MeshPhongMaterial( { color: 0x00dddd, specular: 0x009900, opacity: 0.5, transparent: true,shininess: 10, shading: THREE.FlatShading } )
    var plane = new THREE.Mesh( planeGeometry, planeMaterial );
    plane.receiveShadow = true;
    plane.opacity = .7;
    scene.add( plane );
    //plane.position.y = -2;
    plane.rotation.x = -Math.PI/2;

}

function createEnemy(ang){

  enemy = new Enemy();
  console.log('new enemy')

  enemy.mesh.scale.set( .65, .65, 1.0 ); // imageWidth, imageHeight

 // enemy.mesh.position.z = -1;//-Math.sin(enemy.angle)*enemy.distance;
  enemy.mesh.position.y = controls.userHeight;// + Math.random()*controls.userHeight ;
 // enemy.mesh.position.x = (Math.random()*10) - 5;// Math.cos(enemy.angle)*enemy.distance;
  //player.position.set(0, controls.userHeight, -1);
  //var ang = Math.random() * 10;
  enemy.angle = Math.random()*360;
  enemy.mesh.lookAt(camera);
  enemy.mesh.name = "enemy"+ang;
 // enemy.angle = - (ang*0.1);
 // enemy.distance = game.seaRadius + game.planeDefaultHeight + (-1 + Math.random() * 2) * (game.planeAmpHeight-20);
  enemy.mesh.position.z = Math.sin(enemy.angle)*10;//-5 + Math.sin(enemy.angle)*10;
  enemy.mesh.position.x = Math.random()*4 - 2;
 // enemy.mesh.position.x = Math.cos(enemy.angle)*10;
/*
  var r = 1;
  var geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
  var material = new THREE.MeshBasicMaterial({color:0xff0000, transparent:true, opacity:0.4, side: THREE.DoubleSide})
  //var material = new THREE.MeshNormalMaterial();
  var nhelper = new THREE.Mesh(geometry, material);
 
  
  enemy.mesh.add(nhelper);
  */
/*
  var nhelper = new THREE.BoxHelper( new THREE.Mesh( new THREE.BoxGeometry( r, r, r)));
  nhelper.material.color.setHex( 0x080808);
  nhelper.material.blending = THREE.AdditiveBlending;
  //helper.position.set(0, controls.userHeight, 0);
  
  enemy.mesh.add(nhelper);
  */

  scene.add(enemy.mesh);
  enemiesPool.push(enemy);
  collidableMeshList.push(enemy.mesh);
  //collidableMeshList.push(nhelper);
 
}

function spawnEnemies(){
  var nenemies = 10;//game.level;

  for (var i=0; i<nenemies; i++){
    createEnemy(i);
  }
}



var Enemy = function(){
  /*
  var geom = new THREE.TetrahedronGeometry(8,2);
  var mat = new THREE.MeshPhongMaterial({
    color:Colors.red,
    shininess:0,
    specular:0xffffff,
    shading:THREE.FlatShading
  });
  */

  var geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
  var material = new THREE.MeshBasicMaterial({color:0xff0000, transparent:true, opacity:0.4, side: THREE.DoubleSide})
  this.mesh = new THREE.Mesh(geometry, material);
  this.active = true;

  //this.mesh = new THREE.Mesh( geometry, material );
  //    scene.add( cube );
  
  //this.mesh = new THREE.Sprite( enemyMaterial );
  this.mesh.castShadow = true;
  this.angle = 0;
  this.dist = 0;
}
/*
var enemiesHolder = function (){
  this.mesh = new THREE.Object3D();
  this.enemiesInUse = [];
}

enemiesHolder.prototype.spawnEnemies = function(){
  var nenemies = game.level;

  for (var i=0; i<nenemies; i++){
    var enemy;
    if (enemiesPool.length) {
      enemy = enemiesPool.pop();
    }else{
      enemy = new Enemy();
      console.log('new enemy')
    }

    enemy.angle = - (i*0.1);
   // enemy.distance = game.seaRadius + game.planeDefaultHeight + (-1 + Math.random() * 2) * (game.planeAmpHeight-20);
   // enemy.mesh.position.y = -game.seaRadius + Math.sin(enemy.angle)*enemy.distance;
    enemy.mesh.position.z = -5;//-Math.sin(enemy.angle)*enemy.distance;
    enemy.mesh.position.x = 0;// Math.cos(enemy.angle)*enemy.distance;

    this.mesh.add(enemy.mesh);
    this.enemiesInUse.push(enemy);
  }
}
/*
enemiesHolder.prototype.rotateenemies = function(){
  for (var i=0; i<this.enemiesInUse.length; i++){
    var enemy = this.enemiesInUse[i];
    enemy.angle += game.speed*deltaTime*game.enemiesSpeed;

    if (enemy.angle > Math.PI*2) enemy.angle -= Math.PI*2;

    enemy.mesh.position.y = -game.seaRadius + Math.sin(enemy.angle)*enemy.distance;
    enemy.mesh.position.x = Math.cos(enemy.angle)*enemy.distance;
    enemy.mesh.rotation.z += Math.random()*.1;
    enemy.mesh.rotation.y += Math.random()*.1;

    //var globalenemyPosition =  enemy.mesh.localToWorld(new THREE.Vector3());
    var diffPos = airplane.mesh.position.clone().sub(enemy.mesh.position.clone());
    var d = diffPos.length();
    if (d<game.enemyDistanceTolerance){
      particlesHolder.spawnParticles(enemy.mesh.position.clone(), 15, Colors.red, 3);

      enemiesPool.unshift(this.enemiesInUse.splice(i,1)[0]);
      this.mesh.remove(enemy.mesh);
      game.planeCollisionSpeedX = 100 * diffPos.x / d;
      game.planeCollisionSpeedY = 100 * diffPos.y / d;
      ambientLight.intensity = 2;

      removeEnergy();
      i--;
    }else if (enemy.angle > Math.PI){
      enemiesPool.unshift(this.enemiesInUse.splice(i,1)[0]);
      this.mesh.remove(enemy.mesh);
      i--;
    }
  }
}
*/



function updateEnemies(vec) { 
 
  // iterate through every particle
  for(var i=0; i<enemiesPool.length; i++) {
 
    var nEnemy = enemiesPool[i]; 
   // console.log(nEnemy)
 
    // and move it forward dependent on the mouseY position. 
    nEnemy.mesh.position.z +=  options.enemySpeed;//.1;
 
    // if the particle is too close move it to the back
    if(nEnemy.mesh.position.z>20){
      if (nEnemy.active==true) {
        nEnemy.mesh.position.z-=40; 
      }else{
        scene.remove(nEnemy)
      }
    }


    

 /// check if enemy is in view of camera ...
/*
    camera.updateMatrix();
    camera.updateMatrixWorld();
    var frustum = new THREE.Frustum();
    frustum.setFromMatrix(new THREE.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse));  

    // Your 3d point to check
    var pos = nEnemy.mesh.position;
    if (frustum.containsPoint(pos)) {
        // Do something with the position...
       // console.log(nEnemy.mesh)
       if (nEnemy.mesh.position.z >-1 )
          console.log('hit')
    }

    // console.log(camera.rotation)
*/
/*
    nEnemy.mesh.position.x -= vec.x * blasterSpeed;
    nEnemy.mesh.position.y -= vec.y * blasterSpeed;
    nEnemy.mesh.position.z -= vec.z * blasterSpeed;
    */
  }
 
 
 
}

function createObstacle(){

}



function setupGround(){


    

    loader.load('img/checkerboard.jpg', function(texture){
        var floorTexture = texture;
        floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
        floorTexture.repeat.set( 10, 10 );
        var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
        addGround(floorMaterial);
    });


    


   
}


function addGround(floorMaterial){

    //create the ground material using MeshLambert Material
 //   var groundMat = new THREE.MeshLambertMaterial( {color: 0xffffff, side: THREE.DoubleSide}  );
    //create the plane geometry
   // var geometry = new THREE.PlaneGeometry(400,800,300,300);
    var geometry = new THREE.PlaneGeometry(5,5,300,300);
   // var geometry = new THREE.BoxGeometry(400, 10, 800);

          //create the ground form the geometry and material


    // for ( var z= -1600; z < 1600; z+=800 ) {
    
          
        /*  //make the terrain bumpy
          for (var i = 0, l = geometry.vertices.length; i < l; i++) {
            var vertex = geometry.vertices[i];
            var value = pn.noise(vertex.x / 10, vertex.y /10, 0);
            vertex.z = value *6;
          }
          //ensure light is computed correctly
          geometry.computeFaceNormals();
          geometry.computeVertexNormals();
        */
    

       //   var ground = new THREE.Mesh(geometry,groundMat); 

           var ground = new THREE.Mesh(geometry,floorMaterial); 
         // var ground = new THREE.Mesh(geometry,checkerTexture); 
          //rotate 90 degrees around the xaxis so we can see the terrain 
          ground.rotation.x = -Math.PI/-2;
          // Then set the z position to where it is in the loop (distance of camera)
        //  ground.position.y = -1;

          ground.receiveShadow = true;
          //add the ground to the scene
          scene.add(ground); 
          //finally push it to the stars array 
          floor.push(ground); 
   //   }


      /// alt versions
      /*
       // var geometry = new THREE.BoxGeometry(200, 200, 200);
        var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
       // material = new THREE.MeshBasicMaterial();
        //var floor = new THREE.Mesh(floorGeometry, material);
        var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
        floor.position.y = -0.5;
       floor.rotation.x = Math.PI / 2;
        scene.add(floor);
      */
    /*
    var floorTexture = new THREE.ImageUtils.loadTexture( 'img/checkerboard.jpg' );
    floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
    floorTexture.repeat.set( 10, 10 );
    var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
    var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
    var floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.position.y = -0.5;
    floor.rotation.x = Math.PI / 2;
    scene.add(floor);
    */
  }
function shadowLights(){
  //shadows
      var light = new THREE.PointLight( 0xffffff, 1, 100 );
      light.position.set( 0, 12, 0 );
      light.castShadow = true;
      light.shadow.mapSize.width = 1024;
      light.shadow.mapSize.height = 1024;

      light.shadow.camera.left = 500
      scene.add( light );

      var ambientLight = new THREE.AmbientLight( 0x151515 ); // soft white light
      scene.add( ambientLight );
}

function createLights() {
  // A hemisphere light is a gradient colored light; 
  // the first parameter is the sky color, the second parameter is the ground color, 
  // the third parameter is the intensity of the light
  hemisphereLight = new THREE.HemisphereLight(0xaaaaaa,0x000000, .9)
  
  // A directional light shines from a specific direction. 
  // It acts like the sun, that means that all the rays produced are parallel. 
  shadowLight = new THREE.DirectionalLight(0xffffff, .9);

  // Set the direction of the light  
  shadowLight.position.set(150, 350, 350);
  
  // Allow shadow casting 
  shadowLight.castShadow = true;

  // define the visible area of the projected shadow
  shadowLight.shadow.camera.left = -400;
  shadowLight.shadow.camera.right = 400;
  shadowLight.shadow.camera.top = 400;
  shadowLight.shadow.camera.bottom = -400;
  shadowLight.shadow.camera.near = 1;
  shadowLight.shadow.camera.far = 1000;

  // define the resolution of the shadow; the higher the better, 
  // but also the more expensive and less performant
  shadowLight.shadow.mapSize.width = 2048;
  shadowLight.shadow.mapSize.height = 2048;
  
  // to activate the lights, just add them to the scene
  scene.add(hemisphereLight);  
  scene.add(shadowLight);
}

function setDebug(bool){
    debug = bool;
    if (bool ==false) info.innerHTML = null;
}


function setStageDimensions(stage) {
  // Make the skybox fit the stage.
  /*
  var material = skybox.material;
 // scene.remove(skybox);

  // Size the skybox according to the size of the actual stage.
  var geometry = new THREE.BoxGeometry(stage.sizeX, boxSize, stage.sizeZ);
  skybox = new THREE.Mesh(geometry, material);

  // Place it on the floor.
  skybox.position.y = boxSize/2;
 // scene.add(skybox);
*/
  // Place the cube in the middle of the scene, at user height.
  player.position.set(0, controls.userHeight, -1);
}

/*
window.ondevicemotion = function(event) {
        
    accX = Math.round(event.accelerationIncludingGravity.x*10) / 10;  
    accY = Math.round(event.accelerationIncludingGravity.y*10) / 10;  
    
    movement = 1;
    
    xA = -(accX / 10) * movement;
    yA = -(accY / 10) * movement;
    
    
    //run();
    
}  
*/

/*
var shootDirection = new THREE.Vector3();
var shootVelo = 15;
var projector = new THREE.Projector();
function getShootDir(targetVec){
    var vector = targetVec;
    targetVec.set(0,0,1);
    projector.unprojectVector(vector, camera);
    var ray = new THREE.Ray(sphereBody.position, vector.sub(sphereBody.position).normalize() );
    targetVec.copy(ray.direction);
}

            window.addEventListener("click",function(e){
                if(controls.enabled==true){
                    var x = sphereBody.position.x;
                    var y = sphereBody.position.y;
                    var z = sphereBody.position.z;
                    var ballBody = new CANNON.Body({ mass: 1 });
                    ballBody.addShape(ballShape);
                    var ballMesh = new THREE.Mesh( ballGeometry, material );
                    world.add(ballBody);
                    scene.add(ballMesh);
                    ballMesh.castShadow = true;
                    ballMesh.receiveShadow = true;
                    balls.push(ballBody);
                    ballMeshes.push(ballMesh);
                    getShootDir(shootDirection);
                    ballBody.velocity.set(  shootDirection.x * shootVelo,
                                            shootDirection.y * shootVelo,
                                            shootDirection.z * shootVelo);

                    // Move the ball outside the player sphere
                    x += shootDirection.x * (sphereShape.radius*1.02 + ballShape.radius);
                    y += shootDirection.y * (sphereShape.radius*1.02 + ballShape.radius);
                    z += shootDirection.z * (sphereShape.radius*1.02 + ballShape.radius);
                    ballBody.position.set(x,y,z);
                    ballMesh.position.set(x,y,z);
                }
            });

*/

function initGUI() {

                    //this.gui = new dat.GUI();

                    gui.values = {};

                    gui.values.blasterSpeed            = gui.add(options,'blasterSpeed',0.0,0.1).step(0.001);

                    gui.values.enemySpeed            = gui.add(options,'enemySpeed',0.0,0.1).step(0.001);

                   // gui.values.segments         = gui.add(options,'segments',20,800).step(1);

                   // gui.values.wireframe_color     = gui.addColor(options,'wireframe_color');
                    
                    gui.values.helpers = gui.add(options, 'helpers');

                  //  gui.values.floor_visible = gui.add(options, 'floor_visible');




                    gui.values.helpers.onChange(value => {

                        //plane_material.wireframe = value;
                        console.log("helpers="+ value);

                    }
                    );

                    gui.values.blasterSpeed.onChange(value => {

                        options.blasterSpeed.value = value;

                    }
                    );

                    gui.values.enemySpeed.onChange(value => {

                        options.enemySpeed.value = value;

                    }
                    );

                   /*
                    gui.values.wireframe_color.onChange(value => {
                        console.log('value');
                        uniforms.line_color.value = new THREE.Color(value);
                    }
                    );

                    gui.values.segments.onFinishChange(value => {

                        scene.remove(plane_mesh);

                        buildPlane(value);

                        scene.add(plane_mesh);
                    }
                    );
                    */
                }
 // loadGetReady();
 // loadSound();
 resetGame();
  loadGetReady();
  loadSound();
  loadExplode()
  initGUI();
  init();

</script>

</html>
