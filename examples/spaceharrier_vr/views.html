<!DOCTYPE html>

<html lang="en">
<head>
<title>Space Harrier VR</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<style>
body {
  width: 100%;
  height: 100%;
  background-color: #bd8ef8;
  color: #fff;
  margin: 0px;
  padding: 0;
  overflow: hidden;
}
#info{
  position: absolute;
  top: 10px;
  left: 10px;
  z-index: 101;
}
/*
* {cursor: none;}
*/
</style>
</head>

<body>
<div id='info'></div>

</body>

<script id="vertexShader" type="x-shader/x-vertex">
varying vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
}
  </script>
  
  <script id="fragmentShader" type="x-shader/x-fragment">
uniform vec3 color1;
uniform vec3 color2;
uniform float scale;
varying vec2 vUv;
void main() {
  vec2 center = -1.0 + 2.0 * vUv;
  vec2 uv = floor(center.xy * scale);
  if(mod(uv.x + uv.y, 2.0) > 0.5){
    gl_FragColor = vec4(color1, 1.0);
  }else{
    gl_FragColor = vec4(color2, 1.0);
  }
}
  </script>

<script>
/*
 * Debug parameters.
 */
WebVRConfig = {
  /**
   * webvr-polyfill configuration
   */

  // Forces availability of VR mode.
  //FORCE_ENABLE_VR: true, // Default: false.
  // Complementary filter coefficient. 0 for accelerometer, 1 for gyro.
  //K_FILTER: 0.98, // Default: 0.98.
  // How far into the future to predict during fast motion.
  //PREDICTION_TIME_S: 0.040, // Default: 0.040 (in seconds).
  // Flag to disable touch panner. In case you have your own touch controls
  //TOUCH_PANNER_DISABLED: true, // Default: false.
  // Enable yaw panning only, disabling roll and pitch. This can be useful for
  // panoramas with nothing interesting above or below.
  YAW_ONLY: true, // Default: false.
  // Enable the deprecated version of the API (navigator.getVRDevices).
  //ENABLE_DEPRECATED_API: true, // Default: false.
  // Scales the recommended buffer size reported by WebVR, which can improve
  // performance. Making this very small can lower the effective resolution of
  // your scene.
  BUFFER_SCALE: 1, // default: 1.0
  // Allow VRDisplay.submitFrame to change gl bindings, which is more
  // efficient if the application code will re-bind it's resources on the
  // next frame anyway.
  // Dirty bindings include: gl.FRAMEBUFFER_BINDING, gl.CURRENT_PROGRAM,
  // gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING,
  // and gl.TEXTURE_BINDING_2D for texture unit 0
  // Warning: enabling this might lead to rendering issues.
  //DIRTY_SUBMIT_FRAME_BINDINGS: true // default: false
};
</script>

<!--
  A polyfill for Promises. Needed for IE and Edge.
  -->
<script src="node_modules/es6-promise/dist/es6-promise.js"></script>

<!--
  three.js 3d library
  -->
<script src="node_modules/three/build/three.min.js"></script>

<!--
  VRControls.js acquires positional information from connected VR devices and applies the transformations to a three.js camera object.
   -->
<script src="node_modules/three/examples/js/controls/VRControls.js"></script>
<!--
<script src="node_modules/three/examples/js/controls/DeviceOrientationControls.js"></script>
-->
<!--
  VREffect.js handles stereo camera setup and rendering.
  -->
<script src="node_modules/three/examples/js/effects/VREffect.js"></script>

<!--
  A polyfill for WebVR using the Device{Motion,Orientation}Event API.
  -->
<script src="node_modules/webvr-polyfill/build/webvr-polyfill.js"></script>

<!--
  Helps enter and exit VR mode, provides best practices while in VR.
  -->
<script src="build/webvr-manager.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.19.0/TweenMax.min.js"></script>
<!--
<script src="build/threejs-texture-checkerboard.js"></script>
-->
<script src="node_modules/howler/dist/howler.min.js"></script>

<script>

var forceVR = false;//true;
var debug = false;//true;

var views;
var renderer, scene, camera, controls, effect, manager, loader;
var pivot, player, player_sprite;
var mouse = new THREE.Vector2();
var uTime;
var helper;
var blasterArr = [];
var arrowArr = [];
var blasterSpeed = .01;//5;
var info = document.getElementById('info');
var sound, getReady;

var hemisphereLight, shadowLight;
var floorMaterial, floorPlane;
var enemyMaterial, obstacleMaterial;
var floor = [];
var checkerTexture;
var xA = 0;
var yA = 0;
var accX = 0;
var accY= 0;
var accZ = 0;

// Request animation frame loop function
var lastRender = 0;

var vrDisplay;

var accZsmooth = 0;
var accYsmooth = 0;
var factor = .98;


var playerVector = new THREE.Vector3();
var camVector = new THREE.Vector3();


//var raycaster, INTERSECTED;
var raycaster = new THREE.Raycaster();


var Colors = {
  red:0xf25346,
  white:0xd8d0d1,
  brown:0x59332e,
  pink:0xF5986E,
  brownDark:0x23190f,
  blue:0x68c3c0,
};

// GAME VARIABLES
var game;
var deltaTime = 0;
var newTime = new Date().getTime();
var oldTime = new Date().getTime();
var enemiesPool = [];
var particlesPool = [];
var particlesInUse = [];

var collidableMeshList = [];

var views = [
        {
          left: 0,
          bottom: 0,
          width: 0.6,
          height: 1.0,
         // background: new THREE.Color().setRGB( 0.5, 0.5, 0.7 ),
          eye: [ 0, 1, 0 ],
         // up: [ 0, 1, 0 ],
          fov: 75,
          updateCamera: function ( camera, scene, mouseX, mouseY ) {
  
            //camera.lookAt( scene.position );
          }
          
        },
       
        {
          left: 0.6,
          bottom: 0,
          width: 0.4,
          height: 0.5,
          background: new THREE.Color().setRGB( 0.7, 0.5, 0.5 ),
          eye: [ 0, 50, -3 ],
          up: [ 0, 10, 0 ],
          fov: 75,
          updateCamera: function ( camera, scene, mouseX, mouseY ) {
    
            camera.lookAt( camera.position.clone().setY( 0 ) );
          }
         
        },
        {
          left: 0.6,
          bottom: 0.5,
          width: 0.4,
          height: 0.5,
          background: new THREE.Color().setRGB( 0.5, 0.7, 0.7 ),
          eye: [ 5, 2, -3 ],
          up: [ 0, 1, 0 ],
          fov: 75,
          updateCamera: function ( camera, scene, mouseX, mouseY ) {
   
            camera.lookAt( camera.position.clone().setX( 0 ) );
          }
          
        }
      
      ];

function resetGame(){
  game = {speed:0,
          initSpeed:.00035,
          baseSpeed:.00035,
          targetBaseSpeed:.00035,
          incrementSpeedByTime:.0000025,
          incrementSpeedByLevel:.000005,
          distanceForSpeedUpdate:100,
          speedLastUpdate:0,

          distance:0,
          ratioSpeedDistance:50,
          energy:100,
          ratioSpeedEnergy:3,

          level:1,
          levelLastUpdate:0,
          distanceForLevelUpdate:1000,

          enemyDistanceTolerance:10,
          enemyValue:10,
          enemiesSpeed:.6,
          enemyLastSpawn:0,
          distanceForenemiesSpawn:50,

          status : "playing",
         };
  //fieldLevel.innerHTML = Math.floor(game.level);
}

// shader for checkerboard

var uniforms = {
      "color1" : {
        type : "c",
        value : new THREE.Color(0x76c876)
      },
      "color2" : {
        type : "c",
        value : new THREE.Color(0xa7f9a7)
      },
      "scale" : {
        type : "f",
        value : 80,
        min : 1, // only used for dat.gui, not needed for production
        max : 100 // only used for dat.gui, not needed for production
      },
    }
var vertexShader = document.getElementById('vertexShader').text;
var fragmentShader = document.getElementById('fragmentShader').text;
var checkerTexture = new THREE.ShaderMaterial(
        {
          uniforms : uniforms,
          vertexShader : vertexShader,
          fragmentShader : fragmentShader,
          side: THREE.DoubleSide
         // doubleSide: true,
        });

function loadSound(){
  sound = new Howl({
    src: ['../_audio/boing.mp3']
  });
  sound.play();

}

function playSound(){
  sound.play();
}

function loadGetReady(){

  getReady = new Howl({
    src: ['audio/ready.mp3']
  });
  getReady.play();

}

function playGetReady(){
  getReady.play();
}

function muteAll(){
  howler.mute();
}


function init(){



    // Setup three.js WebGL renderer. Note: Antialiasing is a big performance hit.
    // Only enable it if you actually need to.
    renderer = new THREE.WebGLRenderer({antialias: false});
    renderer.setPixelRatio(window.devicePixelRatio);

    // Append the canvas element created by the renderer to document body element.
    document.body.appendChild(renderer.domElement);


    for (var ii =  0; ii < views.length; ++ii ) {
          var view = views[ii];
          camera = new THREE.PerspectiveCamera( view.fov, window.innerWidth / window.innerHeight, 1, 10000 );
          camera.position.x = view.eye[ 0 ];
          camera.position.y = view.eye[ 1 ];
          camera.position.z = view.eye[ 2 ];
         // camera.up.x = view.up[ 0 ];
         // camera.up.y = view.up[ 1 ];
        //  camera.up.z = view.up[ 2 ];
          view.camera = camera;
         // camera.lookAt(0,0,0)
        }

    // Create a three.js scene.
    scene = new THREE.Scene();

    scene.background = new THREE.Color( 0xbd8ef8 );



    // Create a three.js camera.
    camera = views[0].camera;
   // camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
    //var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 100);



    controls = new THREE.VRControls(camera);
    controls.standing = true;
    controls.standing = true;

   // camera.y = controls.userHeight;
    camera.lookAt(0, controls.userHeight, 0)

    // Apply VR stereo rendering to renderer.
    effect = new THREE.VREffect(renderer);
    effect.setSize(window.innerWidth, window.innerHeight);

   // raycaster = new THREE.Raycaster();

    // Create a VR manager helper to enter and exit VR mode.
    var params = {
      hideButton: false, // Default: false.
      isUndistorted: false // Default: false.
    };
    manager = new WebVRManager(renderer, effect, params);

    

    loader = new THREE.TextureLoader();
    //setPlayerTexture calls setupStage which triggers animate
    loader.load('img/Space_Harrier_player_sprite.png', setPlayerTexture);

    var loader2 = new THREE.TextureLoader();
    loader2.load('img/blaster.png', function(texture){
        blasterMaterial = new THREE.SpriteMaterial( { map: texture, color: 0xffffff } );
       // createBlaster();

       // needs a delay??
       if (forceVR && manager.isVRCompatible){
          manager.enterVRMode_();
          console.log(manager)
       }

    });

    var loader3 = new THREE.TextureLoader();
    loader2.load('img/enemy.png', function(texture){
        enemyMaterial = new THREE.SpriteMaterial( { map: texture, color: 0xffffff } );
       // createEnemy();
        spawnEnemies();

    });

    createLights();
    setupGround();
   // addGround();

    

    window.addEventListener('resize', onResize, true);
    window.addEventListener('vrdisplaypresentchange', onResize, true);
    document.addEventListener( 'mousemove', onDocumentMouseMove, false );
    document.addEventListener( 'click', createBlaster, true );
    document.addEventListener( 'touchstart', createBlaster, true );

    


}





/*
// Add a repeating grid as a skybox.
var boxSize = 5;
var loader = new THREE.TextureLoader();
loader.load('img/box.png', onTextureLoaded);

function onTextureLoaded(texture) {
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(boxSize, boxSize);

  var geometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
  var material = new THREE.MeshBasicMaterial({
    map: texture,
    color: 0x01BE00,
    side: THREE.BackSide
  });
*/




/*
  // Align the skybox to the floor (which is at y=0).
  skybox = new THREE.Mesh(geometry, material);
  skybox.position.y = boxSize/2;
  scene.add(skybox);
*/

  // Floor
  //var floor = new THREE.Mesh(cube, floorMat );
  //scene.add( floor );

 // createSea();


  // For high end VR devices like Vive and Oculus, take into account the stage
  // parameters provided.
 // setupStage();
//}


// Create 3D objects.
/*
var geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
//var material = new THREE.MeshNormalMaterial();
var cube = new THREE.Mesh(geometry, material);

// Position cube mesh to be right in front of you.
cube.position.set(0, controls.userHeight, -1);

// Add cube mesh to your three.js scene
scene.add(cube);
*/



function setPlayerTexture(playerTexture){
  //var playerTexture = THREE.ImageUtils.loadTexture( 'img/Space_Harrier_player_sprite.png' );
  var playerMaterial = new THREE.SpriteMaterial( { map: playerTexture, color: 0xffffff } );
  player = new THREE.Sprite( playerMaterial );


  //player.position.set(0, controls.userHeight, -1);
  player.position.z = -1;

  player.scale.set( .5, .5, 1.0 ); // imageWidth, imageHeight

  pivot = new THREE.Object3D();
  pivot.position.set(0, controls.userHeight, 0);
  scene.add(pivot);
  pivot.add(player);

  var r = 1;
  helper = new THREE.BoxHelper( new THREE.Mesh( new THREE.BoxGeometry( r, r, r)));
  helper.material.color.setHex( 0x080808);
  helper.material.blending = THREE.AdditiveBlending;
  //helper.position.set(0, controls.userHeight, 0);
  helper.position.z = -1;
  helper.scale.set( .2, .2, .2);
  pivot.add(helper);

  if (debug ==false) helper.visible = false;
  // position the object on the pivot, so that it appears 5 meters 
  // in front of the user.

  //controlPlayer(0,0);


  //scene.add( player );

  setupStage();

}


function animate(timestamp) {
  var delta = Math.min(timestamp - lastRender, 500);
  lastRender = timestamp;
  //uTime = timestamp;

  // Apply rotation to cube mesh
 // cube.rotation.y += delta * 0.0006;

 // find intersections
 /* raycaster.setFromCamera( mouse, camera );
  var intersects = raycaster.intersectObjects( scene.children );
  if ( intersects.length > 0 ) {
    if ( INTERSECTED != intersects[ 0 ].object && intersects[ 0 ].object.name == "enemy") {
      if ( INTERSECTED ) //INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
      INTERSECTED = intersects[ 0 ].object;
     // INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
     // INTERSECTED.material.emissive.setHex( 0xff0000 );
     // console.log(intersects[ 0 ].object.name);
    }
  } else {
    if ( INTERSECTED ) //INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
    INTERSECTED = null;
  }
*/

  // collision detection:
  //   determines if any of the rays from the cube's origin to each vertex
  //    intersects any face of a mesh in the array of target meshes
  //   for increased collision accuracy, add more vertices to the cube;
  //    for example, new THREE.CubeGeometry( 64, 64, 64, 8, 8, 8, wireMaterial )
  //   HOWEVER: when the origin of the ray is within the target mesh, collisions do not occur
 // var originPoint = pivot.position.clone();
 /*
  var originPoint = new THREE.Vector3();
  originPoint.setFromMatrixPosition( player.matrixWorld );

  blaster.position.set(vector.x , vector.y, vector.z );
  
  for (var vertexIndex = 0; vertexIndex < helper.geometry.vertices.length; vertexIndex++)
  {   
    var localVertex = helper.geometry.vertices[vertexIndex].clone();
    var globalVertex = localVertex.applyMatrix4( helper.matrix );
    var directionVector = globalVertex.sub( helper.position );
    
    var ray = new THREE.Raycaster( originPoint, directionVector.clone().normalize() );
    var collisionResults = ray.intersectObjects( collidableMeshList );
    if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) 
      console.log(" Hit ");
  } 
  */


  // #3

  /*
  var newPos = new THREE.Vector3(0,0,0);
    var collisions = [];

    for (var i = 0; i < lasers.length; i++) {
      if (lasers[i].active) {
        lasers[i].time += t;
        newPos.copy(lasers[i].dir);
        newPos.multiplyScalar(lasers[i].time * laserVelocity);
        lasers[i].position.copy(newPos);
        //lasers[i].rotation.x = Math.PI/2;
        lasers[i].lookAt(lasers[i].dir);
        var kill_this_laser = false;

        raycaster.set(lasers[i].position, lasers[i].dir);
        intersects = raycaster.intersectObjects(planets);
        if (intersects.length > 0 && intersects[0].distance < collisionDist) {
          hitCount++;
          var obj = intersects[i].object;
          //obj.material.emissive.setHex(0x00ff00);
      
          spawnPlanet(obj);
          kill_this_laser = true;
        }

        // check max distance for laser:
        if (lasers[i].position.z < maxLaserDist) {
          kill_this_laser = true;
        }

        if (kill_this_laser) killLaser(i);
      }
    }
    */

  playerVector.setFromMatrixPosition( player.matrixWorld );
 // console.log(playerVector)

  raycaster.set(new THREE.Vector3(playerVector.x, playerVector.y, playerVector.z), camera.position);
  var collisionResults = raycaster.intersectObjects( collidableMeshList );
  //if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) 
  if ( collisionResults.length > 0 ) {
      console.log(" Hit ");
    player.material.color = new THREE.Color(0x0066CC);
  }else{
    player.material.color = new THREE.Color(0xffffff);
  }

  controls.update();
  // Render the scene through the manager.
 // manager.render(scene, camera, timestamp);
 // effect.render(scene, camera);


  for ( var ii = 0; ii < views.length; ++ii ) {
          view = views[ii];
          var vcamera = view.camera;
          view.updateCamera( vcamera, scene,null, null );
          var left   = Math.floor( window.innerWidth  * view.left );
          var bottom = Math.floor( window.innerHeight * view.bottom );
          var width  = Math.floor( window.innerWidth  * view.width );
          var height = Math.floor( window.innerHeight * view.height );
          renderer.setViewport( left, bottom, width, height );
          renderer.setScissor( left, bottom, width, height );
          renderer.setScissorTest( true );
          renderer.setClearColor( view.background );
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
         // renderer.render( scene, camera );
          manager.render(scene, vcamera, timestamp);
          effect.render(scene, vcamera);
        }
  
  //player.position.set(0, controls.userHeight, -1);
 // pivot.rotation.y = camera.rotation.y;
  //console.log(camera.rotation.y)




  pivot.rotation.copy( camera.rotation );
  pivot.updateMatrix();


  //pivot.applyQuaternion(camera.quaternion);
/*
  var yaxis = new THREE.Vector3(0, 1, 0);
var zaxis = new THREE.Vector3(0, 0, 1);
var direction = zaxis.clone();
// Apply the camera's quaternion onto the unit vector of one of the axes
// of our desired rotation plane (the z axis of the xz plane, in this case).
direction.applyQuaternion(camera.quaternion);
// Project the direction vector onto the y axis to get the y component
// of the direction.
var ycomponent = yaxis.clone().multiplyScalar(direction.dot(yaxis));
// Subtract the y component from the direction vector so that we are
// left with the x and z components.
direction.sub(ycomponent);
// Normalize the direction into a unit vector again.
direction.normalize();
// Set the pivot's quaternion to the rotation required to get from the z axis
// to the xz component of the camera's direction.
pivot.quaternion.setFromUnitVectors(zaxis, direction);
*/
/*
  var vec = new THREE.Vector3( 0, 0, -1 );
  vec.applyQuaternion( camera.quaternion );

  pivot.rotation.copy( vec );


  var vector = camera.getWorldDirection();
  var theta = Math.atan2(vector.x,vector.z);
*/
/*
  var startRotation = new THREE.Euler().copy( camera.rotation );
  pivot.rotation.copy(startRotation)
  */
 // pivot.rotation.z = camera.rotation.z;


 // helper.rotation.y = camera.rotation.y;
 // helper.rotation.x = camera.rotation.x;

  for(var i=0; i<floor.length; i++) {
      
      ground = floor[i]; 
        
      // move it forward by a 10th of its array position each time 
      ground.position.z +=  0.5;
        
      // once the star is too close, reset its z position
      if(ground.position.z>400) ground.position.z-=1600;   
  }
 // console.log(camera.rotation)
/*
 var camDir = camera.getWorldDirection();
 //var camDir = new THREE.Vector3(0, .1, -4)
 var horizon = new THREE.Vector3(camDir.x, .02, camDir.z);
 var scaleCam = horizon.multiplyScalar(2);
*/
 for(var i=0; i<blasterArr.length; i++) {

    //console.log(blasterArr[i])
    var blasterCollision = blasterArr[i].raycaster.intersectObjects( collidableMeshList );
    //if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) 
    if ( blasterCollision.length > 0 && blasterArr[i].active==true) {
        console.log(" BLASTED " + blasterCollision[0].object.name);
        console.log(blasterCollision[0])
        blasterCollision[0].object.material.color = new THREE.Color(0x0066CC);
        blasterArr[i].active=false;
        scene.remove(blasterCollision[0].object);
       // scene.remove(blasterCollision[0]);
       // collidableMeshList.splice(collidableMeshList.indexOf(blasterCollision[0].object), 1);
        collidableMeshList.splice(collidableMeshList.indexOf(blasterCollision[0].object), 1);
        console.log(collidableMeshList);
        scene.remove(blasterArr[i]);
        blasterArr.splice(i, 1);
    }else{
     
      blasterArr[i].position.x += blasterArr[i].blasterDir.x * blasterSpeed;
      blasterArr[i].position.y += blasterArr[i].blasterDir.y * blasterSpeed;
      blasterArr[i].position.z += blasterArr[i].blasterDir.z * blasterSpeed;
      if (timestamp - blasterArr[i].time > 1000) {
        scene.remove(blasterArr[i]);
        blasterArr.splice(i, 1);

      }
    }
    



 }

 if (enemiesPool.length > 0 ) updateEnemies();
 //console.log(enemiesPool.length)

 player.position.x = xA;
 player.position.y = yA;  



//console.log(yA)
 
 //info.textContent = "x:"+vrDisplay.orientation_.x.toFixed(2)+",y:"+vrDisplay.orientation_.y.toFixed(2)+",z:"+vrDisplay.orientation_.z.toFixed(2);

 

// console.log(vrDisplay.orientation_)

  vrDisplay.requestAnimationFrame(animate);
}

function onResize(e) {
  effect.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
}



// Get the HMD, and if we're dealing with something that specifies
// stageParameters, rearrange the scene.
function setupStage() {
  navigator.getVRDisplays().then(function(displays) {
    if (displays.length > 0) {
      vrDisplay = displays[0];
      if (vrDisplay.stageParameters) {
        setStageDimensions(vrDisplay.stageParameters);
        // if (forceVR && manager.isVRcompatible){
          //  manager.enterVRMode_();
           // console.log(manager)
        // }
      }
      vrDisplay.requestAnimationFrame(animate);
    }
 //   console.log(vrDisplay.orientation_);
     // window.addEventListener("devicemotion", function(event) 
      
    // is mobile? has accelerometer?
    //if(window.DeviceMotionEvent) { 
   //   var util = new Util;
  //    console.log(util.isMobile)
  // bad mobile detection
    if(window.innerWidth < 769) { 
      console.log('isDeviceMotion')

      window.addEventListener("devicemotion", function(event) 
      {
        
          //accX = Math.round(event.accelerationIncludingGravity.x*10) / 10;  
          //accY = Math.round(event.accelerationIncludingGravity.y*10) / 10;  
         // accY = event.accelerationIncludingGravity.y;
        // if (manager.mode == 1){

          accZ = event.accelerationIncludingGravity.z; 
          accY = event.accelerationIncludingGravity.y;
          accZsmooth = factor * accZsmooth + (1 - factor) * accZ;
          accYsmooth = factor * accYsmooth + (1 - factor) * accY;

          if (debug) info.innerHTML = 'accZ:'+accZ.toFixed(2)+', accZsm:'+accZsmooth.toFixed(2)+', accY:'+accYsmooth.toFixed(2);
          
          movement = 2;
          
          if (manager.mode == 1){
            xA = -accYsmooth * movement;
            yA = - accZsmooth * .4;// *movement;
          }else{
            yA = accZsmooth * .5;// *movement;
            xA = -accYsmooth * .5
          }
          
       /*   }else{
            xA = 0;
            yA = 0;
            player.position.set(0,0,-2)

          }
          */
          
          //run();
      }, true);
      /*
      window.addEventListener("deviceorientation", function(event) 
      {
          
          var xValue = Math.round(event.gamma);
          var yValue = Math.round(event.beta);
          var Rotation = Math.round(event.alpha);

          info.innerHTML = 'x:'+xValue+', y:'+yValue+' ,rot:'+Rotation;
        //  info.innerHTML = "x:"+vrDisplay.orientation_.x.toFixed(2)+",y:"+vrDisplay.orientation_.y.toFixed(2)+",z:"+vrDisplay.orientation_.z.toFixed(2);
          var halfwidth= window.innerWidth/2;
          var newYPos = yValue/5;
          info.innerHTML += ' n:'+newYPos.toFixed(2);

          //for landscape, reverse x and y
          controlPlayer(newYPos, 0);



          
        }, true);
        */



    }    
  });
  
}


function onDocumentMouseMove( event ) {

  event.preventDefault();

  mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
  mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

  if (debug) info.innerHTML = 'x:'+mouse.x.toFixed(2)+', y:'+mouse.y.toFixed(2);

  //controlPlayer(-mouse.x.toFixed(2)*10)
  controlPlayer(mouse.x, mouse.y/2)

}

function controlPlayer(xAcc, yAcc){

   // accX = (xAcc*10) / 10;  
   // accY = (yAcc*10) / 10;  

    accX = xAcc;
    accY = yAcc;
    
    movement = 10;
    
    xA = -(accX / 10) * movement;
    yA = -(accY / 10) * movement;

   //   player.position.x = xpos;
/*
     TweenMax.to(player.position ,50,{
            x:xpos,
           // y:0,
            ease:"Power3.easeOut",
            onUpdate:function(){
                      //  console.log('tweened');
            }
      });
      */
}
/*
function addLights() {
    var dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(100, 100, 50);
    scene.add(dirLight);
}
*/



function createBlaster(event){
/*
  var geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
var material = new THREE.MeshNormalMaterial();
var cube = new THREE.Mesh(geometry, material);
scene.add(cube);
cube.position.set(0, controls.userHeight, -10);

*/
  if (manager.mode == 3) event.preventDefault();
 // manager.enterVRMode_();
 // console.log(manager.mode)
 // console.log('createBlaster')
  /*
  if (manager.mode == 3){
    camera.fov = 25;

    camera.updateProjectionMatrix();
  }else{
    camera.fov = 75;
    camera.updateProjectionMatrix();

  }
  */
 // console.log(camera.getWorldDirection());

  blaster = new THREE.Sprite( blasterMaterial );
  //blaster.position.z = -10;
  //blaster.position.x = 0;//player.position.x;
  //blaster.position.y = 0;//player.position.y;
  blaster.scale.set( .2, .2, 1.0 );
  blaster.time = lastRender;
  blaster.active = true;

  blaster.raycaster = new THREE.Raycaster(new THREE.Vector3(playerVector.x, playerVector.y, playerVector.z), camera.position);

  //var camDir = camera.getWorldDirection();
//  var scaleCam = camDir.multiplyScalar(1.1);

 // blaster.position.set(player.position.x, controls.userHeight + player.position.y, player.position.z - .1);


//  var vector = new THREE.Vector3();
//  vector.setFromMatrixPosition( player.matrixWorld );

  blaster.position.set(playerVector.x , playerVector.y, playerVector.z );
  scene.add(blaster);

  blasterArr.push(blaster);

  var camDir = camera.getWorldDirection(camVector).multiplyScalar(40);
 //var camDir = new THREE.Vector3(0, .1, -4)
// var horizon = new THREE.Vector3(camDir.x, .02, camDir.z);
 //var scaleCam = horizon.multiplyScalar(2);

 blaster.blasterDir = camDir;//scaleCam;

  var from = blaster.position;//new THREE.Vector3( 2, 2, 2 );
  var to = camDir;//new THREE.Vector3( 0, controls.userHeight, -40);
  var direction = to.clone().sub(from);
  var length = direction.length();
  var arrowHelper = new THREE.ArrowHelper(direction.normalize(), from, length, 0xff0000 );
  scene.add( arrowHelper );

  arrowArr.push( arrowHelper);

  playSound();

}

function createEnemy(ang){

  enemy = new Enemy();
  console.log('new enemy')

  enemy.mesh.scale.set( .65, .65, 1.0 ); // imageWidth, imageHeight

 // enemy.mesh.position.z = -1;//-Math.sin(enemy.angle)*enemy.distance;
  enemy.mesh.position.y = controls.userHeight;// + Math.random()*controls.userHeight ;
 // enemy.mesh.position.x = (Math.random()*10) - 5;// Math.cos(enemy.angle)*enemy.distance;
  //player.position.set(0, controls.userHeight, -1);
  //var ang = Math.random() * 10;
  enemy.angle = Math.random()*360;
  enemy.mesh.lookAt(camera);
  enemy.mesh.name = "enemy"+ang;
 // enemy.angle = - (ang*0.1);
 // enemy.distance = game.seaRadius + game.planeDefaultHeight + (-1 + Math.random() * 2) * (game.planeAmpHeight-20);
  enemy.mesh.position.z = -5 + Math.sin(enemy.angle)*10;
  enemy.mesh.position.x = Math.random()*4 - 2;
 // enemy.mesh.position.x = Math.cos(enemy.angle)*10;

  var r = 1;
  var nhelper = new THREE.BoxHelper( new THREE.Mesh( new THREE.BoxGeometry( r, r, r)));
  nhelper.material.color.setHex( 0x080808);
  nhelper.material.blending = THREE.AdditiveBlending;
  //helper.position.set(0, controls.userHeight, 0);
  
  enemy.mesh.add(nhelper);

  scene.add(enemy.mesh);
  enemiesPool.push(enemy);
  //collidableMeshList.push(enemy.mesh);
  collidableMeshList.push(nhelper);
 
}

function spawnEnemies(){
  var nenemies = 10;//game.level;

  for (var i=0; i<nenemies; i++){
    createEnemy(i);
  }
}



var Enemy = function(){
 /* var geom = new THREE.TetrahedronGeometry(8,2);
  var mat = new THREE.MeshPhongMaterial({
    color:Colors.red,
    shininess:0,
    specular:0xffffff,
    shading:THREE.FlatShading
  });
  */

  this.mesh = new THREE.Sprite( enemyMaterial );
  this.mesh.castShadow = false;//true;
  this.angle = 0;
  this.dist = 0;
}
/*
var enemiesHolder = function (){
  this.mesh = new THREE.Object3D();
  this.enemiesInUse = [];
}

enemiesHolder.prototype.spawnEnemies = function(){
  var nenemies = game.level;

  for (var i=0; i<nenemies; i++){
    var enemy;
    if (enemiesPool.length) {
      enemy = enemiesPool.pop();
    }else{
      enemy = new Enemy();
      console.log('new enemy')
    }

    enemy.angle = - (i*0.1);
   // enemy.distance = game.seaRadius + game.planeDefaultHeight + (-1 + Math.random() * 2) * (game.planeAmpHeight-20);
   // enemy.mesh.position.y = -game.seaRadius + Math.sin(enemy.angle)*enemy.distance;
    enemy.mesh.position.z = -5;//-Math.sin(enemy.angle)*enemy.distance;
    enemy.mesh.position.x = 0;// Math.cos(enemy.angle)*enemy.distance;

    this.mesh.add(enemy.mesh);
    this.enemiesInUse.push(enemy);
  }
}
/*
enemiesHolder.prototype.rotateenemies = function(){
  for (var i=0; i<this.enemiesInUse.length; i++){
    var enemy = this.enemiesInUse[i];
    enemy.angle += game.speed*deltaTime*game.enemiesSpeed;

    if (enemy.angle > Math.PI*2) enemy.angle -= Math.PI*2;

    enemy.mesh.position.y = -game.seaRadius + Math.sin(enemy.angle)*enemy.distance;
    enemy.mesh.position.x = Math.cos(enemy.angle)*enemy.distance;
    enemy.mesh.rotation.z += Math.random()*.1;
    enemy.mesh.rotation.y += Math.random()*.1;

    //var globalenemyPosition =  enemy.mesh.localToWorld(new THREE.Vector3());
    var diffPos = airplane.mesh.position.clone().sub(enemy.mesh.position.clone());
    var d = diffPos.length();
    if (d<game.enemyDistanceTolerance){
      particlesHolder.spawnParticles(enemy.mesh.position.clone(), 15, Colors.red, 3);

      enemiesPool.unshift(this.enemiesInUse.splice(i,1)[0]);
      this.mesh.remove(enemy.mesh);
      game.planeCollisionSpeedX = 100 * diffPos.x / d;
      game.planeCollisionSpeedY = 100 * diffPos.y / d;
      ambientLight.intensity = 2;

      removeEnergy();
      i--;
    }else if (enemy.angle > Math.PI){
      enemiesPool.unshift(this.enemiesInUse.splice(i,1)[0]);
      this.mesh.remove(enemy.mesh);
      i--;
    }
  }
}
*/



function updateEnemies(vec) { 
 
  // iterate through every particle
  for(var i=0; i<enemiesPool.length; i++) {
 
    var nEnemy = enemiesPool[i]; 
   // console.log(nEnemy)
 
    // and move it forward dependent on the mouseY position. 
    nEnemy.mesh.position.z +=  .03;//.1;
 
    // if the particle is too close move it to the back
    if(nEnemy.mesh.position.z>20) {
      nEnemy.mesh.position.z-=40; 
      //console.log(nEnemy)
     // nEnemy.mesh.material.color = new THREE.Color(0xffffff);
     // console.log(nEnemy.mesh.material.color)
    }


    

 /// check if enemy is in view of camera ...
/*
    camera.updateMatrix();
    camera.updateMatrixWorld();
    var frustum = new THREE.Frustum();
    frustum.setFromMatrix(new THREE.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse));  

    // Your 3d point to check
    var pos = nEnemy.mesh.position;
    if (frustum.containsPoint(pos)) {
        // Do something with the position...
       // console.log(nEnemy.mesh)
       if (nEnemy.mesh.position.z >-1 )
          console.log('hit')
    }

    // console.log(camera.rotation)
*/
/*
    nEnemy.mesh.position.x -= vec.x * blasterSpeed;
    nEnemy.mesh.position.y -= vec.y * blasterSpeed;
    nEnemy.mesh.position.z -= vec.z * blasterSpeed;
    */
  }
 
 
 
}

function createObstacle(){

}




function setupGround(){

    loader.load('img/checkerboard.jpg', function(texture){
        var floorTexture = texture;
        floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
        floorTexture.repeat.set( 10, 10 );
        var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
        addGround(floorMaterial);
    });


    


   
}


function addGround(floorMaterial){

    //create the ground material using MeshLambert Material
 //   var groundMat = new THREE.MeshLambertMaterial( {color: 0xffffff, side: THREE.DoubleSide}  );
    //create the plane geometry
    var geometry = new THREE.PlaneGeometry(400,800,300,300);
   // var geometry = new THREE.BoxGeometry(400, 10, 800);

          //create the ground form the geometry and material


     for ( var z= -1600; z < 1600; z+=800 ) {
    
          
        /*  //make the terrain bumpy
          for (var i = 0, l = geometry.vertices.length; i < l; i++) {
            var vertex = geometry.vertices[i];
            var value = pn.noise(vertex.x / 10, vertex.y /10, 0);
            vertex.z = value *6;
          }
          //ensure light is computed correctly
          geometry.computeFaceNormals();
          geometry.computeVertexNormals();
        */
    

       //   var ground = new THREE.Mesh(geometry,groundMat); 

         //  var ground = new THREE.Mesh(geometry,floorMaterial); 
          var ground = new THREE.Mesh(geometry,checkerTexture); 
          //rotate 90 degrees around the xaxis so we can see the terrain 
          ground.rotation.x = -Math.PI/-2;
          // Then set the z position to where it is in the loop (distance of camera)
          ground.position.z = z;
          //add the ground to the scene
          scene.add(ground); 
          //finally push it to the stars array 
          floor.push(ground); 
      }


      /// alt versions
      /*
       // var geometry = new THREE.BoxGeometry(200, 200, 200);
        var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
       // material = new THREE.MeshBasicMaterial();
        //var floor = new THREE.Mesh(floorGeometry, material);
        var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
        floor.position.y = -0.5;
       floor.rotation.x = Math.PI / 2;
        scene.add(floor);
      */
    /*
    var floorTexture = new THREE.ImageUtils.loadTexture( 'img/checkerboard.jpg' );
    floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
    floorTexture.repeat.set( 10, 10 );
    var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
    var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
    var floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.position.y = -0.5;
    floor.rotation.x = Math.PI / 2;
    scene.add(floor);
    */
  }


function createLights() {
  // A hemisphere light is a gradient colored light; 
  // the first parameter is the sky color, the second parameter is the ground color, 
  // the third parameter is the intensity of the light
  hemisphereLight = new THREE.HemisphereLight(0xaaaaaa,0x000000, .9)
  
  // A directional light shines from a specific direction. 
  // It acts like the sun, that means that all the rays produced are parallel. 
  shadowLight = new THREE.DirectionalLight(0xffffff, .9);

  // Set the direction of the light  
  shadowLight.position.set(150, 350, 350);
  
  // Allow shadow casting 
  shadowLight.castShadow = true;

  // define the visible area of the projected shadow
  shadowLight.shadow.camera.left = -400;
  shadowLight.shadow.camera.right = 400;
  shadowLight.shadow.camera.top = 400;
  shadowLight.shadow.camera.bottom = -400;
  shadowLight.shadow.camera.near = 1;
  shadowLight.shadow.camera.far = 1000;

  // define the resolution of the shadow; the higher the better, 
  // but also the more expensive and less performant
  shadowLight.shadow.mapSize.width = 2048;
  shadowLight.shadow.mapSize.height = 2048;
  
  // to activate the lights, just add them to the scene
  scene.add(hemisphereLight);  
  scene.add(shadowLight);
}

function setDebug(bool){
    debug = bool;
    if (bool ==false) info.innerHTML = null;
}


function setStageDimensions(stage) {
  // Make the skybox fit the stage.
  /*
  var material = skybox.material;
 // scene.remove(skybox);

  // Size the skybox according to the size of the actual stage.
  var geometry = new THREE.BoxGeometry(stage.sizeX, boxSize, stage.sizeZ);
  skybox = new THREE.Mesh(geometry, material);

  // Place it on the floor.
  skybox.position.y = boxSize/2;
 // scene.add(skybox);
*/
  // Place the cube in the middle of the scene, at user height.
  player.position.set(0, controls.userHeight, -1);
}

/*
window.ondevicemotion = function(event) {
        
    accX = Math.round(event.accelerationIncludingGravity.x*10) / 10;  
    accY = Math.round(event.accelerationIncludingGravity.y*10) / 10;  
    
    movement = 1;
    
    xA = -(accX / 10) * movement;
    yA = -(accY / 10) * movement;
    
    
    //run();
    
}  
*/

/*
var shootDirection = new THREE.Vector3();
var shootVelo = 15;
var projector = new THREE.Projector();
function getShootDir(targetVec){
    var vector = targetVec;
    targetVec.set(0,0,1);
    projector.unprojectVector(vector, camera);
    var ray = new THREE.Ray(sphereBody.position, vector.sub(sphereBody.position).normalize() );
    targetVec.copy(ray.direction);
}

            window.addEventListener("click",function(e){
                if(controls.enabled==true){
                    var x = sphereBody.position.x;
                    var y = sphereBody.position.y;
                    var z = sphereBody.position.z;
                    var ballBody = new CANNON.Body({ mass: 1 });
                    ballBody.addShape(ballShape);
                    var ballMesh = new THREE.Mesh( ballGeometry, material );
                    world.add(ballBody);
                    scene.add(ballMesh);
                    ballMesh.castShadow = true;
                    ballMesh.receiveShadow = true;
                    balls.push(ballBody);
                    ballMeshes.push(ballMesh);
                    getShootDir(shootDirection);
                    ballBody.velocity.set(  shootDirection.x * shootVelo,
                                            shootDirection.y * shootVelo,
                                            shootDirection.z * shootVelo);

                    // Move the ball outside the player sphere
                    x += shootDirection.x * (sphereShape.radius*1.02 + ballShape.radius);
                    y += shootDirection.y * (sphereShape.radius*1.02 + ballShape.radius);
                    z += shootDirection.z * (sphereShape.radius*1.02 + ballShape.radius);
                    ballBody.position.set(x,y,z);
                    ballMesh.position.set(x,y,z);
                }
            });

*/
  resetGame();
  loadGetReady();
  loadSound();
  init();
 // createEnemy();

</script>

</html>
