<!DOCTYPE html>
<html lang="en">

<head>
    <title>Space Harrier VR: insert coin</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <style>
    body {
        margin: 0px;
        padding: 0;
        overflow: hidden;
        display: flex;
        width: 100%;
        height: 100%;
        background-color: #bd8ef8;
        color: #fff;
        align-items: center;
        justify-content: center;
    }
    
    #info {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 101;
        display: none;
    }
    
    #score {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 102;
    }

    .stats{
        position: absolute;
        left: 0;
        bottom: 0;
    }

 
    /*
* {cursor: none;}
*/
    </style>
</head>

<body>
    <a href="#" id="reset"><div id='info'></div></a>
    <div id='score'></div>
   
</body>
<!--
<script id="vertexShader" type="x-shader/x-vertex">
    varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }
</script>
<script id="fragmentShader" type="x-shader/x-fragment">
    uniform vec3 color1; uniform vec3 color2; uniform float scale; varying vec2 vUv; void main() { vec2 center = -1.0 + 2.0 * vUv; vec2 uv = floor(center.xy * scale); if(mod(uv.x + uv.y, 2.0) > 0.5){ gl_FragColor = vec4(color1, 1.0); }else{ gl_FragColor = vec4(color2, 1.0); } }
</script>

-->

<script id="vertexShader" type="x-shader/x-vertex">
      varying vec2 vUv;
      uniform float time;
      uniform float speed;
      uniform float scale;
      //varying float z;

      void main() {
        vUv = uv;

        //float z = scale;
        //float y = scale;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);

      }
  </script>
  
  <script id="fragmentShader" type="x-shader/x-fragment">

      uniform vec3 color1; 
      uniform vec3 color2;


      uniform float speed;
      uniform float scale;
      uniform float delta;

      uniform float time;
      varying vec2 vUv;
      uniform vec2 u_resolution;



      void main() {


        
        float delta = time * speed;

        vec2 center = -1.0 + 2.0 * vUv;

        vec2 uv = center.xy * scale;

        uv.y+=delta;

        gl_FragColor = vec4(color1, 1.0);
    
        if (floor(mod(uv.y, 2.0)) < 1.0) {
            if (mod(uv.x, 2.0) > 1.0)
                gl_FragColor = vec4(color2, 1.0);
        } else {
            if (mod(uv.x, 2.0) < 1.0)
                gl_FragColor = vec4(color2, 1.0);
        }

      }
  </script>
<script>
/*
 * Debug parameters.
 */
WebVRConfig = {
    /**
     * webvr-polyfill configuration
     */

    // Forces availability of VR mode.
    // FORCE_ENABLE_VR: true, // Default: false.
    // Complementary filter coefficient. 0 for accelerometer, 1 for gyro.
    //K_FILTER: 0.98, // Default: 0.98.
    // How far into the future to predict during fast motion.
    //PREDICTION_TIME_S: 0.040, // Default: 0.040 (in seconds).
    // Flag to disable touch panner. In case you have your own touch controls
    // TOUCH_PANNER_DISABLED: true, // Default: false.
    // Enable yaw panning only, disabling roll and pitch. This can be useful for
    // panoramas with nothing interesting above or below.
    YAW_ONLY: false, // Default: false.
    // Enable the deprecated version of the API (navigator.getVRDevices).
    //ENABLE_DEPRECATED_API: true, // Default: false.
    // Scales the recommended buffer size reported by WebVR, which can improve
    // performance. Making this very small can lower the effective resolution of
    // your scene.
    BUFFER_SCALE: 1, // default: 1.0
    // Allow VRDisplay.submitFrame to change gl bindings, which is more
    // efficient if the application code will re-bind it's resources on the
    // next frame anyway.
    // Dirty bindings include: gl.FRAMEBUFFER_BINDING, gl.CURRENT_PROGRAM,
    // gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING,
    // and gl.TEXTURE_BINDING_2D for texture unit 0
    // Warning: enabling this might lead to rendering issues.
    //DIRTY_SUBMIT_FRAME_BINDINGS: true // default: false
};
</script>
<!--
  A polyfill for Promises. Needed for IE and Edge.
  -->
<script src="node_modules/es6-promise/dist/es6-promise.js"></script>
<!--
  three.js 3d library
  -->
<script src="node_modules/three/build/three.min.js"></script>
<script src="../../bower_components/three.js/examples/js/libs/ammo.js"></script>
<script src="../../bower_components/three.js/examples/js/Detector.js"></script>
<script src="../../bower_components/three.js/examples/js/libs/stats.min.js"></script>
<script src="../../bower_components/three.js/examples/js/ConvexObjectBreaker.js"></script>
<script src="../../bower_components/three.js/examples/js/QuickHull.js"></script>
<script src="../../bower_components/three.js/examples/js/geometries/ConvexGeometry.js"></script>
<script src="../../bower_components/three.js/examples/js/utils/GeometryUtils.js"></script>
<script src="../../bower_components/gsap/src/minified/TweenMax.min.js"></script>
<!--
  VRControls.js acquires positional information from connected VR devices and applies the transformations to a three.js camera object.
   -->
<script src="node_modules/three/examples/js/controls/VRControls.js"></script>
<!--
<script src="node_modules/three/examples/js/controls/DeviceOrientationControls.js"></script>
-->
<!--
  VREffect.js handles stereo camera setup and rendering.
  -->
<script src="node_modules/three/examples/js/effects/VREffect.js"></script>
<!--
  A polyfill for WebVR using the Device{Motion,Orientation}Event API.
  -->
<script src="node_modules/webvr-polyfill/build/webvr-polyfill.js"></script>
<!--
  Helps enter and exit VR mode, provides best practices while in VR.
  -->
<script src="build/webvr-manager.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.19.0/TweenMax.min.js"></script>
<!--
<script src="build/threejs-texture-checkerboard.js"></script>
-->
<script src="node_modules/reticulum/reticulum.js"></script>
<script src="node_modules/howler/dist/howler.min.js"></script>
<script src="../../bower_components/three.js/examples/js/libs/pnltri.min.js"></script>
        <script>
            THREE.ShapeUtils.triangulateShape = ( function () {
                var pnlTriangulator = new PNLTRI.Triangulator();
                function removeDupEndPts(points) {

                    var l = points.length;

                    if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

                        points.pop();

                    }

                }

                return function triangulateShape( contour, holes ) {
                    // console.log("new Triangulation: PnlTri.js " + PNLTRI.REVISION );

                    removeDupEndPts( contour );
                    holes.forEach( removeDupEndPts );

                    return pnlTriangulator.triangulate_polygon( [ contour ].concat(holes) );
                };
            } )();
        </script>
<script>
var forceVR = true;//false; //true;
var debug = false; //true;

var renderer, scene, camera, controls, effect, manager, loader, stats, title, coins;
var playerGroup, playerblock, playerBody, playerState;
var pivot, player, player_sprite;
var mouse = new THREE.Vector2();
var uTime;
var helper;
var blasterArr = [];
var letterArr = [];
var explosionArr = [];
var enemyPool = [];
var blasterSpeed = .3; //5;
var info = document.getElementById('info');
var touchEnabled = false;
var gameOn = false;
var gameSetupComplete = false;
var pressTimer = false;
var pressCounter = 0;
var freeze = false;
var enemyAttackRange = 1000;

var annie, hero;

var score_display = document.getElementById('score');
var score = 0;
var bang, getReady, explode, argh, bkgdMusic, laser, startgame;

var textureLoader;
var clock = new THREE.Clock();
var playerVector = new THREE.Vector3();
var camVector = new THREE.Vector3();
var camDir = new THREE.Vector3();
var heroTexture;

var direction = new THREE.Vector3();

var mouseCoords = new THREE.Vector2();
var raycaster = new THREE.Raycaster();
var ballMaterial = new THREE.MeshPhongMaterial({
    color: 0x000000,
    wireframe: false,
    //transparent:true, opacity:0.5
});

var hemisphereLight, shadowLight;
var floorMaterial, floorPlane;
var floor = [];
//var checkerTexture;
var xA = 0;
var yA = 0;
var accX = 0;
var accY = 0;
var accZ = 0;

// Physics variables
var gravityConstant = 0; //0.1; //7.8;
var collisionConfiguration;
var dispatcher;
var broadphase;
var solver;
var physicsWorld;
var margin = 0.05;

var convexBreaker = new THREE.ConvexObjectBreaker();

// Rigid bodies include all movable objects
var rigidBodies = [];

var pos = new THREE.Vector3();
var quat = new THREE.Quaternion();
var transformAux1 = new Ammo.btTransform();
var tempBtVec3_1 = new Ammo.btVector3(0, 0, 0);

var time = 0;

var objectsToRemove = [];
for (var i = 0; i < 500; i++) {
    objectsToRemove[i] = null;
}
var numObjectsToRemove = 0;

var impactPoint = new THREE.Vector3();
var impactNormal = new THREE.Vector3();

// Request animation frame loop function
var lastRender = 0;

var vrDisplay;

var accZsmooth = 0;
var accYsmooth = 0;
var factor = .98;

var _v3 = new THREE.Vector3;

var arrowArr = [];
 var group, textMesh1, textMesh2, textGeo, materials;

 var text = "VR",

        height = 20,
        size = 70,
        hover = 30,

        curveSegments = 4,

        bevelThickness = 20,
        bevelSize = 1.5,
        bevelSegments = 3,
        bevelEnabled = true,

        font = undefined,

        fontName = "Slukoni";//"optimer", // helvetiker, optimer, gentilis, droid sans, droid serif
        fontWeight = "Medium";//"bold"; // normal bold







var Colors = {
    red: 0xf25346,
    white: 0xd8d0d1,
    brown: 0x59332e,
    pink: 0xF5986E,
    brownDark: 0x23190f,
    blue: 0x68c3c0,
};

// shader for checkerboard

var options  = {
                

        speed            : 10.0,

        segments         : 324,

        checker_color1     : '#76c876',

        checker_color2     : '#a7f9a7',

        scale            : 50,

      //  perlin_passes    : 1,

        wireframe        : true,

      //  floor_visible    : true

    };


var uniforms = {
      "time": {
          type: "f",
          value: 0.0
      },
      "speed": {
          type: "f",
          value: options.speed
      },

  
      "color1" : {
        type : "c",
        value : new THREE.Color(0x76c876)
      },
      "color2" : {
        type : "c",
        value : new THREE.Color(0xa7f9a7)
      },
     
      "scale" : {
        type : "f",
        value : options.scale,
        min : 1, // only used for dat.gui, not needed for production
        max : 100 // only used for dat.gui, not needed for production
      },
    }
var vertexShader = document.getElementById('vertexShader').text;
var fragmentShader = document.getElementById('fragmentShader').text;

var defines = {};
defines[ "USE_MAP" ] = "";
var checkerTexture = new THREE.ShaderMaterial({
    defines: defines,
    uniforms: uniforms,
    vertexShader: vertexShader,
    fragmentShader: fragmentShader,
    side: THREE.DoubleSide,
   // lights:true
        // doubleSide: true,
});



// custom global variables
var annie, hero; // animators

var invisibleMat =  new THREE.MeshBasicMaterial( { 
    color: 0x00ff00, 
    side: THREE.BackSide,  
    wireframe: false,
    transparent: true,
    depthWrite: false,
    opacity: 0
});



var volume = 0.4;

// load Textures, then font
var loadingManager = new THREE.LoadingManager();

loadingManager.onStart = function ( url, itemsLoaded, itemsTotal ) {

    console.log( 'Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );

};

loadingManager.onLoad = function ( ) {

    console.log('loading manager complete');

    loadFont();

};


loadingManager.onProgress = function ( url, itemsLoaded, itemsTotal ) {

    console.log( 'Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );

};

loadingManager.onError = function ( url ) {

    console.log( 'There was an error loading ' + url );

};

var textureLoader = new THREE.TextureLoader( loadingManager );

var titleTexture = textureLoader.load( "img/spaceharrier_title.png");
var coinsTexture = textureLoader.load( "img/insert_coins.png");
var heroTexture = textureLoader.load( "img/hero-spritesheet.png" );
var explosionTexture = textureLoader.load( "img/explosion_sprite_small.png" );
var enemyTexture = textureLoader.load( "img/Space_Harrier_enemy_Mukadensu.png" );
var blasterTexture = textureLoader.load( "img/blaster.png" );
var enemyBlasterTexture = textureLoader.load( "img/enemy_blaster.png" );

function loadSounds(){

    bkgdMusic = new Howl({
        preload: true,
        src: ['audio/sh-theme.mp3'],
        volume: volume
    });

    bang = new Howl({
        preload: true,
        src: ['audio/boing.mp3'],
        volume: volume
    });

    getReady = new Howl({
        preload: true,
        src: ['audio/ready.mp3'],
        volume: volume
    });

    explode = new Howl({
        preload: true,
        src: ['audio/explode.mp3'],
        volume: volume
    });

    argh = new Howl({
        preload: true,
        src: ['audio/sharrierAAArg.mp3'],
        volume: volume
    });

    laser = new Howl({
        preload: true,
        src: ['audio/projectile.wav'],
        volume: 1
    });

    startgame = new Howl({
        preload: true,
        src: ['audio/sharrierCoin.mp3'],
        volume: 1
    });

}




function playBkgd() {
    bkgdMusic.play();
}





function playBang() {
    bang.play();
}



function playGetReady() {
    getReady.play();
}


function playExplode() {
    explode.play();
}


function playArgh() {
    argh.play();
}

function playLaser() {
    laser.play();
}

function playCoin() {
    startgame.play();
}

function muteAll() {
    howler.mute();
}

function init(){
   /* loadBkgd();
    loadGetReady();
    //playBkgd();
    loadSound();
    loadArgh();
    loadExplode();
*/
    loadSounds();
    //playBkgd();

    createScene();
    initPhysics();
    createGround();
    createTitleScreen();
   // createStartButton();
    initInput();
    
}


function createScene() {

    setDebug(true);



    renderer = new THREE.WebGLRenderer({
        antialias: true,
        precision: "mediump"
    });
    renderer.setClearColor(0xffff00);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;

    // Append the canvas element created by the renderer to document body element.
    document.body.appendChild(renderer.domElement);

    // Create a three.js scene.
    scene = new THREE.Scene();

    scene.background = new THREE.Color(0xbd8ef8);



    // Create a three.js camera.
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
    //var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 100);
    setupPointer();
    scene.add(camera)

    controls = new THREE.VRControls(camera);
    controls.standing = true;
    controls.standing = true;

    // Apply VR stereo rendering to renderer.
    effect = new THREE.VREffect(renderer);
    effect.setSize(window.innerWidth, window.innerHeight);

    // Create a VR manager helper to enter and exit VR mode.
    var params = {
        hideButton: false, // Default: false.
        isUndistorted: false // Default: false.
    };
    manager = new WebVRManager(renderer, effect, params);

    setupStage();

    
        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.bottom = '0px';
        stats.domElement.style.top = null;
        stats.domElement.className= 'stats';
        document.body.appendChild(stats.domElement);
 
    createLights();


    setTimeout(function(){ 
        if (forceVR && manager.isVRCompatible) {
            manager.enterVRMode_();
            console.log(manager)
        }
    }, 50);

    window.addEventListener('resize', onResize, true);
    window.addEventListener('vrdisplaypresentchange', onResize, true);


}

function createStartButton(){
    var canvas1 = document.createElement('canvas');
    var context1 = canvas1.getContext('2d');
    canvas1.width = 100;
    canvas1.height = 100;
    var x = 0;
    var y = 50;
    context1.font = "20px Arial";
    context1.lineWidth = 1;
    context1.fillStyle = "rgba(255,0,0,0.95)";
    context1.strokeStyle = 'blue';
    var text = 'Hello, world!';
    context1.fillText(text, 0, 50);
   // context1.strokeText(text, 0, 50);
    
    // canvas contents will be used for a texture
    var texture1 = new THREE.Texture(canvas1) 
    texture1.needsUpdate = true;
      
    var material1 = new THREE.MeshBasicMaterial( {map: texture1, side:THREE.DoubleSide } );
   // material1.transparent = true;

    var mesh1 = new THREE.Mesh(
        new THREE.PlaneGeometry(100, 100),
        material1
      );
    mesh1.position.set(0,2,-80);
    scene.add( mesh1 );
    
}

function createTitleScreen(){

    console.log('create ttile')
    var titleMaterial = new THREE.MeshBasicMaterial({
        map: titleTexture,
        color: 0xffffff,
        transparent: true
    });

    title = new THREE.Mesh(new THREE.PlaneGeometry(2, 1, 1, 1), titleMaterial);
      //  title.scale.set(2, 1, 1)
    title.position.set(0, controls.userHeight+.1, -5);
    title.castShadow = true;
    scene.add(title);




    var coinsMaterial = new THREE.MeshBasicMaterial({
        map: coinsTexture,
        color: 0xffffff,
        transparent: true,
        opacity: 1
    });


    coins = new THREE.Mesh(new THREE.PlaneGeometry(2.5, .3, 1, 1), coinsMaterial);
    coins.position.set(0, controls.userHeight-.3, 2);
    coins.scale.set(.2,.2,.2)
    scene.add(coins);

    Reticulum.add( coins, {
                        clickCancelFuse: true, // Overrides global setting for fuse's clickCancelFuse
                        reticleHoverColor: 0x00fff6, // Overrides global reticle hover color
                        fuseVisible: true, // Overrides global fuse visibility
                        fuseDuration: 1.5, // Overrides global fuse duration
                        fuseColor: 0xcc0000, // Overrides global fuse color
                        onGazeOver: function(){
                            // do something when user targets object
                            //this.material.emissive.setHex( 0xffcc00 );
                            console.log('onGazeOver')
                        },
                        onGazeOut: function(){
                            // do something when user moves reticle off targeted object
                            //this.material.emissive.setHex( 0xcc0000 );
                            console.log('onGazeOut')
                        },
                        onGazeLong: function(){
                            // do something user targetes object for specific time
                          //  this.material.emissive.setHex( 0x0000cc );
                            console.log('onGazeLong')
                            //startGame();
                        },
                        onGazeClick: function(){
                            // have the object react when user clicks / taps on targeted object
                           // this.material.emissive.setHex( 0x0000cc );
                            console.log('onGazeClick')
                            startGame();
                        }
                    });

    TweenMax.to(coins.position, 1,{

        z:-1,
        delay: 1,
        ease:"Power3.easeOut",
        onUpdate:function(){
           // no_geom.verticesNeedUpdate = true;
            
      //  console.log('tweened');
    }});

    console.log(coins.material)

    TweenMax.to(coins.material, .2, {
            opacity: 0,
            delay: 2,
            repeat: 5,
            yoyo: true
    });

    TweenMax.to(coins.position, 1,{

        z:-1,
        delay: 1,
        ease:"Power3.easeOut",
        onUpdate:function(){
           // no_geom.verticesNeedUpdate = true;
            
      //  console.log('tweened');
    }});

        


    TweenMax.to(title.position, 1,{

        z:-2,

        ease:"Power3.easeOut",
        onUpdate:function(){
           // no_geom.verticesNeedUpdate = true;
            
      //  console.log('tweened');
    }});

    createLetter('V')
    createLetter('R')

    
}

function removeTitleScreen(){
    removeFromReticulum(coins);
    for (var n=0; n<letterArr.length;n++){
        scene.remove(letterArr[n])
    }
    scene.remove(title)
    scene.remove(coins)

}

function initPhysics() {

    // Physics configuration

    collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
    dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
    broadphase = new Ammo.btDbvtBroadphase();
    solver = new Ammo.btSequentialImpulseConstraintSolver();
    physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);
    physicsWorld.setGravity(new Ammo.btVector3(0, -gravityConstant, 0));

}

function addPlayer() {

    console.log('addPlayer')

    player = new Player(0, true);
    player.animate('fly');

/*
    pivot = new THREE.Object3D();
    pivot.position.set(0, controls.userHeight, 0);
  //  scene.add(pivot);
  */

    // createPlayer(playerTexture);

   // createPlayerHelper();
}

function Explosion(vector) {

    //var explosionTexture = new THREE.TextureLoader().load("img/explosion_sprite_small.png");
    var expSprite = new TextureAnimator(explosionTexture, 7, 1, 7, 75);
    expSprite.animBehavior = "loop";

  //  explosionblock = new THREE.Mesh(new THREE.BoxGeometry(.5, .5, .5, 1, 1, 1), createMaterial(0xff0000, true, 1, false));
    explosionblock = new THREE.Mesh(new THREE.BoxGeometry(.5, .5, .5, 1, 1, 1), invisibleMat);
    explosionblock.castShadow = true;
    explosionblock.receiveShadow = true;
    explosionblock.name = "explosion";


    var explosionMaterial = new THREE.SpriteMaterial({
        map: explosionTexture,
        color: 0xffffff
    });
     explosionMaterial.transparent = true;
    explosionMaterial.depthTest = true
    explosionMaterial.depthWrite = false
    explosionMaterial.polygonOffset = true
    explosionMaterial.polygonOffsetFactor = -4
    var explosion = new THREE.Sprite(explosionMaterial);


    // explosion.position.set(0,controls.userHeight,-5);
    explosion.scale.set(2.5, 2, 1.0); 
    explosionblock.position.copy(vector);
    scene.add(explosionblock);
    explosionblock.add(explosion)

    explosionArr.push(this);

    this.mesh = explosion;
    this.block = explosionblock;
    this.sprite = expSprite;
    this.start = 0;
    //  this.shadow = new Shadow(player.position);
    this.dist = Math.random() * 60;

    // this.flicker();

    this.update = function() {
      //  console.log('explosion update')

    }

    this.animate = function(state, loops) {
        // console.log('player animate')
        //this.tilesHorizontal =3;


    }

    this.flicker = function() {
        TweenMax.to(this.mesh.material, .1, {
            opacity: 0,
            delay: .4,
            repeat: 7,
            yoyo: true
        });
    }

    this.fadeOut = function() {
    //    console.log('fadeOut')
        var _this = this;
        TweenMax.to(this.mesh.material, .3, {
            opacity: 0,
            delay: .5,
            onComplete:function(){
                _this.destroy();
                        }
        });
    }


    this.destroy = function() {
       // console.log('destroy')
       // console.log(this)
        scene.remove(this.block);
        explosionArr.splice(this, 1);
        // console.log(enemyPool)

    }

    this.fadeOut();

}



function createPlayerHelper() {
    var r = 1;
    helper = new THREE.BoxHelper(new THREE.Mesh(new THREE.BoxGeometry(r, r, r)));
    helper.material.color.setHex(0x080808);
    helper.material.blending = THREE.AdditiveBlending;
    //helper.position.set(0, controls.userHeight, 0);
    helper.position.z = -1;
    helper.scale.set(.2, .2, .2);
    pivot.add(helper);

    if (debug == false) helper.visible = false;
}


function animate() {


    var deltaTime = clock.getDelta();


    //animate checkerboard texture
    uniforms.time.value = clock.getElapsedTime();

    if (!freeze){
        if (gameOn){
            hero.update(700 * deltaTime);
            //  if (annie) annie.update(700 * deltaTime);
            for (var n = 0; n < explosionArr.length; n++) {
               // console.log(explosionArr[n])
                explosionArr[n].sprite.update(700 * deltaTime);

            }

            for (var n = 0; n < enemyPool.length; n++) {
               // console.log(explosionArr[n])
               enemyPool[n].update();


            }

            playerFollow();

            


        }

        updatePhysics(deltaTime);

        controls.update(deltaTime);
    }

    if (pressTimer) {
        pressCounter++;
       // console.log(pressCounter)
        if (pressCounter > 200){
            resetGame();
            pressTimer=false;
        }
    }

    Reticulum.update();


    time += deltaTime;


    // Render the scene through the manager.
    manager.render(scene, camera);
   // effect.render(scene, camera);

   
    /*

        for (var i = 0; i < floor.length; i++) {

            ground = floor[i];

            // move it forward by a 10th of its array position each time 
            ground.position.z += 0.5;

            // once the star is too close, reset its z position
            if (ground.position.z > 400) ground.position.z -= 1600;
        }

    */

    stats.update();

    vrDisplay.requestAnimationFrame(animate);
}

function playerFollow() {
    var camDir = camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(1);
    var camVect = new THREE.Vector3(camDir.x, camDir.y, camDir.z);


    // get mouse position and add some accelerometer
    var vector;
    if (touchEnabled) {
        vector = new THREE.Vector3(-accYsmooth, accZsmooth, -1).unproject(camera);


    } else {

        vector = new THREE.Vector3(-mouse.x * 10, -mouse.y * 10, -1).unproject(camera);
        //  vector = new THREE.Vector3(-mouse.x * 10 - accYsmooth, -mouse.y * 10 + accZsmooth, -1).unproject(camera);
    }


    var direction = camVect.clone().sub(playerGroup.position).add(vector);

    var speed = 5;
    var xpos = direction.x * speed;
    var ypos = direction.y * speed;
    var zpos = direction.z * speed;


    playerBody.setLinearVelocity(new Ammo.btVector3(xpos, ypos, zpos));

}

function onResize(e) {
    effect.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

}



// Get the HMD, and if we're dealing with something that specifies
// stageParameters, rearrange the scene.
function setupStage() {

   console.log(navigator)


    navigator.getVRDisplays().then(function(displays) {



        if (displays.length > 0) {
            vrDisplay = displays[0];
            if (vrDisplay.stageParameters) {
                setStageDimensions(vrDisplay.stageParameters);
                if (forceVR && manager.isVRcompatible) {
                    manager.enterVRMode_();
                    console.log(manager)
                    alert('manager fire 2')
                }
            }
            vrDisplay.requestAnimationFrame(animate);
        }
        //   console.log(vrDisplay.orientation_);
        // window.addEventListener("devicemotion", function(event) 

        // is mobile? has accelerometer?
        //if(window.DeviceMotionEvent) { 
        //   var util = new Util;
        //    console.log(util.isMobile)
        // bad mobile detection
        if (window.innerWidth < 769) {
            manager.enterVRMode_()
            console.log('isDeviceMotion')
            alert('isDeviceMotion')


            window.addEventListener("devicemotion", function(event) {

                //accX = Math.round(event.accelerationIncludingGravity.x*10) / 10;  
                //accY = Math.round(event.accelerationIncludingGravity.y*10) / 10;  
                // accY = event.accelerationIncludingGravity.y;
                // if (manager.mode == 1){

                accZ = event.accelerationIncludingGravity.z;
                accY = event.accelerationIncludingGravity.y;
                accZsmooth = factor * accZsmooth + (1 - factor) * accZ;
                accYsmooth = factor * accYsmooth + (1 - factor) * accY;


                if (gameOn){
                    if (accZsmooth < -1) {
                            player.animate('run')
                        
                    } else {
                       // player.animate('fly');
                        if (accYsmooth < -.15) {
                             player.animate('right')
                         } else if (accYsmooth >.15) {
                             player.animate('left')
                         } else {
                             player.animate('fly')
                         }
                       
                      
                    }
                }

                //if VR mode
                if (manager.mode == 3) {
                    //  info.innerHTML += ' mode 1'
                    // info.innerHTML += ' player='+player.position;
                    //  ?????????????????????
                    //  accZsmooth =-7.75;
                    accYsmooth = accYsmooth*-1;


                    mouse.x = 0;
                    mouse.y = 0;

                }


                if (debug) {
                    info.innerHTML = 'accZ:' + accZ.toFixed(2) + ', accZsm:' + accZsmooth.toFixed(2) + ', accY:' + accYsmooth.toFixed(2);
                    info.innerHTML += ' mode:' + manager.mode;
                }

                

            }, true);



        }
    });

}


function setupPointer(){
   Reticulum.init(camera, {
        proximity: false,
        lockDistance: true,
        reticle: {
            visible: true,
            restPoint: -1, //Defines the reticle's resting point when no object has been targeted
            color: 0xcc0000,
            innerRadius: 0.021,
            outerRadius: 0.026,
            hover: {
                color: 0xcc0000,
                innerRadius: 0.06,
                outerRadius: 0.07,
                speed: 10,
                vibrate: 50 //Set to 0 or [] to disable
            }
        },
        fuse: {
            visible: false,
            duration: 2.5,
            color: 0x00fff6,
            innerRadius: 0.071,
            outerRadius: 0.081,
            vibrate: 0, //Set to 0 or [] to disable
            clickCancelFuse: false //If users clicks on targeted object fuse is canceled
        }
    });
}

function onDocumentKeyPress(event) {
    player.animate('run');
    var keyCode = event.which;
    console.log(keyCode)

    // press ''

    if (keyCode == 100) {

        if (debug == true) {
            setDebug(false);
        } else {
            setDebug(true);
        }

        event.preventDefault();

    }

}


function onDocumentMouseMove(event) {

    if (gameOn){
        event.preventDefault();

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;



        if (mouse.y > .3) {
            if (camera.rotation.x < 0.05 ){
                player.animate('run')
            }
        } else {
            player.animate('fly');
             if (mouse.x < -.4) {
                 player.animate('right')
             } else if (mouse.x > .4) {
                 player.animate('left')
             } else {
                 player.animate('fly')
             }
          
        }
        /*
            mouseCoords.set(
                (event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1
            );
        */

        if (debug) info.innerHTML = 'x:' + mouse.x.toFixed(2) + ', y:' + mouse.y.toFixed(2);

    }
}




function createLights() {
    var ambientLight = new THREE.AmbientLight(0x707070);
    scene.add(ambientLight);

    var light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(0, 18, 5);
    light.castShadow = true;
    var d = 14;
    light.shadow.camera.left = -d;
    light.shadow.camera.right = d;
    light.shadow.camera.top = d;
    light.shadow.camera.bottom = -d;

  //  light.shadow.bias = -0.000222;

    light.shadow.camera.near = 2;
    light.shadow.camera.far = 50;

    light.shadow.mapSize.x = 1024;
    light.shadow.mapSize.y = 1024;



    scene.add(light);
}

function createParalellepipedWithPhysics(sx, sy, sz, mass, pos, quat, material) {

    var object = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1), material);
    var shape = new Ammo.btBoxShape(new Ammo.btVector3(sx * 0.5, sy * 0.5, sz * 0.5));
    shape.setMargin(margin);


    var ballBody = createRigidBody(object, shape, mass, pos, quat);

    return object;

}


function createGround(){
    pos.set(0, -0.5, 0);
    quat.set(0, 0, 0, 1);
    var ground = createParalellepipedWithPhysics(100, 1, 100, 0, pos, quat, checkerTexture);
    ground.receiveShadow = true;
    ground.name = "ground";


    //var planeMaterial = new THREE.ShadowMaterial( { opacity: 0.1 } );
    var shadowMaterial = new THREE.ShadowMaterial( { color: 0xeeeeee } );
    shadowMaterial.opacity = 0.5;

  //  var plane = new THREE.Mesh( new THREE.PlaneGeometry(400, 400, 10, 10), createMaterial(0xffffff));
    var plane = new THREE.Mesh( new THREE.PlaneBufferGeometry(400, 400, 10, 10), shadowMaterial);
    plane.position.y = 0.1;
    plane.rotation.x = -Math.PI / 2;
    plane.receiveShadow = true;
    plane.name="shadowplane"
    scene.add( plane );
}

function createObjects() {
    

    var towerMass = 1000;
    var towerHalfExtents = new THREE.Vector3(2, 5, 2);
    pos.set(-3, 2, -10);
    quat.set(0, 0, 0, 1);
    //  createObject( towerMass, towerHalfExtents, pos, quat, createMaterial( 0xF0A024 ), 'tower' );

    var tower = createParalellepipedWithPhysics(2, 5, 2, towerMass, pos, quat, createMaterial());
    tower.receiveShadow = true;
    tower.castShadow = true;
    tower.name = "tower";

    addToReticulum(tower);



    pos.set(0, 1, -5);
    quat.set(0, 0, 0, 1);
    var brick = createParalellepipedWithPhysics(.6, .6, 1.2, 1000, pos, quat, createMaterial());


    brick.castShadow = true;
    brick.receiveShadow = true;
    brick.name = "brick";
    addToReticulum(brick);

    pos.set(Math.random()*4-2, Math.random()*10, Math.random()*10 - 5);
    quat.set(0, 0, 0, 1);
    var brick = createParalellepipedWithPhysics(.6, .6, 1.2, 1000, pos, quat, createMaterial());


    brick.castShadow = true;
    brick.receiveShadow = true;
    brick.name = "brick";
    addToReticulum(brick);


    createWall(0,0);
    createWall(-10, 20);
    
    
}

function createWall(xpos, zpos) {
    // Wall
    var brickMass = 100; //0.5;
    var brickLength = 1.2;
    var brickDepth = 0.6;
    var brickHeight = brickLength * 0.5;
    var numBricksLength = 6;
    var numBricksHeight = 8;
    var z0 = -10 - numBricksLength * brickLength * 0.5 +zpos;
    pos.set(3+xpos, brickHeight * 0.5, z0);
    quat.set(0, 0, 0, 1);
    for (var j = 0; j < numBricksHeight; j++) {

        var oddRow = (j % 2) == 1;

        pos.z = z0;

        if (oddRow) {
            pos.z -= 0.25 * brickLength;
        }

        var nRow = oddRow ? numBricksLength + 1 : numBricksLength;
        for (var i = 0; i < nRow; i++) {

            var brickLengthCurrent = brickLength;
            var brickMassCurrent = brickMass;
            if (oddRow && (i == 0 || i == nRow - 1)) {
                brickLengthCurrent *= 0.5;
                brickMassCurrent *= 0.5;
            }

            var brick = createParalellepipedWithPhysics(brickDepth, brickHeight, brickLengthCurrent, brickMassCurrent, pos, quat, createMaterial());


            brick.castShadow = true;
            brick.receiveShadow = true;
            brick.name = "brick";
            addToReticulum(brick);
            

            if (oddRow && (i == 0 || i == nRow - 2)) {
                pos.z += 0.75 * brickLength;
            } else {
                pos.z += brickLength;
            }

        }
        pos.y += brickHeight;
    }

}


function createEnemies() {

   // var ballMass = 30; //.35;
   // var ballRadius = 1; //0.4;

    for (var j = 0; j < 10; j++) {

        var enemy = new Enemy();
        
    }
}




function Player(xpos, sprite) {


    playerGroup = new THREE.Object3D();
    playerGroup.name = "player";


    //var playerTexture = new THREE.TextureLoader().load( "img/player_small_128.png" );
   // var playerTexture = new THREE.TextureLoader().load(img);
   // if (sprite) hero = new TextureAnimator(playerTexture, 4, 4, 3, 75);
    if (sprite) hero = new TextureAnimator(heroTexture, 4, 4, 3, 75);
    //annie = new TextureAnimator( playerTexture, 10, 1, 10, 75 ); // texture, #horiz, #vert, #total, duration.

    pos.set(0, controls.userHeight, -1);
    quat.set(0, 0, 0, 1);

    var playerMass = 2000;

    var sx = .25;
    var sy = .4;
    var sz = .25;

  //  playerblock = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1), createMaterial(0xff0000, true));
/*  var mat = new THREE.MeshPhongMaterial({
                      color: 0xffffff,
                      shading: THREE.FlatShading,
    side: THREE.BackSide,  
    wireframe: false,
     depthWrite: false,
    transparent: true,
    opacity: 0
});
*/
   // playerblock = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1), createMaterial(0xff0000, false,.5, true));
    playerblock = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1), invisibleMat);

    playerblock.castShadow = true;
  //  playerblock.receiveShadow = true;
 //   playerblock.name = "player";
   // playerblock.visibile = false;
    playerGroup.add(playerblock)

   // playerblock.visible = false;

    var playerMaterial = new THREE.SpriteMaterial({
        map: heroTexture,
        color: 0xffffff
    });
    /*
        var playerMaterial = new THREE.MeshBasicMaterial({
            map: playerTexture,
            side: THREE.DoubleSide,
            color: 0xffffff
        });
        */
    playerMaterial.transparent = true;


    // playerMaterial.map.offset = new THREE.Vector2(0.25 * 1, 0);
    // playerMaterial.map.repeat = new THREE.Vector2(1 / 4, 1);
    //fixes flicker when planes intersect
  //  playerMaterial.depthTest = true
  //  playerMaterial.depthWrite = false
  //  playerMaterial.polygonOffset = true
  //  playerMaterial.polygonOffsetFactor = -4
        /// end fix

    /// the actual character ////      
    // var playerGeometry = new THREE.PlaneGeometry(1, 1, 10, 10);
    //  var player = new THREE.Mesh(playerGeometry, playerMaterial);

    var player = new THREE.Sprite(playerMaterial);


    player.scale.set(.5, .5, 1.0); // imageWidth, imageHeight
   // player.scale.set(.25, .25, 1.0);
    playerGroup.add(player);

    var playerShape = new Ammo.btBoxShape(new Ammo.btVector3(sx * 0.5, sy * 0.5, sz * 0.5));
    playerShape.setMargin(margin);

    /* var playerShape = new Ammo.btSphereShape(playerRadius);
     playerShape.setMargin(margin);
     */

    playerBody = createRigidBody(playerGroup, playerShape, playerMass, pos, quat);
    playerBody.setFriction(0.9);

   // physicsBodies.push(playerBody);


  //  console.log(playerblock)
  //  console.log(playerblock.name)
  //  console.log(playerBody)




    /////////
    /*
      // playerblock = new THREE.Mesh(new THREE.SphereGeometry(playerRadius, 14, 10), ballMaterial);
        playerblock = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1), createMaterial(0xff0000, true));
        playerblock.castShadow = true;
        playerblock.receiveShadow = true;
        playerblock.name = "player";

        var playerMaterial = new THREE.SpriteMaterial({
            map: texture,
            color: 0xffffff
        });
        var player = new THREE.Sprite(playerMaterial);
        player.scale.set(.5, .5, 1.0); // imageWidth, imageHeight
        playerblock.add(player)
    */
    /////

    this.mesh = player;
    this.start = 0;
    //  this.shadow = new Shadow(player.position);
    this.dist = Math.random() * 60;

    this.update = function() {
     //   console.log('player update')

    }

    this.animate = function(state, loops) {
        // console.log('player animate')
        //this.tilesHorizontal =3;

       // console.log('state=' + state + ',pState=' + playerState)
        if (state != playerState) {
            hero.currentTile = 0;
            hero.numberOfTiles = 3;
           // console.error('state=' + state + ',pState=' + playerState)
            playerState = state;
            if (state == "fly") {
               // console.log("fly")

                hero.setFrame(0, 3, 'freeze');

            } else if (state == "left") {
              //  console.log("left")
                hero.setFrame(1, 3, 'freeze');

            } else if (state == "right") {
              //  console.log("right")
                hero.setFrame(2, 3, 'freeze');

            } else if (state == "run") {
              //  console.log("run")
                hero.setFrame(0, 2, 'loop');

            } else if (state == "fall") {
              // console.log("fall")
                hero.setFrame(0, 1, 'once');
                this.flicker();

            } else if (state == "die") {
              //+  console.log("die")
                    //this.tilesHorizontal =4;
                hero.numberOfTiles = 4;
                hero.setFrame(0, 0, 'once');
                this.flicker();

            }
        }
    }

    this.flicker = function() {
        TweenMax.to(this.mesh.material, .1, {
            opacity: 0,
            delay: .4,
            repeat: 7,
            yoyo: true
        });
    }





    /*
      this.update = function(){
            this.mesh.position.y = 80 + Math.sin(this.start)*40;
            this.mesh.position.z = Math.cos(this.start)*this.dist;
            this.shadow.update();
            this.start+=options.speed;


      }

      this.destroy = function(){
        console.log('destroy')
        this.shadow.destroy();
        scene.remove(this.mesh);
        //playerPool.splice(this, 1);
       // console.log(enemyPool)

      }
      */
}

function Enemy() {


   // var enemyTexture = new THREE.TextureLoader().load( "img/enemy.png" );
  //  var enemyTexture = new THREE.TextureLoader().load( "img/Space_Harrier_enemy_Mukadensu.png" );
    var px = Math.random() * 6 - 3;
    var py = controls.userHeight/2 + Math.random() * 2;
    var pz = Math.random()*20 -60
 
    pos.set(px, py, pz);
    quat.set(0, 0, 0, 1);

    var enemyMass = 10;

    var sx = .8;
    var sy = .6;
    var sz = .25;
/*
     var mat = new THREE.MeshBasicMaterial( { 
        color: 0xffff00, 
        side: THREE.BackSide,  
        wireframe: true,
        transparent: true,
       // depthWrite: false,
        opacity: 1
    });
    */

  //  enemyblock = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1), createMaterial(0xff0000, false, 1, true));
  //  enemyblock = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1), invisibleMat);
    var enemyRadius = .3;
    enemyblock =  new THREE.Mesh(new THREE.SphereGeometry(enemyRadius, 8, 8 ), invisibleMat);
    enemyblock.castShadow = true;
    enemyblock.receiveShadow = true;
    enemyblock.name = "enemy";
    enemyblock.userData.reticulumReady = true;

    Reticulum.add( enemyblock, {
       
        reticleHoverColor: 0xffcc00, // Overrides global reticle hover color
        fuseVisible: false, // Overrides global fuse visibility

    });

    var enemyMaterial = new THREE.SpriteMaterial({
        map: enemyTexture,
        color: 0xffffff
    });

    enemyMaterial.transparent = true;

    enemyMaterial.depthTest = true
    enemyMaterial.depthWrite = false
    enemyMaterial.polygonOffset = true
    enemyMaterial.polygonOffsetFactor = -4

    var enemy = new THREE.Sprite(enemyMaterial);

    enemy.scale.set(1, .5, 1.0); // imageWidth, imageHeight
    enemyblock.add(enemy);

    var enemyShape = new Ammo.btSphereShape(enemyRadius);
    enemyShape.setMargin(margin);

   // var enemyShape = new Ammo.btBoxShape(new Ammo.btVector3(sx * 0.5, sy * 0.5, sz * 0.5));
   // enemyShape.setMargin(margin);

    var enemyBody = createRigidBody(enemyblock, enemyShape, enemyMass, pos, quat);
    enemyBody.setFriction(0.9);

    var direction = new THREE.Vector3();
    direction.subVectors(new THREE.Vector3(0, 4, 0), pos).normalize();


    pos.copy(direction);
    pos.multiplyScalar(2 + Math.random()*3);
    enemyBody.setLinearVelocity(new Ammo.btVector3(0, 0, pos.z));

    enemyPool.push(this);


    this.mesh = enemy;
    this.block = enemyblock;
    this.body = enemyBody;
    this.start = 0;
    this.blastInt = Math.floor(Math.random()*enemyAttackRange)+500;



    this.dist = Math.random() * 60;

    this.update = function() {
        //console.log('enemy update: pos.z = '+ this.block.position.z)
        this.start++;
        if (this.start>this.blastInt && this.block.position.z<-5){
            this.start = 0;
            console.warn('shoot')
            this.shoot();
        }
     /*   var dur = (sec - this.born);
        var mod = (dur%5).toFixed(2)
        console.log(mod)
        if ((sec - this.born)%5 === 2){
            sec =0;
            console.warn('shoot')
        }
*/

        if (this.block.position.z>0){

                //////
          var tr = new Ammo.btTransform();
            tr.setOrigin(new Ammo.btVector3(Math.random() * 20 - 10, controls.userHeight, -60));
            this.body.setWorldTransform( tr ); 
        
            // apply your new transform to the rigid body //  
           // rigidBody->getMotionState()->setWorldTransform( tr ); 
          //  console.error('reset')
           // pos.set(0, controls.userHeight, -10);
           // this.body.position.copy(pos);
        }

    }

    this.animate = function(state, loops) {

        
    }

    this.shoot = function() {

        var direction = new THREE.Vector3();
        direction.subVectors(playerGroup.position, this.block.position).normalize();

        // Creates a ball and throws it
        var ballMass = 35;
        var ballRadius = 0.2;

        // var ball = new THREE.Mesh(new THREE.SphereGeometry(ballRadius, 14, 10), ballMaterial);
        //var ball = new THREE.Mesh(new THREE.SphereGeometry(ballRadius, 8, 8), createMaterial(0x33ffff));
        var ball = new THREE.Mesh(new THREE.SphereGeometry(ballRadius, 8, 8), invisibleMat);
        ball.castShadow = true;
       // ball.receiveShadow = true;
        ball.name = "laser";


        var blasterMaterial = new THREE.SpriteMaterial({
            map: enemyBlasterTexture,
            color: 0xffffff
        });
        // createBlaster();



        var blaster = new THREE.Sprite(blasterMaterial);
        blaster.scale.set(.5, .5, 1.0);
        ball.add(blaster)


        var ballShape = new Ammo.btSphereShape(ballRadius);
        ballShape.setMargin(margin);
        // pos.copy(raycaster.ray.direction);
        // pos.add(raycaster.ray.origin);

        pos.copy(direction);
        // pos.add(playerVector);
       // console.log(this.block.position)
        pos.add(this.block.position);


        quat.set(0, 0, 0, 1);
        var ballBody = createRigidBody(ball, ballShape, ballMass, pos, quat);

        pos.copy(direction);
        pos.multiplyScalar(10);
        //ballBody.setLinearVelocity(new Ammo.btVector3(0, 0, pos.z));
        ballBody.setLinearVelocity(new Ammo.btVector3(pos.x, pos.y, pos.z));

        playLaser();

        ///  playerblock.position.copy(pos)

/*
        // pos.copy(raycaster.ray.direction);
        pos.copy(direction);
        pos.multiplyScalar(24);
        ballBody.setLinearVelocity(new Ammo.btVector3(pos.x, pos.y, pos.z));
*/
    }

    this.flicker = function() {
        TweenMax.to(this.mesh.material, .1, {
            opacity: 0,
            delay: .4,
            repeat: 7,
            yoyo: true
        });
    }





    /*
      this.update = function(){
            this.mesh.position.y = 80 + Math.sin(this.start)*40;
            this.mesh.position.z = Math.cos(this.start)*this.dist;
            this.shadow.update();
            this.start+=options.speed;


      }

      this.destroy = function(){
        console.log('destroy')
        this.shadow.destroy();
        scene.remove(this.mesh);
        //playerPool.splice(this, 1);
       // console.log(enemyPool)

      }
      */
}

function createRigidBody(object, physicsShape, mass, pos, quat, vel, angVel) {

    if (pos) {
        object.position.copy(pos);
    } else {
        pos = object.position;
    }
    if (quat) {
        object.quaternion.copy(quat);
    } else {
        quat = object.quaternion;
    }

    var transform = new Ammo.btTransform();
    transform.setIdentity();
    transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
    transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
    var motionState = new Ammo.btDefaultMotionState(transform);


    //////

    var localInertia = new Ammo.btVector3(0, 0, 0);
    physicsShape.calculateLocalInertia(mass, localInertia);

    var rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, physicsShape, localInertia);
    var body = new Ammo.btRigidBody(rbInfo);


    body.setFriction(0.5);

    if (vel) {
        body.setLinearVelocity(new Ammo.btVector3(vel.x, vel.y, vel.z));
    }
    if (angVel) {
        body.setAngularVelocity(new Ammo.btVector3(angVel.x, angVel.y, angVel.z));
    }

    object.userData.physicsBody = body;
    object.userData.collided = false;


    scene.add(object);



    if (mass > 0) {
        rigidBodies.push(object);

        // Disable deactivation
        body.setActivationState(4);
    }

    var btVecUserData = new Ammo.btVector3(0, 0, 0);
    btVecUserData.threeObject = object;
    body.setUserPointer(btVecUserData);


    physicsWorld.addRigidBody(body);

    return body;
}

function createRandomColor() {
    return Math.floor(Math.random() * (1 << 24));
}

function createMaterial(color, wire= false, fade=1, vis=true) {
    color = color || createRandomColor();
    return new THREE.MeshPhongMaterial({
        color: color,
        wireframe: wire,
        transparent:true,
        opacity: fade,
        visible: vis

    });
}

function initInput() {

    
    document.addEventListener('mousemove', onDocumentMouseMove, false);

    document.addEventListener('keypress', onDocumentKeyPress, false);
    window.addEventListener('touchstart', shoot, false);
    window.addEventListener('mousedown', shoot, false);
    window.addEventListener('touchend', endCounter, false);
    window.addEventListener('mouseup', endCounter, false);


}

function endCounter(){
    pressTimer = false;
    pressCounter = 0;

}

function shoot(e) {
/*
    for (var n = 0; n < enemyPool.length; n++) {
           // console.log(explosionArr[n])
            enemyPool[n].shoot();


        }
*/
    
    if (gameOn){

        pressTimer = true;

       // console.log(pressCounter)
        // alert(e)
        //alert(e.type);
        if (e.type == "touchstart") touchEnabled = true;
        //  e.preventDefault();
        //  e.stopPropagation();

        // console.log(playerBody)

        var dir = Math.random() * 2 - 1;

        var bulletDir = camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(20);
        //  var camVect = new THREE.Vector3(bulletDir.x, controls.userHeight, bulletDir.z);
        var bulletVect = new THREE.Vector3(bulletDir.x, bulletDir.y + controls.userHeight, bulletDir.z);

        var direction = bulletVect.clone().sub(playerGroup.position).normalize();
        var length = direction.length();

        //  addArrowHelper(direction, length);

        // Creates a ball and throws it
        var ballMass = 35;
        var ballRadius = 0.2;

        // var ball = new THREE.Mesh(new THREE.SphereGeometry(ballRadius, 14, 10), ballMaterial);
      //  var ball = new THREE.Mesh(new THREE.SphereGeometry(ballRadius, 2, 2), createMaterial(0x33ffff, true, 1, false));
        var ball = new THREE.Mesh(new THREE.SphereGeometry(ballRadius, 2, 2), invisibleMat);
        ball.castShadow = true;
        ball.receiveShadow = true;
        ball.name = "bullet";


        var blasterMaterial = new THREE.SpriteMaterial({
            map: blasterTexture,
            color: 0xffffff
        });
        // createBlaster();


        var blaster = new THREE.Sprite(blasterMaterial);
        blaster.scale.set(.5, .5, 1.0);
        ball.add(blaster)


        var ballShape = new Ammo.btSphereShape(ballRadius);
        ballShape.setMargin(margin);
        // pos.copy(raycaster.ray.direction);
        // pos.add(raycaster.ray.origin);

        pos.copy(direction);
        // pos.add(playerVector);
        pos.add(playerGroup.position);


        quat.set(0, 0, 0, 1);
        var ballBody = createRigidBody(ball, ballShape, ballMass, pos, quat);

        ///  playerblock.position.copy(pos)


        // pos.copy(raycaster.ray.direction);
        pos.copy(direction);
        pos.multiplyScalar(24);
        ballBody.setLinearVelocity(new Ammo.btVector3(pos.x, pos.y, pos.z));

        playBang();
    } else{

        // quick fix game start on desktop, need raycaster
        if (window.innerWidth > 769){
            startGame();
        }
    }

}

function addArrowHelper(direction, length) {
    var arrowHelper = new THREE.ArrowHelper(direction, playerGroup.position, length, 0xff0000);


    arrowHelper.time = lastRender;
    arrowArr.push(arrowHelper);
    scene.add(arrowHelper);
}


function setDebug(bool) {
    debug = bool;
    if (debug == false) {
        info.innerHTML = null;
    }
}


function setStageDimensions(stage) {

    // Place the cube in the middle of the scene, at user height.
    player.position.set(0, controls.userHeight, -1);
}

function updatePhysics(deltaTime) {

    // Step world
    physicsWorld.stepSimulation(deltaTime, 10);

    // Update rigid bodies
    for (var i = 0, il = rigidBodies.length; i < il; i++) {
        var objThree = rigidBodies[i];
        var objPhys = objThree.userData.physicsBody;
        var ms = objPhys.getMotionState();
        //  console.log(objThree.name )
        if (ms) {

            ms.getWorldTransform(transformAux1);
            var p = transformAux1.getOrigin();
            var q = transformAux1.getRotation();
            objThree.position.set(p.x(), p.y(), p.z());
            objThree.quaternion.set(q.x(), q.y(), q.z(), q.w());

            objThree.userData.collided = false;

        }
        /*

                if (objThree.name == "player"){ 
                    console.log('player here')
                    objThree.position.set(p.x()+Math.Random()*4, p.y(), p.z());
                }

        */


    }



    for (var i = 0, il = dispatcher.getNumManifolds(); i < il; i++) {

        var contactManifold = dispatcher.getManifoldByIndexInternal(i);



        var rb0 = contactManifold.getBody0();
        var rb1 = contactManifold.getBody1();

        var threeObject0 = Ammo.castObject(rb0.getUserPointer(), Ammo.btVector3).threeObject;
        var threeObject1 = Ammo.castObject(rb1.getUserPointer(), Ammo.btVector3).threeObject;

        if (!threeObject0 && !threeObject1) {
            continue;
        }

        //  console.log('continuing')

        var userData0 = threeObject0 ? threeObject0.userData : null;
        var userData1 = threeObject1 ? threeObject1.userData : null;

        var breakable0 = userData0 ? userData0.breakable : false;
        var breakable1 = userData1 ? userData1.breakable : false;

        var collided0 = userData0 ? userData0.collided : false;
        var collided1 = userData1 ? userData1.collided : false;

        //if ( ( ! breakable0 && ! breakable1 ) || ( collided0 && collided1 ) ) {
        if (collided0 && collided1) {
            continue;
        }

        var contact = false;
        var maxImpulse = 0;
        for (var j = 0, jl = contactManifold.getNumContacts(); j < jl; j++) {
            var contactPoint = contactManifold.getContactPoint(j);
            if (contactPoint.getDistance() < 0) {
                contact = true;


                var impulse = contactPoint.getAppliedImpulse();
                if (impulse > maxImpulse) {
                    //console.log(contactPoint)
                    maxImpulse = impulse;
                    var pos = contactPoint.get_m_positionWorldOnB();
                    var normal = contactPoint.get_m_normalWorldOnB();
                    impactPoint.set(pos.x(), pos.y(), pos.z());
                    impactNormal.set(normal.x(), normal.y(), normal.z());
                }
                //console.log('break')
                break;
            }
        }

        // If no point has contact, abort
        if (!contact) {
            continue;
        }

        if (!collided0 && maxImpulse > 5) {

            //threeObject0.scale.set(.5,.5,.5)
            //  threeObject0.material = createMaterial()
            testCollisionRules(threeObject1, threeObject0)
            userData0.collided = true;
            //objectsToRemove[ numObjectsToRemove++ ] = threeObject0;
        }


    }

    for (var i = 0; i < numObjectsToRemove; i++) {
        console.log(objectsToRemove[i])

        removeDebris(objectsToRemove[i]);

    }
    numObjectsToRemove = 0;

}

function testCollisionRules(attacker, victim) {

    // console.log('break it')
    /*      //console.log(contactPoint)
    console.log(attacker.name + " hit " + victim.name);

    console.log(victim)
    console.log(attacker)
    console.log('----------')
*/
    if (attacker.name == "bullet") {
        console.warn(attacker.name + " hit " + victim.name);
        if (victim.name != "ground") {
            victim.material = createMaterial()
            objectsToRemove[numObjectsToRemove++] = victim;
            objectsToRemove[numObjectsToRemove++] = attacker;
            playExplode();
            // addExplosion(victim.position);
            var exp = new Explosion(victim.position);
        }

        objectsToRemove[numObjectsToRemove++] = attacker;
        score++;
        score_display.innerHTML = score;

    } else {
        console.log('not bullet: '+ attacker.name + " hit " + victim.name);
       
    }


    if (victim.name == "player" || attacker.name == "player") {

        
        if (attacker.name != "bullet" && victim.name != "tower" && victim.name != "brick") {
            console.error('OUCH!!!!!')
           // console.log(victim.name)
            console.log(attacker.name + " hit " + victim.name);
            console.log(victim.position)
            objectsToRemove[numObjectsToRemove++] = attacker;
            playArgh();
            player.animate('fall');
          //  freeze = true;
        }
    }

 //   attacker.material = createMaterial()


}



function removeDebris(object) {

   // console.log(object)

    scene.remove(object);
    console.log(object.userData)
    if (object.userData.reticulumReady) removeFromReticulum( object);

    physicsWorld.removeRigidBody(object.userData.physicsBody);

}
/*
function removePlayer() {

    //console.log(object)
    alert('removePlayer')

    scene.remove(playerblock);

    physicsWorld.removeRigidBody(playerBody);

}
*/


function TextureAnimator(texture, tilesHoriz, tilesVert, numTiles, tileDispDuration) {
    // note: texture passed by reference, will be updated by the update function.

    this.tilesHorizontal = tilesHoriz;
    this.tilesVertical = tilesVert;
    // how many images does this spritesheet contain?
    //  usually equals tilesHoriz * tilesVert, but not necessarily,
    //  if there at blank tiles at the bottom of the spritesheet. 
    this.numberOfTiles = numTiles;
    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(1 / this.tilesHorizontal, 1 / this.tilesVertical);



    // how long should each image be displayed?
    this.tileDisplayDuration = tileDispDuration;

    // how long has the current image been displayed?
    this.currentDisplayTime = 0;

    // which image is currently being displayed?
    this.currentTile = 0;

    this.animBehavior = false;
    /*
      this.setFrame = function( frame ){
        this.currentTile = frame;
        var currentColumn = this.currentTile % this.tilesHorizontal;
        texture.offset.x = currentColumn / this.tilesHorizontal;

      }
     */

    this.setFrame = function(xpos, ypos, state) {
        this.animBehavior = state;
        // console.log(xpos, ypos)
        var currentColumn = xpos % this.tilesHorizontal;
        texture.offset.x = currentColumn / this.tilesHorizontal;
        var currentRow = ypos % this.tilesVertical;
        //  console.log('currentRow =' + currentRow)
        texture.offset.y = currentRow / this.tilesVertical;

    }

    this.update = function(milliSec) {
        this.currentDisplayTime += milliSec;

        if (this.animBehavior == "once") {
            this.playOnce();
        } else if (this.animBehavior == "loop") {
            this.playLoop();
        }


    };

    this.playOnce = function() {
        while (this.currentDisplayTime > this.tileDisplayDuration) {
            this.currentDisplayTime -= this.tileDisplayDuration;
            if (this.currentTile < this.numberOfTiles - 1) {
                this.currentTile++;
                //   if (this.currentTile == this.numberOfTiles)
                //   this.currentTile = 0;
                var currentColumn = this.currentTile % this.tilesHorizontal;
                texture.offset.x = currentColumn / this.tilesHorizontal;
                //  var currentRow = Math.floor( this.currentTile / this.tilesHorizontal );
                // texture.offset.y = currentRow / this.tilesVertical;
            } else {
                //flash player
                //console.log(this.currentDisplayTime)
                // (Math.floor(this.currentDisplayTime)% 2 == 0)? this.opacity=.2 : this.opacity= 1;
            }
        }
    }

    this.playLoop = function() {
        while (this.currentDisplayTime > this.tileDisplayDuration) {

            this.currentDisplayTime -= this.tileDisplayDuration;
            this.currentTile++;
            if (this.currentTile == this.numberOfTiles)
                this.currentTile = 0;
            var currentColumn = this.currentTile % this.tilesHorizontal;
            texture.offset.x = currentColumn / this.tilesHorizontal;
            //  var currentRow = Math.floor( this.currentTile / this.tilesHorizontal );
            // texture.offset.y = currentRow / this.tilesVertical;
        }
    }



}

function loadFont() {

    var loader = new THREE.FontLoader();
    var typefile = 'fonts/' + fontName + '_' + fontWeight + '.typeface.json';
    console.log(typefile);
    loader.load( typefile, function ( response ) {

        font = response;

       // refreshText();

        //generateLetters();
       // createLetter('V')
       // createLetter('R')
        init();

    } );

}

function createLetter(letter, speed){
                console.log(letter)
                textGeo = new THREE.TextGeometry( letter, {

                    font: font,

                    size: size,
                    height: height,
                    curveSegments: curveSegments,

                    bevelThickness: bevelThickness,
                    bevelSize: bevelSize,
                    bevelEnabled: bevelEnabled,

                    material: 0,
                    extrudeMaterial: 1

                });

                textGeo.computeBoundingBox();
                textGeo.computeVertexNormals();


                var centerOffset = -0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );

              /*  textMesh1 = new THREE.Mesh( textGeo, materials );

                textMesh1.position.x = centerOffset;
               // textMesh1.position.y = hover+ height*8;
               // textMesh1.position.z = 0;

                textMesh1.rotation.x = 0;
                textMesh1.rotation.y = Math.PI * 2;
                */
                var xpos;
                if(letter=='R') {
                        xpos = .45; 
                    }else{
                        xpos=.1;
                    }

                var letter = new THREE.Mesh( textGeo, createMaterial( 0x333333 ) );
                letterArr.push(letter);
                letter.castShadow=true;

                scene.add(letter);

                    letter.position.x = Math.random()*4- 2;
                    letter.position.y = Math.random()*8 - 4;
                    letter.position.z = Math.random()*20;

                    letter.rotation.x = (Math.PI/180)*(Math.random()*180);
                    letter.rotation.y = (Math.PI/180)*(Math.random()*180);
                    letter.rotation.z = (Math.PI/180)*(Math.random()*180);

                    letter.scale.set(.005,.005,.005)

                    var dur;
                    if (speed){
                        dur = speed;
                    }else{
                        dur = 1+ Math.random()*10;
                    }
                    var delay = Math.random();
                    dur = 1;

                    

                    TweenMax.to(letter.position, dur,{
                       // z:depth,
                        x:xpos,
                        y:1.2,
                        z:-2,
                        delay: 1,//delay,
                        ease:"Power3.easeOut",
                        onUpdate:function(){
                           // no_geom.verticesNeedUpdate = true;
                            
                      //  console.log('tweened');
                    }});

                    TweenMax.to(letter.rotation, dur,{
                       // z:depth,
                        x:0,
                        y:0,
                        z:0,
                        delay: 1,//delay,
                        ease:"Power3.easeOut",
                        onUpdate:function(){
                           // no_geom.verticesNeedUpdate = true;
                            
                      //  console.log('tweened');
                    }});
                  
            }

function cleanupPhysics(){

     for (var i = 0; i < rigidBodies.length; i++) {

        removeDebris(rigidBodies[i]);

    }
    rigidBodies = [];
    
}
function addToReticulum(obj){

    obj.userData.reticulumReady = true;


    Reticulum.add( obj, {

        clickCancelFuse: true, // Overrides global setting for fuse's clickCancelFuse
        reticleHoverColor: 0x00fff6, // Overrides global reticle hover color
        fuseVisible: false, // Overrides global fuse visibility
        fuseDuration: 1.5, // Overrides global fuse duration
        fuseColor: 0xcc0000, // Overrides global fuse color
      /*  onGazeOver: function(){
            // do something when user targets object
            //this.material.emissive.setHex( 0xffcc00 );
            console.log('onGazeOver')
        },
        onGazeOut: function(){
            // do something when user moves reticle off targeted object
            //this.material.emissive.setHex( 0xcc0000 );
            console.log('onGazeOut')
        }
        */
    });

}

function removeFromReticulum(obj){
     Reticulum.remove( obj );
}

function startGame(){
    console.log('startGame')

    if (!gameSetupComplete){
    
        playCoin();
        addPlayer();
        createObjects();

        removeTitleScreen();
        gameSetupComplete = true;

        setTimeout(function(){

            playGetReady()
            //addPlayer();
            createEnemies();
            
           // console.error(Reticulum)
           // document.getElementById('intro').style.display = "none";
            
            
            gameOn = true;
        }, 2000);

    }
    
 

}

function resetGame(){
    gameSetupComplete = false;
    gameOn = false;
    freeze = false;
  //  console.log(rigidBodies.length)
    cleanupPhysics();
   // scene.remove(pivot);
   // camera.rotation.set(0,0,0)
   // document.getElementById('intro').style.display = "flex";
    createTitleScreen();
   // console.log(physicsWorld)
}



document.getElementById('reset').addEventListener('click', resetGame, false)

//
</script>

</html>
