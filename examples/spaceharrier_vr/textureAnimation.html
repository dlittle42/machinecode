
<!doctype html>
<html lang="en">
<head>
  <title>Texture Animation (Three.js)</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

</head>
<body>


<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>

<!--
  A polyfill for Promises. Needed for IE and Edge.
  -->
<script src="node_modules/es6-promise/dist/es6-promise.js"></script>

<!--
  three.js 3d library
  -->
<script src="node_modules/three/build/three.min.js"></script>

<script src="../../bower_components/three.js/examples/js/Detector.js"></script>
    <script src="../../bower_components/gsap/src/minified/TweenMax.min.js"></script>
    <script src="../../bower_components/three.js/examples/js/controls/OrbitControls.js"></script>
    <script src="../../bower_components/three.js/examples/js/libs/stats.min.js"></script>
    <script src="../../bower_components/dat.gui/dat.gui.js"></script>

 <script id="vertexShader" type="x-shader/x-vertex">
      varying vec2 vUv;
      uniform float time;
      uniform float speed;

      void main() {
        vUv = uv;

      //  float z = sin(time);

      //  vec3 newPosition = vec3(position.x,position.y,z);
     //   S.x += iGlobalTime*5.0; 

        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
      }
  </script>
  
  <script id="fragmentShader" type="x-shader/x-fragment">
      uniform vec3 color1;
      uniform vec3 color2;
      uniform float scale;
      uniform float time;
      varying vec2 vUv;



      void main() {

      //  vec2 st = gl_FragCoord.xy/vUv.xy;

        //vec2 translate = vec2(cos(u_time),sin(u_time));
        //st += translate*0.35;

       // color1 = vec3(st.x,st.y,0.0);
      //  color1 = vec3(st.x,st.y,0.0);

        vec2 center = -1.0 + 2.0 * vUv;
        vec2 uv = floor(center.xy * scale);

        
        if(mod(uv.x + uv.y, 2.0) > 0.5){
          //color1.x += time*5.0;
          gl_FragColor = vec4(color1, 1.0);
        }else{
          gl_FragColor = vec4(color2, 1.0);
        }
      }
  </script>

<script>
/*
  Three.js "tutorials by example"
  Author: Lee Stemkoski
  Date: July 2013 (three.js v59dev)
*/

// MAIN

// standard global variables
var container, scene, camera, renderer, controls, stats;
//var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();

// custom global variables
var annie, hero; // animators

var enemyPool=[];

var gui;

var player;

var options  = {
                

        speed            : 0.1,

        sprite_horizontal : 0,

       // segments         : 324,

        checker_color1     : '#76c876',

        checker_color2     : '#a7f9a7',

      //  scale            : 1,

      //  perlin_passes    : 1,

        numEnemies        : 10,

      //  floor_visible    : true

    };

// shader for checkerboard

var uniforms = {
      "time": {
          type: "f",
          value: 0.0
      },
      "color1" : {
        type : "c",
        value : new THREE.Color(0x76c876)
      },
      "color2" : {
        type : "c",
        value : new THREE.Color(0xa7f9a7)
      },
      "scale" : {
        type : "f",
        value : 5,
        min : 1, // only used for dat.gui, not needed for production
        max : 100 // only used for dat.gui, not needed for production
      },
    }
var vertexShader = document.getElementById('vertexShader').text;
var fragmentShader = document.getElementById('fragmentShader').text;
var checkerTexture = new THREE.ShaderMaterial(
        {
          uniforms : uniforms,
          vertexShader : vertexShader,
          fragmentShader : fragmentShader,
          side: THREE.DoubleSide
         // doubleSide: true,
        });

initGUI();
init();
animate();

// FUNCTIONS    
function init() 
{
  // SCENE
  scene = new THREE.Scene();
  scene.background = new THREE.Color( 0xbd8ef8 );
  // CAMERA
  var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
  var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
  camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
  scene.add(camera);
  camera.position.set(0,150,400);
  camera.lookAt(scene.position);  
  // RENDERER
  if ( Detector.webgl )
    renderer = new THREE.WebGLRenderer( {antialias:true} );
	//renderer = new THREE.WebGLRenderer({antialias: true, logarithmicDepthBuffer: true})
  else
    renderer = new THREE.CanvasRenderer(); 
  renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
  container = document.getElementById( 'ThreeJS' );
  container.appendChild( renderer.domElement );

  // CONTROLS
  controls = new THREE.OrbitControls( camera, renderer.domElement );
  // STATS
  stats = new Stats();
  stats.domElement.style.position = 'absolute';
  stats.domElement.style.bottom = '0px';
  stats.domElement.style.zIndex = 100;
  container.appendChild( stats.domElement );
  // LIGHT
  var light = new THREE.PointLight(0xffffff);
  light.position.set(0,250,0);
  scene.add(light);
  // FLOOR
  /*
  var floorTexture = new THREE.ImageUtils.loadTexture( 'img/checkerboard.jpg' );
  floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
  floorTexture.repeat.set( 10, 10 );
  var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
  */
  var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
 // var floor = new THREE.Mesh(floorGeometry, floorMaterial);

  var floor = new THREE.Mesh(floorGeometry,checkerTexture)
  floor.position.y = -0.5;
  floor.rotation.x = Math.PI / 2;
  scene.add(floor);
  // SKYBOX/FOG
  /*
  var skyBoxGeometry = new THREE.CubeGeometry( 10000, 10000, 10000 );
  var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0x9999ff, side: THREE.BackSide } );
  var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
   scene.add(skyBox);
   */
  scene.fog = new THREE.FogExp2( 0x9999ff, 0.00025 );
  
  ////////////
  // CUSTOM //
  ////////////
  
  // MESHES WITH ANIMATED TEXTURES!
  
  //var runnerTexture = new THREE.ImageUtils.loadTexture( 'img/explosion_sprite_small.png' );
  var explosionTexture = new THREE.TextureLoader().load( "img/explosion_sprite_small.png" );
   annie = new TextureAnimator( explosionTexture, 7, 1, 7, 75 );
  //annie = new TextureAnimator( explosionTexture, 10, 1, 10, 75 ); // texture, #horiz, #vert, #total, duration.
  var explosionMaterial = new THREE.MeshBasicMaterial( { map: explosionTexture, side:THREE.DoubleSide, color: 0xffffff } );
  explosionMaterial.transparent = true;
  explosionMaterial.depthTest= true
  explosionMaterial.depthWrite= false
	explosionMaterial.polygonOffset= true
	explosionMaterial.polygonOffsetFactor= -4
  var explosionGeometry = new THREE.PlaneGeometry(116, 78, 1, 1);
  var explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
  explosion.position.set(-100,40,0);
  scene.add(explosion);


  
  spawnEnemies(options.numEnemies);

  player = new Player("img/player_horizontal.png", 0, true);
  var player2 = new Player("img/Space_Harrier_player_sprite.png", 100 );

  
}

function Player(img, xpos, sprite){

	//var playerTexture = new THREE.TextureLoader().load( "img/player_small_128.png" );
	var playerTexture = new THREE.TextureLoader().load( img);
	if (sprite) hero = new TextureAnimator( playerTexture, 3, 1, 3, 75 );
  //annie = new TextureAnimator( playerTexture, 10, 1, 10, 75 ); // texture, #horiz, #vert, #total, duration.
  var playerMaterial = new THREE.MeshBasicMaterial( { map: playerTexture, side:THREE.DoubleSide, color: 0xffffff } );
  playerMaterial.transparent = true;
  //fixes flicker when planes intersect
  playerMaterial.depthTest= true
  playerMaterial.depthWrite= false
	playerMaterial.polygonOffset= true
	playerMaterial.polygonOffsetFactor= -4
	/// end fix
  var playerGeometry = new THREE.PlaneGeometry(40, 40, 10, 10);
  var player = new THREE.Mesh(playerGeometry, playerMaterial);
  player.position.set(xpos,40,0);
  scene.add(player);

  this.mesh = player;
  this.start=0;
  this.shadow = new Shadow(player.position);
  this.dist = Math.random()*60

  this.update = function(){
  		this.mesh.position.y = 80 + Math.sin(this.start)*40;
  		this.mesh.position.z = Math.cos(this.start)*this.dist;
  		this.shadow.update();
  		this.start+=options.speed;


  }

  this.destroy = function(){
  	console.log('destroy')
  	this.shadow.destroy();
  	scene.remove(this.mesh);
    //playerPool.splice(this, 1);
   // console.log(enemyPool)

  }
}

function spawnEnemies(num){
	for (var i=0; i<num; i++){
		var alien = new Enemy();
	}
}

function destroyAll(){
	console.log('destroyAll')
	for (var i=0; i<enemyPool.length; i++){
		console.log(enemyPool[i])
		enemyPool[i].destroy();

	}
	enemyPool=[];
}

function Enemy(){
  var enemyTexture = new THREE.TextureLoader().load( "img/enemy.png" );
  //annie = new TextureAnimator( enemyTexture, 10, 1, 10, 75 ); // texture, #horiz, #vert, #total, duration.
  var enemyMaterial = new THREE.MeshBasicMaterial( { map: enemyTexture, side:THREE.DoubleSide, color: 0xffffff } );
  enemyMaterial.transparent = true;
  //fixes flicker when planes intersect
  enemyMaterial.depthTest= true
  enemyMaterial.depthWrite= false
	enemyMaterial.polygonOffset= true
	enemyMaterial.polygonOffsetFactor= -4
	/// end fix
  var enemyGeometry = new THREE.PlaneGeometry(60, 40, 10, 10);
  var enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
  enemy.position.set((Math.random()*1000)-500,40,0);
  scene.add(enemy);

  this.mesh = enemy;
  enemyPool.push(this)
  this.start=0;
  this.shadow = new Shadow(enemy.position);
  this.dist = Math.random()*60

  this.update = function(){
  		this.mesh.position.y = 80 + Math.sin(this.start)*40;
  		this.mesh.position.z = Math.cos(this.start)*this.dist;
  		this.shadow.update();
  		this.start+=options.speed;


  }

  this.destroy = function(){
  	console.log('destroy')
  	this.shadow.destroy();
  	scene.remove(this.mesh);
    //enemyPool.splice(this, 1);
   // console.log(enemyPool)

  }

}

function Shadow(pos){

  var shadowTexture = new THREE.TextureLoader().load( "img/shadow.png" );
  //annie = new TextureAnimator( shadowTexture, 10, 1, 10, 75 ); // texture, #horiz, #vert, #total, duration.
  var shadowMaterial = new THREE.MeshBasicMaterial( { map: shadowTexture, side:THREE.DoubleSide, color: 0xffffff, opacity: 0.5, transparent: true } );

  var shadowGeometry = new THREE.PlaneGeometry(20, 20, 1, 1);
  var shadow = new THREE.Mesh(shadowGeometry, shadowMaterial);
  shadow.position.set(pos.x,0,0);
  shadow.rotation.x = Math.PI / 2;
  scene.add(shadow);

  this.mesh = shadow;

  this.update = function(){
  		this.mesh.position.x = pos.x;
  		this.mesh.position.z = pos.z;
  		var shadowScale = 1 + (40/pos.y);
  		this.mesh.scale.set( shadowScale, shadowScale, 1.0 )
  


  }

  this.destroy = function(){
  	scene.remove(this.mesh);

  }

}

function animate() 
{
    requestAnimationFrame( animate );
  render();   
  update();
}

function update()
{
  var delta = clock.getDelta(); 

  annie.update(700 * delta);

  for (var i=0; i<enemyPool.length; i++){
  	var nEnemy = enemyPool[i];
  	nEnemy.update();
  }

  
  controls.update();
  stats.update();
}

function render() 
{
  renderer.render( scene, camera );
}

function TextureAnimator(texture, tilesHoriz, tilesVert, numTiles, tileDispDuration) 
{ 
  // note: texture passed by reference, will be updated by the update function.
    
  this.tilesHorizontal = tilesHoriz;
  this.tilesVertical = tilesVert;
  // how many images does this spritesheet contain?
  //  usually equals tilesHoriz * tilesVert, but not necessarily,
  //  if there at blank tiles at the bottom of the spritesheet. 
  this.numberOfTiles = numTiles;
  texture.wrapS = texture.wrapT = THREE.RepeatWrapping; 
  texture.repeat.set( 1 / this.tilesHorizontal, 1 / this.tilesVertical );

  // how long should each image be displayed?
  this.tileDisplayDuration = tileDispDuration;

  // how long has the current image been displayed?
  this.currentDisplayTime = 0;

  // which image is currently being displayed?
  this.currentTile = 0;

  this.setFrame = function( frame ){
  	this.currentTile = frame;
    var currentColumn = this.currentTile % this.tilesHorizontal;
    texture.offset.x = currentColumn / this.tilesHorizontal;

  }
    
  this.update = function( milliSec )
  {
    this.currentDisplayTime += milliSec;
    while (this.currentDisplayTime > this.tileDisplayDuration)
    {
      this.currentDisplayTime -= this.tileDisplayDuration;
      this.currentTile++;
      if (this.currentTile == this.numberOfTiles)
        this.currentTile = 0;
      var currentColumn = this.currentTile % this.tilesHorizontal;
      texture.offset.x = currentColumn / this.tilesHorizontal;
      var currentRow = Math.floor( this.currentTile / this.tilesHorizontal );
      texture.offset.y = currentRow / this.tilesVertical;
    }
  };
}   

function initGUI() {

    gui = new dat.GUI();

    gui.values = {};

    gui.values.speed            = gui.add(options,'speed',0,1).step(0.1);

    gui.values.sprite_horizontal  = gui.add(options,'sprite_horizontal',0,2).step(1);

   // gui.values.scale            = gui.add(options,'scale',1,100).step(1.0);

    gui.values.numEnemies         = gui.add(options,'numEnemies',0,40).step(1);


    gui.values.checker_color1     = gui.addColor(options,'checker_color1');

    gui.values.checker_color2     = gui.addColor(options,'checker_color2');



  //  gui.values.wireframe = gui.add(options, 'wireframe');

  //  gui.values.floor_visible = gui.add(options, 'floor_visible');


/*
    gui.values.elevation.onChange(value => {

        uniforms.elevation.value = value;

    }
    );


    gui.values.wireframe.onChange(value => {

        plane_material.wireframe = value;

    }
    );

    gui.values.floor_visible.onChange(value => {

        groundMaterial.visible = value;

    }
    );



    gui.values.noise_range.onChange(value => {

        uniforms.noise_range.value = value;

    }
    );
*/
    gui.values.speed.onChange(value => {

        options.speed.value = value;

    }
    );

    gui.values.sprite_horizontal.onChange(value => {
    	console.log('sprite change')
        options.sprite_horizontal.value = value;
        
        hero.setFrame(value);

      //  hero.update();
        console.log(hero)

    }
    );



    gui.values.checker_color1.onChange(value => {
        console.log('value');
        uniforms.color1.value = new THREE.Color(value);
    }
    );

    gui.values.checker_color2.onChange(value => {
        console.log('value');
        uniforms.color2.value = new THREE.Color(value);
    }
    );

    return gui.values.numEnemies.onFinishChange(value => {

    	console.log(value);

    	destroyAll();

    	spawnEnemies(value);

       // scene.remove(plane_mesh);

      //  buildPlanes(value);

      //  scene.add(plane_mesh);
    }
    );
}

</script>

</body>
</html>
