<!DOCTYPE html>
<html lang="en">

<head>
    <title>Space Harrier VR</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <style>
    body {
        width: 100%;
        height: 100%;
        background-color: #bd8ef8;
        color: #fff;
        margin: 0px;
        padding: 0;
        overflow: hidden;
    }
    
    #info {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 101;
    }
    
    #score {
        position: absolute;
        top: 50px;
        right: 10px;
        z-index: 102;
    }
    /*
* {cursor: none;}
*/
    </style>
</head>

<body>
    <div id='info'></div>
    <div id='score'></div>
</body>
<script id="vertexShader" type="x-shader/x-vertex">
    varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }
</script>
<script id="fragmentShader" type="x-shader/x-fragment">
    uniform vec3 color1; uniform vec3 color2; uniform float scale; varying vec2 vUv; void main() { vec2 center = -1.0 + 2.0 * vUv; vec2 uv = floor(center.xy * scale); if(mod(uv.x + uv.y, 2.0) > 0.5){ gl_FragColor = vec4(color1, 1.0); }else{ gl_FragColor = vec4(color2, 1.0); } }
</script>
<script>
/*
 * Debug parameters.
 */
WebVRConfig = {
    /**
     * webvr-polyfill configuration
     */

    // Forces availability of VR mode.
    // FORCE_ENABLE_VR: true, // Default: false.
    // Complementary filter coefficient. 0 for accelerometer, 1 for gyro.
    //K_FILTER: 0.98, // Default: 0.98.
    // How far into the future to predict during fast motion.
    //PREDICTION_TIME_S: 0.040, // Default: 0.040 (in seconds).
    // Flag to disable touch panner. In case you have your own touch controls
    // TOUCH_PANNER_DISABLED: true, // Default: false.
    // Enable yaw panning only, disabling roll and pitch. This can be useful for
    // panoramas with nothing interesting above or below.
    YAW_ONLY: false, // Default: false.
    // Enable the deprecated version of the API (navigator.getVRDevices).
    //ENABLE_DEPRECATED_API: true, // Default: false.
    // Scales the recommended buffer size reported by WebVR, which can improve
    // performance. Making this very small can lower the effective resolution of
    // your scene.
    BUFFER_SCALE: 1, // default: 1.0
    // Allow VRDisplay.submitFrame to change gl bindings, which is more
    // efficient if the application code will re-bind it's resources on the
    // next frame anyway.
    // Dirty bindings include: gl.FRAMEBUFFER_BINDING, gl.CURRENT_PROGRAM,
    // gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING,
    // and gl.TEXTURE_BINDING_2D for texture unit 0
    // Warning: enabling this might lead to rendering issues.
    //DIRTY_SUBMIT_FRAME_BINDINGS: true // default: false
};
</script>
<!--
  A polyfill for Promises. Needed for IE and Edge.
  -->
<script src="node_modules/es6-promise/dist/es6-promise.js"></script>
<!--
  three.js 3d library
  -->
<script src="node_modules/three/build/three.min.js"></script>
<script src="../../bower_components/three.js/examples/js/libs/ammo.js"></script>
<script src="../../bower_components/three.js/examples/js/Detector.js"></script>
<script src="../../bower_components/three.js/examples/js/libs/stats.min.js"></script>
<script src="../../bower_components/three.js/examples/js/ConvexObjectBreaker.js"></script>
<script src="../../bower_components/three.js/examples/js/QuickHull.js"></script>
<script src="../../bower_components/three.js/examples/js/geometries/ConvexGeometry.js"></script>
<!--
  VRControls.js acquires positional information from connected VR devices and applies the transformations to a three.js camera object.
   -->
<script src="node_modules/three/examples/js/controls/VRControls.js"></script>
<!--
<script src="node_modules/three/examples/js/controls/DeviceOrientationControls.js"></script>
-->
<!--
  VREffect.js handles stereo camera setup and rendering.
  -->
<script src="node_modules/three/examples/js/effects/VREffect.js"></script>
<!--
  A polyfill for WebVR using the Device{Motion,Orientation}Event API.
  -->
<script src="node_modules/webvr-polyfill/build/webvr-polyfill.js"></script>
<!--
  Helps enter and exit VR mode, provides best practices while in VR.
  -->
<script src="build/webvr-manager.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.19.0/TweenMax.min.js"></script>
<!--
<script src="build/threejs-texture-checkerboard.js"></script>
-->
<script src="node_modules/howler/dist/howler.min.js"></script>
<script>
var forceVR = false; //true;
var debug = false; //true;

var renderer, scene, camera, controls, effect, manager, loader, stats;
var playerblock, playerBody;
var pivot, player, player_sprite;
var mouse = new THREE.Vector2();
var uTime;
var helper;
var blasterArr = [];
var blasterSpeed = .3; //5;
var info = document.getElementById('info');
var touchEnabled = false;

var score_display = document.getElementById('score');
var score = 0;
var sound, getReady, explode, argh;

var textureLoader;
var clock = new THREE.Clock();
var playerVector = new THREE.Vector3();
var camVector = new THREE.Vector3();
var camDir = new THREE.Vector3();
var heroTexture;

var direction = new THREE.Vector3();

var mouseCoords = new THREE.Vector2();
var raycaster = new THREE.Raycaster();
var ballMaterial = new THREE.MeshPhongMaterial({
    color: 0x000000,
    wireframe: false,
    //transparent:true, opacity:0.5
});

var hemisphereLight, shadowLight;
var floorMaterial, floorPlane;
var floor = [];
var checkerTexture;
var xA = 0;
var yA = 0;
var accX = 0;
var accY = 0;
var accZ = 0;

// Physics variables
var gravityConstant = 0; //0.1; //7.8;
var collisionConfiguration;
var dispatcher;
var broadphase;
var solver;
var physicsWorld;
var margin = 0.05;

var convexBreaker = new THREE.ConvexObjectBreaker();

// Rigid bodies include all movable objects
var rigidBodies = [];

var pos = new THREE.Vector3();
var quat = new THREE.Quaternion();
var transformAux1 = new Ammo.btTransform();
var tempBtVec3_1 = new Ammo.btVector3(0, 0, 0);

var time = 0;

var objectsToRemove = [];
for (var i = 0; i < 500; i++) {
    objectsToRemove[i] = null;
}
var numObjectsToRemove = 0;

var impactPoint = new THREE.Vector3();
var impactNormal = new THREE.Vector3();

// Request animation frame loop function
var lastRender = 0;

var vrDisplay;

var accZsmooth = 0;
var accYsmooth = 0;
var factor = .98;

var _v3 = new THREE.Vector3;


var Colors = {
    red: 0xf25346,
    white: 0xd8d0d1,
    brown: 0x59332e,
    pink: 0xF5986E,
    brownDark: 0x23190f,
    blue: 0x68c3c0,
};

// shader for checkerboard

var uniforms = {
    "color1": {
        type: "c",
        value: new THREE.Color(0x76c876)
    },
    "color2": {
        type: "c",
        value: new THREE.Color(0xa7f9a7)
    },
    "scale": {
        type: "f",
        value: 80,
        min: 1, // only used for dat.gui, not needed for production
        max: 100 // only used for dat.gui, not needed for production
    },
}
var vertexShader = document.getElementById('vertexShader').text;
var fragmentShader = document.getElementById('fragmentShader').text;
var checkerTexture = new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: vertexShader,
    fragmentShader: fragmentShader,
    side: THREE.DoubleSide
        // doubleSide: true,
});



// custom global variables
var annie, hero; // animators
var volume = 0.4;

function loadSound() {
    sound = new Howl({
        src: ['../_audio/boing.mp3'],
        volume: volume
    });
    sound.play();

}

function playSound() {
    sound.play();
}

function loadGetReady() {

    getReady = new Howl({
        src: ['audio/ready.mp3'],
        volume: volume
    });
    getReady.play();

}

function playGetReady() {
    getReady.play();
}


function loadExplode() {

    explode = new Howl({
        src: ['audio/explode.mp3'],
        volume: volume
    });
    //explode.play();

}

function playExplode() {
    explode.play();
}

function loadArgh() {

    argh = new Howl({
        src: ['audio/sharrierAAArg.mp3'],
        volume: volume
    });
    //explode.play();

}


function playArgh() {
    argh.play();
}

function muteAll() {
    howler.mute();
}


function init() {

    setDebug(true)

    // Setup three.js WebGL renderer. Note: Antialiasing is a big performance hit.
    // Only enable it if you actually need to.
    /*renderer = new THREE.WebGLRenderer({
        antialias: false
    });*/
    renderer = new THREE.WebGLRenderer({
        antialias: true,
        precision: "mediump"
    });
    renderer.setClearColor(0xffff00);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;

    // Append the canvas element created by the renderer to document body element.
    document.body.appendChild(renderer.domElement);

    // Create a three.js scene.
    scene = new THREE.Scene();

    scene.background = new THREE.Color(0xbd8ef8);



    // Create a three.js camera.
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
    //var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 100);

    controls = new THREE.VRControls(camera);
    controls.standing = true;
    controls.standing = true;

    // Apply VR stereo rendering to renderer.
    effect = new THREE.VREffect(renderer);
    effect.setSize(window.innerWidth, window.innerHeight);

    // Create a VR manager helper to enter and exit VR mode.
    var params = {
        hideButton: false, // Default: false.
        isUndistorted: false // Default: false.
    };
    manager = new WebVRManager(renderer, effect, params);



    loader = new THREE.TextureLoader();
    //setPlayerTexture calls setupStage which triggers animate
    loader.load('img/Space_Harrier_player_sprite.png', setPlayerTexture);

    var loader2 = new THREE.TextureLoader();
    loader2.load('img/blaster.png', function(texture) {
        blasterMaterial = new THREE.SpriteMaterial({
            map: texture,
            color: 0xffffff
        });
        // createBlaster();

        // needs a delay??
        if (forceVR && manager.isVRCompatible) {
            manager.enterVRMode_();
            console.log(manager)
        }

    });
    /*
        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        renderer.domElement.appendChild(stats.domElement);
    */
    //  createLights();

    createLights2();
    // setupGround();
    /*
        //var runnerTexture = new THREE.ImageUtils.loadTexture( 'img/explosion_sprite_small.png' );
      var explosionTexture = new THREE.TextureLoader().load( "img/explosion_sprite_small.png" );
      annie = new TextureAnimator( explosionTexture, 7, 1, 7, 75 );
      annie.animBehavior = "loop";
      //annie = new TextureAnimator( explosionTexture, 10, 1, 10, 75 ); // texture, #horiz, #vert, #total, duration.
      var explosionMaterial = new THREE.MeshBasicMaterial( { map: explosionTexture, side:THREE.DoubleSide, color: 0xffffff } );
      explosionMaterial.transparent = true;
      explosionMaterial.depthTest= true
      explosionMaterial.depthWrite= false
      explosionMaterial.polygonOffset= true
      explosionMaterial.polygonOffsetFactor= -4
      var explosionGeometry = new THREE.PlaneGeometry(116, 78, 1, 1);
      var explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
      explosion.position.set(-100,40,0);
      scene.add(explosion);
    */
    window.addEventListener('resize', onResize, true);
    window.addEventListener('vrdisplaypresentchange', onResize, true);
    document.addEventListener('mousemove', onDocumentMouseMove, false);

    //  window.addEventListener('orientationchange', doOnOrientationChange);
    //  document.addEventListener('click', createBlaster, true);
    // document.addEventListener('touchstart', createBlaster, true);

}

function initPhysics() {

    // Physics configuration

    collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
    dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
    broadphase = new Ammo.btDbvtBroadphase();
    solver = new Ammo.btSequentialImpulseConstraintSolver();
    physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);
    physicsWorld.setGravity(new Ammo.btVector3(0, -gravityConstant, 0));

}



function setPlayerTexture(playerTexture) {
    //var playerTexture = THREE.ImageUtils.loadTexture( 'img/Space_Harrier_player_sprite.png' );
    /*  var playerMaterial = new THREE.SpriteMaterial({
        map: playerTexture,
        color: 0xffffff
    });
    player = new THREE.Sprite(playerMaterial);


    //player.position.set(0, controls.userHeight, -1);
    player.position.z = -1;

    player.scale.set(.5, .5, 1.0); // imageWidth, imageHeight
*/
    heroTexture = playerTexture;

    pivot = new THREE.Object3D();
    pivot.position.set(0, controls.userHeight, 0);
    scene.add(pivot);
    //  pivot.add(player);
    /*
        var mass = 0;
      //  var towerHalfExtents = new THREE.Vector3(1, 1, 1);
        pos.set(0, controls.userHeight, -1);
        quat.set(0, 0, 0, 1);
        //  createObject( towerMass, towerHalfExtents, pos, quat, createMaterial( 0xF0A024 ), 'tower' );

        playerblock = createParalellepipedWithPhysics(.2, .2, .2, mass, pos, quat, createMaterial(0xffff00));
        playerblock.receiveShadow = true;
        playerblock.castShadow = true;
        playerblock.name = "player";
    */
    createPlayer(playerTexture);

    var r = 1;
    helper = new THREE.BoxHelper(new THREE.Mesh(new THREE.BoxGeometry(r, r, r)));
    helper.material.color.setHex(0x080808);
    helper.material.blending = THREE.AdditiveBlending;
    //helper.position.set(0, controls.userHeight, 0);
    helper.position.z = -1;
    helper.scale.set(.2, .2, .2);
    pivot.add(helper);

    if (debug == false) helper.visible = false;
    // position the object on the pivot, so that it appears 5 meters 
    // in front of the user.

    //controlPlayer(0,0);


    //scene.add( player );

    setupStage();

}


function animate() {
    /*
        
        var delta = Math.min(timestamp - lastRender, 500);
        lastRender = timestamp;
        //uTime = timestamp;

        // Apply rotation to cube mesh
        // cube.rotation.y += delta * 0.0006;

        controls.update();
    */


    var deltaTime = clock.getDelta();

    updatePhysics(deltaTime);

    controls.update(deltaTime);

    //renderer.render( scene, camera );

    //   playerVector.setFromMatrixPosition( player.matrixWorld );

    time += deltaTime;


    // Render the scene through the manager.
    manager.render(scene, camera);
    effect.render(scene, camera);


    //player.position.set(0, controls.userHeight, -1);
    // pivot.rotation.y = camera.rotation.y;
    //console.log(camera.rotation.y)
    /*
    playerVector.setFromMatrixPosition(player.matrixWorld);

    var camDir = camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(1);
    //  var camVect = new THREE.Vector3(camDir.x, controls.userHeight, camDir.z);
    var camVect = new THREE.Vector3(camDir.x, camDir.y, camDir.z);

    var direction = camVect.clone().sub(playerVector);

    
    pos.copy(direction);
    pos.add(playerVector);
    playerblock.position.copy(pos)
    console.log(playerblock.position)
    */



    // console.log(mouseCoords)
    // console.log(playerblock.position)

    // _v3.copy(mouse);
    /*
        var camDir = camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(1);
        //  var camVect = new THREE.Vector3(camDir.x, controls.userHeight, camDir.z);
        var camVect = new THREE.Vector3(camDir.x, camDir.y, camDir.z);

        //_v3.copy(mouse)
        // _v3.copy(mouse).sub(playerblock.position).multiplyScalar(.5);
        var vector = new THREE.Vector3(-mouse.x * 10, -mouse.y * 10, -1).unproject(camera);

        var direction = camVect.clone().sub(playerblock.position).add(vector);




        // _v3.copy(mouse).sub(playerblock.position).multiplyScalar(.5);
        // _v3.y = 0;



       
        //   var xpos = pivot.position.x - playerblock.position.x;
        //   var ypos = pivot.position.y - playerblock.position.y;
        //   var zpos = pivot.position.z - playerblock.position.z - 1;
       
        var speed = 5;
        var xpos = direction.x * speed;
        var ypos = direction.y * speed;
        var zpos = direction.z * speed;


        //  var xpos = mouse.x - playerblock.position.x;
        //  var ypos = controls.userHeight + mouse.y - playerblock.position.y;

        //console.log(_v3)
        //  playerBody.setLinearVelocity(new Ammo.btVector3(xpos*5,ypos*5,0));
        //// // playerBody.setLinearVelocity(new Ammo.btVector3(xpos*5,ypos*5,zpos*5));
        playerBody.setLinearVelocity(new Ammo.btVector3(xpos, ypos, zpos));

        console.log(playerblock.position)
        */

    playerFollow();

    pivot.rotation.copy(camera.rotation);
    pivot.updateMatrix();

    /*
        _v3.copy(mouseCoords).sub(playerblock.position).multiplyScalar(5);
        _v3.y = 0;
        playerBody.setLinearVelocity(_v3);
        */

    /*
        playerblock.rotation.copy(camera.rotation);
        playerblock.updateMatrix();
    */
    /*

        for (var i = 0; i < floor.length; i++) {

            ground = floor[i];

            // move it forward by a 10th of its array position each time 
            ground.position.z += 0.5;

            // once the star is too close, reset its z position
            if (ground.position.z > 400) ground.position.z -= 1600;
        }
        // console.log(camera.rotation)
        var camDir = camera.getWorldDirection();

        for (var i = 0; i < blasterArr.length; i++) {
            blasterArr[i].position.x += camDir.x * blasterSpeed;
            blasterArr[i].position.y += camDir.y * blasterSpeed;
            blasterArr[i].position.z += camDir.z * blasterSpeed;
            if (timestamp - blasterArr[i].time > 1000) {
                scene.remove(blasterArr[i]);
                blasterArr.splice(i, 1);
            }

        }
    */
    //  player.position.x = xA;
    //  player.position.y = yA;

    // stats.update();


    vrDisplay.requestAnimationFrame(animate);
}

function playerFollow() {
    var camDir = camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(1);
    var camVect = new THREE.Vector3(camDir.x, camDir.y, camDir.z);


    // get mouse position and add some accelerometer
    //  console.log(-mouse.x * 10)
    var vector;
    if (touchEnabled) {
        vector = new THREE.Vector3(-mouse.x * 10 - accYsmooth, -mouse.y * 10 + accZsmooth, -1).unproject(camera);
    } else {
        vector = new THREE.Vector3(-accYsmooth, accZsmooth, -1).unproject(camera);
    }


    var direction = camVect.clone().sub(playerblock.position).add(vector);

    var speed = 5;
    var xpos = direction.x * speed;
    var ypos = direction.y * speed;
    var zpos = direction.z * speed;


    playerBody.setLinearVelocity(new Ammo.btVector3(xpos, ypos, zpos));

    // console.log(playerblock.position)
}

function onResize(e) {
    effect.setSize(window.innerWidth, window.innerHeight);
    //  camDir = new THREE.Vector3(0,0,-1);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
 /*   var dir = playerblock.position; //camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(1);
    // playerblock.position.set(0,0,-1);
    var str = JSON.stringify(dir); //, null, 4)
    console.log(str);
    score_display.innerHTML = str;
*/
    // removePlayer();
    // createPlayer(heroTexture);
    // alert(str)
}



// Get the HMD, and if we're dealing with something that specifies
// stageParameters, rearrange the scene.
function setupStage() {
    navigator.getVRDisplays().then(function(displays) {
        if (displays.length > 0) {
            vrDisplay = displays[0];
            if (vrDisplay.stageParameters) {
                setStageDimensions(vrDisplay.stageParameters);
                if (forceVR && manager.isVRcompatible) {
                    manager.enterVRMode_();
                    console.log(manager)
                }
            }
            vrDisplay.requestAnimationFrame(animate);
        }
        //   console.log(vrDisplay.orientation_);
        // window.addEventListener("devicemotion", function(event) 

        // is mobile? has accelerometer?
        //if(window.DeviceMotionEvent) { 
        //   var util = new Util;
        //    console.log(util.isMobile)
        // bad mobile detection
        if (window.innerWidth < 769) {
            console.log('isDeviceMotion')

            window.addEventListener("devicemotion", function(event) {

                //accX = Math.round(event.accelerationIncludingGravity.x*10) / 10;  
                //accY = Math.round(event.accelerationIncludingGravity.y*10) / 10;  
                // accY = event.accelerationIncludingGravity.y;
                // if (manager.mode == 1){

                accZ = event.accelerationIncludingGravity.z;
                accY = event.accelerationIncludingGravity.y;
                accZsmooth = factor * accZsmooth + (1 - factor) * accZ;
                accYsmooth = factor * accYsmooth + (1 - factor) * accY;



                movement = 2;

                if (manager.mode == 1) {
                    //  info.innerHTML += ' mode 1'
                    xA = -accYsmooth * movement;
                    yA = -accZsmooth * .4; // *movement;
                } else {
                    // info.innerHTML += ' player='+player.position;
                    //  ?????????????????????
                    //  accZsmooth =-7.75;
                    //  accYsmooth =-7.75;
                    mouse.x = 0;
                    mouse.y = 0;


                    yA = accZsmooth * .75; // *movement;
                    xA = -accYsmooth * .5
                }


                if (debug) {
                    info.innerHTML = 'accZ:' + accZ.toFixed(2) + ', accZsm:' + accZsmooth.toFixed(2) + ', accY:' + accYsmooth.toFixed(2);
                    info.innerHTML += ' mode:' + manager.mode + ',compat:' + manager.isVRcompatible;
                }

                /*   }else{
                     xA = 0;
                     yA = 0;
                     player.position.set(0,0,-2)

                   }
                   */

                //run();
            }, true);



        }
    });

}
/*
function doOnOrientationChange() {
    switch(window.orientation) {  
      case -90 || 90:
        alert('landscape');
        break; 
      default:
        alert('portrait');
        break; 
    }
}
  
*/


function onDocumentMouseMove(event) {

    event.preventDefault();

    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    /*
        mouseCoords.set(
            (event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1
        );
        */

    if (debug) info.innerHTML = 'x:' + mouse.x.toFixed(2) + ', y:' + mouse.y.toFixed(2);
    //   if (debug) info.innerHTML = 'x:' + mouseCoords.x.toFixed(2) + ', y:' + mouseCoords.y.toFixed(2);

    //controlPlayer(-mouse.x.toFixed(2)*10)
    // controlPlayer(mouse.x, mouse.y / 2)

}

function controlPlayer(xAcc, yAcc) {

    // accX = (xAcc*10) / 10;  
    // accY = (yAcc*10) / 10;  

    accX = xAcc;
    accY = yAcc;

    movement = 10;

    xA = -(accX / 10) * movement;
    yA = -(accY / 10) * movement;


}


/*

function createBlaster(event) {

    var geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
    var material = new THREE.MeshNormalMaterial();
    //blaster = new THREE.Mesh(geometry, material);



    if (manager.mode == 3) event.preventDefault();


    blaster = new THREE.Sprite(blasterMaterial);

    blaster.scale.set(.2, .2, 1.0);
    blaster.time = lastRender;

    //var distVector = playerVector.multiplyScalar(2);


    //projector.unprojectVector( vector, camera );
    //blaster.raycaster = new THREE.Raycaster(new THREE.Vector3(playerVector.x, playerVector.y, playerVector.z), new THREE.Vector3(distVector.x, playerVector.y, distVector.z));

    //var camDir = camera.getWorldDirection();
    //  var scaleCam = camDir.multiplyScalar(1.1);

    // blaster.position.set(player.position.x, controls.userHeight + player.position.y, player.position.z - .1);


    blaster.position.set(playerVector.x, playerVector.y, playerVector.z);

    // blaster.position.set(playerblock.position.x, playerblock.position.y, playerbock.position.z);
    scene.add(blaster);

    // blasterArr.push(blaster);

    //   var camVector = new THREE.Vector3();

    var bulletDir = camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(20);
    var bulletVect = new THREE.Vector3(bulletDir.x, controls.userHeight, bulletDir.z);

    var direction = bulletVect.clone().sub(blaster.position);
    var length = direction.length();
    var arrowHelper = new THREE.ArrowHelper(direction.normalize(), blaster.position, length, 0xff0000);


    arrowHelper.time = lastRender;
    scene.add(arrowHelper);

    // arrowArr.push(arrowHelper);




    playSound();

}
*/


function setupGround() {

    loader.load('img/checkerboard.jpg', function(texture) {
        var floorTexture = texture;
        floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
        floorTexture.repeat.set(10, 10);
        var floorMaterial = new THREE.MeshBasicMaterial({
            map: floorTexture,
            side: THREE.DoubleSide
        });
        addGround(floorMaterial);
    });






}


function addGround(floorMaterial) {

    //create the ground material using MeshLambert Material
    //   var groundMat = new THREE.MeshLambertMaterial( {color: 0xffffff, side: THREE.DoubleSide}  );
    //create the plane geometry
    var geometry = new THREE.PlaneGeometry(400, 800, 300, 300);
    // var geometry = new THREE.BoxGeometry(400, 10, 800);

    //create the ground form the geometry and material


    for (var z = -1600; z < 1600; z += 800) {


        /*  //make the terrain bumpy
          for (var i = 0, l = geometry.vertices.length; i < l; i++) {
            var vertex = geometry.vertices[i];
            var value = pn.noise(vertex.x / 10, vertex.y /10, 0);
            vertex.z = value *6;
          }
          //ensure light is computed correctly
          geometry.computeFaceNormals();
          geometry.computeVertexNormals();
        */


        //   var ground = new THREE.Mesh(geometry,groundMat); 

        //  var ground = new THREE.Mesh(geometry,floorMaterial); 
        var ground = new THREE.Mesh(geometry, checkerTexture);
        //rotate 90 degrees around the xaxis so we can see the terrain 
        ground.rotation.x = -Math.PI / -2;
        // Then set the z position to where it is in the loop (distance of camera)
        ground.position.z = z;


        //add the ground to the scene
        scene.add(ground);
        //finally push it to the stars array 
        floor.push(ground);
    }



}


function createLights() {
    // A hemisphere light is a gradient colored light; 
    // the first parameter is the sky color, the second parameter is the ground color, 
    // the third parameter is the intensity of the light
    hemisphereLight = new THREE.HemisphereLight(0xaaaaaa, 0x000000, .9)

    // A directional light shines from a specific direction. 
    // It acts like the sun, that means that all the rays produced are parallel. 
    shadowLight = new THREE.DirectionalLight(0xffffff, .9);

    // Set the direction of the light  
    shadowLight.position.set(150, 350, 350);

    // Allow shadow casting 
    shadowLight.castShadow = true;

    // define the visible area of the projected shadow
    shadowLight.shadow.camera.left = -400;
    shadowLight.shadow.camera.right = 400;
    shadowLight.shadow.camera.top = 400;
    shadowLight.shadow.camera.bottom = -400;
    shadowLight.shadow.camera.near = 1;
    shadowLight.shadow.camera.far = 1000;

    // define the resolution of the shadow; the higher the better, 
    // but also the more expensive and less performant
    shadowLight.shadow.mapSize.width = 2048;
    shadowLight.shadow.mapSize.height = 2048;

    // to activate the lights, just add them to the scene
    scene.add(hemisphereLight);
    scene.add(shadowLight);
}

function createLights2() {
    var ambientLight = new THREE.AmbientLight(0x707070);
    scene.add(ambientLight);

    var light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(-10, 18, 5);
    light.castShadow = true;
    var d = 14;
    light.shadow.camera.left = -d;
    light.shadow.camera.right = d;
    light.shadow.camera.top = d;
    light.shadow.camera.bottom = -d;

    light.shadow.camera.near = 2;
    light.shadow.camera.far = 50;

    light.shadow.mapSize.x = 1024;
    light.shadow.mapSize.y = 1024;

    scene.add(light);
}

function createParalellepipedWithPhysics(sx, sy, sz, mass, pos, quat, material) {

    var object = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1), material);
    var shape = new Ammo.btBoxShape(new Ammo.btVector3(sx * 0.5, sy * 0.5, sz * 0.5));
    shape.setMargin(margin);


    var ballBody = createRigidBody(object, shape, mass, pos, quat);

    return object;

}

function createObject(mass, halfExtents, pos, quat, material, name) {

    var object = new THREE.Mesh(new THREE.BoxGeometry(halfExtents.x * 2, halfExtents.y * 2, halfExtents.z * 2), material);
    object.position.copy(pos);
    object.quaternion.copy(quat);


    object.castShadow = true;
    object.receiveShadow = true;
    object.name = name;




    var shape = createConvexHullPhysicsShape(object.geometry.vertices);
    shape.setMargin(margin);

    var body = createRigidBody(object, shape, object.userData.mass, null, null, object.userData.velocity, object.userData.angularVelocity);
    convexBreaker.prepareBreakableObject(object, mass, new THREE.Vector3(), new THREE.Vector3(), true);
    createDebrisFromBreakableObject(object);

}

function createObjects() {
    pos.set(0, -0.5, 0);
    quat.set(0, 0, 0, 1);
    var ground = createParalellepipedWithPhysics(40, 1, 40, 0, pos, quat, checkerTexture);
    ground.receiveShadow = true;
    ground.name = "ground";

    var towerMass = 1000;
    var towerHalfExtents = new THREE.Vector3(2, 5, 2);
    pos.set(-3, 2, -5);
    quat.set(0, 0, 0, 1);
    //  createObject( towerMass, towerHalfExtents, pos, quat, createMaterial( 0xF0A024 ), 'tower' );

    var tower = createParalellepipedWithPhysics(2, 5, 2, towerMass, pos, quat, createMaterial());
    tower.receiveShadow = true;
    tower.castShadow = true;
    tower.name = "tower";

    /*
         var towerMass = 10;
        var towerHalfExtents = new THREE.Vector3( 2, 5, 2 );
        pos.set( 1, 2, -5 );
        quat.set( 0, 0, 0, 1 );
      //  createObject( towerMass, towerHalfExtents, pos, quat, createMaterial( 0xF0A024 ), 'tower' );

        var tower = createParalellepipedWithPhysics(2, 5, 2, towerMass, pos, quat, createMaterial());
        tower.receiveShadow = true;
        tower.castShadow = true;
        tower.name = "tower";
    */
    pos.set(0, 1, -5);
    quat.set(0, 0, 0, 1);
    var brick = createParalellepipedWithPhysics(.6, .6, 1.2, 1000, pos, quat, createMaterial());


    brick.castShadow = true;
    brick.receiveShadow = true;
    brick.name = "bricktest";


    createWall();
    createBalls();
}

function createWall() {
    // Wall
    var brickMass = 100; //0.5;
    var brickLength = 1.2;
    var brickDepth = 0.6;
    var brickHeight = brickLength * 0.5;
    var numBricksLength = 6;
    var numBricksHeight = 8;
    var z0 = -10 - numBricksLength * brickLength * 0.5;
    pos.set(3, brickHeight * 0.5, z0);
    quat.set(0, 0, 0, 1);
    for (var j = 0; j < numBricksHeight; j++) {

        var oddRow = (j % 2) == 1;

        pos.z = z0;

        if (oddRow) {
            pos.z -= 0.25 * brickLength;
        }

        var nRow = oddRow ? numBricksLength + 1 : numBricksLength;
        for (var i = 0; i < nRow; i++) {

            var brickLengthCurrent = brickLength;
            var brickMassCurrent = brickMass;
            if (oddRow && (i == 0 || i == nRow - 1)) {
                brickLengthCurrent *= 0.5;
                brickMassCurrent *= 0.5;
            }

            var brick = createParalellepipedWithPhysics(brickDepth, brickHeight, brickLengthCurrent, brickMassCurrent, pos, quat, createMaterial(999999));


            brick.castShadow = true;
            brick.receiveShadow = true;
            brick.name = "brick";

            if (oddRow && (i == 0 || i == nRow - 2)) {
                pos.z += 0.75 * brickLength;
            } else {
                pos.z += brickLength;
            }

        }
        pos.y += brickHeight;
    }

}


function createBalls() {

    var ballMass = 30; //.35;
    var ballRadius = 1; //0.4;

    for (var j = 0; j < 20; j++) {

        var ball = new THREE.Mesh(new THREE.SphereGeometry(ballRadius, 14, 10), ballMaterial);
        ball.castShadow = true;
        ball.receiveShadow = true;
        ball.name = "enemy";
        var ballShape = new Ammo.btSphereShape(ballRadius);
        ballShape.setMargin(margin);

        //pos = new THREE.Vector3(10,0,10);
        pos.x = Math.random() * 200 - 100;
        pos.y = Math.random() * 20 - 10;
        pos.z = -100; //Math.random() * 200 - 100;
        //pos.copy( raycaster.ray.direction );
        //pos.add( raycaster.ray.origin );
        quat.set(0, 0, 0, 1);
        var ballBody = createRigidBody(ball, ballShape, ballMass, pos, quat);
        ballBody.setFriction(0.9);

        var direction = new THREE.Vector3();
        direction.subVectors(new THREE.Vector3(0, 4, 0), pos).normalize();


        pos.copy(direction);
        pos.multiplyScalar(10);
        ballBody.setLinearVelocity(new Ammo.btVector3(pos.x, pos.y, pos.z));
    }
}

function createPlayer(texture) {
    console.log('createPlayer')

    pos.set(0, controls.userHeight, -1);
    quat.set(0, 0, 0, 1);

    var playerMass = 1000;
    // var playerRadius = 0.2;
    var sx = .25;
    var sy = .25;
    var sz = .25;

    var wireMaterial = new THREE.MeshPhongMaterial({
        color: 0xff0000,
        wireframe: false,
        //transparent:true, opacity:0.5
    });

    // playerblock = new THREE.Mesh(new THREE.SphereGeometry(playerRadius, 14, 10), ballMaterial);
    playerblock = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1), createMaterial(0xff0000, true));
    playerblock.castShadow = true;
    playerblock.receiveShadow = true;
    playerblock.name = "player";

    var playerMaterial = new THREE.SpriteMaterial({
        map: texture,
        color: 0xffffff
    });
    var player = new THREE.Sprite(playerMaterial);
    player.scale.set(.5, .5, 1.0); // imageWidth, imageHeight
    playerblock.add(player)

    var playerShape = new Ammo.btBoxShape(new Ammo.btVector3(sx * 0.5, sy * 0.5, sz * 0.5));
    playerShape.setMargin(margin);

    /* var playerShape = new Ammo.btSphereShape(playerRadius);
     playerShape.setMargin(margin);
     */

    playerBody = createRigidBody(playerblock, playerShape, playerMass, pos, quat);
    playerBody.setFriction(0.9);


    console.log(playerblock)
    console.log(playerblock.name)
    console.log(playerBody)
        /*
                var direction = new THREE.Vector3();
                direction.subVectors(new THREE.Vector3(0, controls.userHeight, -1), pos).normalize();


                pos.copy(direction);
                pos.multiplyScalar(1);
                playerBody.setLinearVelocity(new Ammo.btVector3(pos.x, pos.y, pos.z));
                */
}


function createRigidBody(object, physicsShape, mass, pos, quat, vel, angVel) {

    if (pos) {
        object.position.copy(pos);
    } else {
        pos = object.position;
    }
    if (quat) {
        object.quaternion.copy(quat);
    } else {
        quat = object.quaternion;
    }

    var transform = new Ammo.btTransform();
    transform.setIdentity();
    transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
    transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
    var motionState = new Ammo.btDefaultMotionState(transform);

    var localInertia = new Ammo.btVector3(0, 0, 0);
    physicsShape.calculateLocalInertia(mass, localInertia);

    var rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, physicsShape, localInertia);
    var body = new Ammo.btRigidBody(rbInfo);

    body.setFriction(0.5);

    if (vel) {
        body.setLinearVelocity(new Ammo.btVector3(vel.x, vel.y, vel.z));
    }
    if (angVel) {
        body.setAngularVelocity(new Ammo.btVector3(angVel.x, angVel.y, angVel.z));
    }

    object.userData.physicsBody = body;
    object.userData.collided = false;


    scene.add(object);



    if (mass > 0) {
        rigidBodies.push(object);

        // Disable deactivation
        body.setActivationState(4);
    }

    var btVecUserData = new Ammo.btVector3(0, 0, 0);
    btVecUserData.threeObject = object;
    body.setUserPointer(btVecUserData);

    physicsWorld.addRigidBody(body);

    return body;
}

function createRandomColor() {
    return Math.floor(Math.random() * (1 << 24));
}

function createMaterial(color, wire) {
    color = color || createRandomColor();
    return new THREE.MeshPhongMaterial({
        color: color,
        wireframe: wire
    });
}

function initInput() {
    //window.addEventListener('mousedown', shoot, false);
    window.addEventListener('touchstart', shoot, false);
    window.addEventListener('mousedown', shoot, false);


}

function shoot(e) {
    // alert(e)
    //alert(e.type);
    if (e.type == "touchstart") touchEnabled = true;
    //  e.preventDefault();
    //  e.stopPropagation();

    console.log(playerBody)
        //console.log(playerBody.getLinearVelocity())
    var dir = Math.random() * 2 - 1;
    // playerBody.setAngularVelocity(new Ammo.btVector3(dir,dir,0));
    //  playerBody.setLinearVelocity(new Ammo.btVector3(dir,dir,0));
    // console.log(playerBody.getLinearVelocity())
    /*    mouseCoords.set(
          (event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1
      );

      console.log(mouseCoords)
      console.log(playerblock.position)

      _v3.copy(mouseCoords);

     // _v3.copy(mouseCoords).sub(playerblock.position).multiplyScalar(.5);
     // _v3.y = 0;

      console.log(_v3)
      playerBody.setLinearVelocity(new Ammo.btVector3(_v3.x,_v3.y,0));

      */

    //  playerBody.setLinearVelocity(new Ammo.btVector3(dir,dir,0));

    ///-----------------------------

    // blaster.position.set(playerVector.x, playerVector.y, playerVector.z);
    //  scene.add(blaster);

    // playerVector.setFromMatrixPosition(player.matrixWorld);

    var bulletDir = camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(20);
    //  var camVect = new THREE.Vector3(bulletDir.x, controls.userHeight, bulletDir.z);
    var bulletVect = new THREE.Vector3(bulletDir.x, bulletDir.y + controls.userHeight, bulletDir.z);

    var direction = bulletVect.clone().sub(playerblock.position);
    var length = direction.length();
    var arrowHelper = new THREE.ArrowHelper(direction.normalize(), playerblock.position, length, 0xff0000);


    arrowHelper.time = lastRender;
    scene.add(arrowHelper);


    ///----------------

    //    raycaster.setFromCamera(mouseCoords, camera);

    // Creates a ball and throws it
    var ballMass = 35;
    var ballRadius = 0.2;

    var ball = new THREE.Mesh(new THREE.SphereGeometry(ballRadius, 14, 10), ballMaterial);
    ball.castShadow = true;
    ball.receiveShadow = true;
    ball.name = "bullet";



    var blaster = new THREE.Sprite(blasterMaterial);
    blaster.scale.set(.8, .8, 1.0);
    ball.add(blaster)


    var ballShape = new Ammo.btSphereShape(ballRadius);
    ballShape.setMargin(margin);
    // pos.copy(raycaster.ray.direction);
    // pos.add(raycaster.ray.origin);

    pos.copy(direction);
    // pos.add(playerVector);
    pos.add(playerblock.position);


    quat.set(0, 0, 0, 1);
    var ballBody = createRigidBody(ball, ballShape, ballMass, pos, quat);

    ///  playerblock.position.copy(pos)


    // pos.copy(raycaster.ray.direction);
    pos.copy(direction);
    pos.multiplyScalar(24);
    ballBody.setLinearVelocity(new Ammo.btVector3(pos.x, pos.y, pos.z));

    playSound();


}


function setDebug(bool) {
    debug = bool;
    if (bool == false) info.innerHTML = null;
}


function setStageDimensions(stage) {

    // Place the cube in the middle of the scene, at user height.
    player.position.set(0, controls.userHeight, -1);
}

function updatePhysics(deltaTime) {

    // Step world
    physicsWorld.stepSimulation(deltaTime, 10);

    // Update rigid bodies
    for (var i = 0, il = rigidBodies.length; i < il; i++) {
        var objThree = rigidBodies[i];
        var objPhys = objThree.userData.physicsBody;
        var ms = objPhys.getMotionState();
        //  console.log(objThree.name )
        if (ms) {

            ms.getWorldTransform(transformAux1);
            var p = transformAux1.getOrigin();
            var q = transformAux1.getRotation();
            objThree.position.set(p.x(), p.y(), p.z());
            objThree.quaternion.set(q.x(), q.y(), q.z(), q.w());

            objThree.userData.collided = false;

        }
        /*

                if (objThree.name == "player"){ 
                    console.log('player here')
                    objThree.position.set(p.x()+Math.Random()*4, p.y(), p.z());
                }

        */


    }



    for (var i = 0, il = dispatcher.getNumManifolds(); i < il; i++) {

        var contactManifold = dispatcher.getManifoldByIndexInternal(i);



        var rb0 = contactManifold.getBody0();
        var rb1 = contactManifold.getBody1();

        var threeObject0 = Ammo.castObject(rb0.getUserPointer(), Ammo.btVector3).threeObject;
        var threeObject1 = Ammo.castObject(rb1.getUserPointer(), Ammo.btVector3).threeObject;

        if (!threeObject0 && !threeObject1) {
            continue;
        }

        //  console.log('continuing')

        var userData0 = threeObject0 ? threeObject0.userData : null;
        var userData1 = threeObject1 ? threeObject1.userData : null;

        var breakable0 = userData0 ? userData0.breakable : false;
        var breakable1 = userData1 ? userData1.breakable : false;

        var collided0 = userData0 ? userData0.collided : false;
        var collided1 = userData1 ? userData1.collided : false;

        //if ( ( ! breakable0 && ! breakable1 ) || ( collided0 && collided1 ) ) {
        if (collided0 && collided1) {
            continue;
        }

        var contact = false;
        var maxImpulse = 0;
        for (var j = 0, jl = contactManifold.getNumContacts(); j < jl; j++) {
            var contactPoint = contactManifold.getContactPoint(j);
            if (contactPoint.getDistance() < 0) {
                contact = true;


                var impulse = contactPoint.getAppliedImpulse();
                if (impulse > maxImpulse) {
                    //console.log(contactPoint)
                    maxImpulse = impulse;
                    var pos = contactPoint.get_m_positionWorldOnB();
                    var normal = contactPoint.get_m_normalWorldOnB();
                    impactPoint.set(pos.x(), pos.y(), pos.z());
                    impactNormal.set(normal.x(), normal.y(), normal.z());
                }
                //console.log('break')
                break;
            }
        }

        // If no point has contact, abort
        if (!contact) {
            continue;
        }

        if (!collided0 && maxImpulse > 5) {

            //threeObject0.scale.set(.5,.5,.5)

            //  threeObject0.material = createMaterial()

            testCollisionRules(threeObject1, threeObject0)




            userData0.collided = true;
            //objectsToRemove[ numObjectsToRemove++ ] = threeObject0;
        }



        // Subdivision
        /*
                var fractureImpulse = 250;

                if ( breakable0 && !collided0 && maxImpulse > fractureImpulse ) {
                  console.log('break it')
                  console.log(threeObject0)
                  threeObject0.scale.set(.5,.5,.5)

                  var debris = convexBreaker.subdivideByImpact( threeObject0, impactPoint, impactNormal , 1, 2, 1.5 );

                  var numObjects = debris.length;
                  for ( var j = 0; j < numObjects; j++ ) {

                    createDebrisFromBreakableObject( debris[ j ] );

                  }

                  objectsToRemove[ numObjectsToRemove++ ] = threeObject0;
                
                  userData0.collided = true;
                  

                }
                */
        /*
                if ( breakable1 && !collided1 && maxImpulse > fractureImpulse ) {

                  var debris = convexBreaker.subdivideByImpact( threeObject1, impactPoint, impactNormal , 1, 2, 1.5 );

                  var numObjects = debris.length;
                  for ( var j = 0; j < numObjects; j++ ) {

                    createDebrisFromBreakableObject( debris[ j ] );

                  }

                  objectsToRemove[ numObjectsToRemove++ ] = threeObject1;
                  userData1.collided = true;

                }
        */
    }

    for (var i = 0; i < numObjectsToRemove; i++) {

        removeDebris(objectsToRemove[i]);

    }
    numObjectsToRemove = 0;

}

function testCollisionRules(attacker, victim) {

    // console.log('break it')
    /*      //console.log(contactPoint)
    console.log(attacker.name + " hit " + victim.name);

    console.log(victim)
    console.log(attacker)
    console.log('----------')
*/
    if (attacker.name == "bullet") {
        console.warn(attacker.name + " hit " + victim.name);
        if (victim.name != "ground") {
            victim.material = createMaterial()
                //objectsToRemove[ numObjectsToRemove++ ] = victim;
            playExplode();
        }

        objectsToRemove[numObjectsToRemove++] = attacker;
        score++;
        score_display.innerHTML = score;

    } else {
        // console.log(attacker.name + " hit " + victim.name);
    }


    if (victim.name == "player" || attacker.name == "player") {
        console.error('OUCH!!!!!')
        playArgh();
    }

    attacker.material = createMaterial()


}

function createDebrisFromBreakableObject(object) {

    object.castShadow = true;
    object.receiveShadow = true;

    var shape = createConvexHullPhysicsShape(object.geometry.vertices);
    shape.setMargin(margin);

    var body = createRigidBody(object, shape, object.userData.mass, null, null, object.userData.velocity, object.userData.angularVelocity);

    // Set pointer back to the three object only in the debris objects
    var btVecUserData = new Ammo.btVector3(0, 0, 0);
    btVecUserData.threeObject = object;
    body.setUserPointer(btVecUserData);



}

function removeDebris(object) {

    console.log(object)

    scene.remove(object);

    physicsWorld.removeRigidBody(object.userData.physicsBody);

}

function removePlayer() {

    //console.log(object)
    alert('removePlayer')

    scene.remove(playerblock);

    physicsWorld.removeRigidBody(playerBody);

}





function createConvexHullPhysicsShape(points) {

    var shape = new Ammo.btConvexHullShape();

    for (var i = 0, il = points.length; i < il; i++) {
        var p = points[i];
        this.tempBtVec3_1.setValue(p.x, p.y, p.z);
        var lastOne = (i === (il - 1));
        shape.addPoint(this.tempBtVec3_1, lastOne);
    }

    return shape;

}

function TextureAnimator(texture, tilesHoriz, tilesVert, numTiles, tileDispDuration) {
    // note: texture passed by reference, will be updated by the update function.

    this.tilesHorizontal = tilesHoriz;
    this.tilesVertical = tilesVert;
    // how many images does this spritesheet contain?
    //  usually equals tilesHoriz * tilesVert, but not necessarily,
    //  if there at blank tiles at the bottom of the spritesheet. 
    this.numberOfTiles = numTiles;
    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(1 / this.tilesHorizontal, 1 / this.tilesVertical);



    // how long should each image be displayed?
    this.tileDisplayDuration = tileDispDuration;

    // how long has the current image been displayed?
    this.currentDisplayTime = 0;

    // which image is currently being displayed?
    this.currentTile = 0;

    this.animBehavior = false;
    /*
      this.setFrame = function( frame ){
        this.currentTile = frame;
        var currentColumn = this.currentTile % this.tilesHorizontal;
        texture.offset.x = currentColumn / this.tilesHorizontal;

      }
     */

    this.setFrame = function(xpos, ypos, state) {
        this.animBehavior = state;
        console.log(xpos, ypos)
        var currentColumn = xpos % this.tilesHorizontal;
        texture.offset.x = currentColumn / this.tilesHorizontal;
        var currentRow = ypos % this.tilesVertical;
        console.log('currentRow =' + currentRow)
        texture.offset.y = currentRow / this.tilesVertical;

    }

    this.update = function(milliSec) {
        this.currentDisplayTime += milliSec;

        if (this.animBehavior == "once") {
            this.playOnce();
        } else if (this.animBehavior == "loop") {
            this.playLoop();
        }


    };

    this.playOnce = function() {
        while (this.currentDisplayTime > this.tileDisplayDuration) {
            this.currentDisplayTime -= this.tileDisplayDuration;
            if (this.currentTile < this.numberOfTiles - 1) {
                this.currentTile++;
                //   if (this.currentTile == this.numberOfTiles)
                //   this.currentTile = 0;
                var currentColumn = this.currentTile % this.tilesHorizontal;
                texture.offset.x = currentColumn / this.tilesHorizontal;
                //  var currentRow = Math.floor( this.currentTile / this.tilesHorizontal );
                // texture.offset.y = currentRow / this.tilesVertical;
            } else {
                //flash player
                //console.log(this.currentDisplayTime)
                // (Math.floor(this.currentDisplayTime)% 2 == 0)? this.opacity=.2 : this.opacity= 1;
            }
        }
    }

    this.playLoop = function() {
        while (this.currentDisplayTime > this.tileDisplayDuration) {

            this.currentDisplayTime -= this.tileDisplayDuration;
            this.currentTile++;
            if (this.currentTile == this.numberOfTiles)
                this.currentTile = 0;
            var currentColumn = this.currentTile % this.tilesHorizontal;
            texture.offset.x = currentColumn / this.tilesHorizontal;
            //  var currentRow = Math.floor( this.currentTile / this.tilesHorizontal );
            // texture.offset.y = currentRow / this.tilesVertical;
        }
    }



}


// loadGetReady();
loadSound();
loadArgh();
loadExplode();
init();
initPhysics();
createObjects();
initInput();
</script>

</html>
