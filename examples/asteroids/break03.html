<!DOCTYPE html>
<html lang="en">

<head>
    <title>Space Harrier VR</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <style>
    body {
        width: 100%;
        height: 100%;
        background-color: #bd8ef8;
        color: #fff;
        margin: 0px;
        padding: 0;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    #info {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 101;
      
    }
    
    #score {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 102;
    }

 
    /*
* {cursor: none;}
*/
    </style>
</head>

<body>
    <a href="#" id="reset"><div id='info'></div></a>
    <div id='score'></div>
   
</body>
<!--
<script id="vertexShader" type="x-shader/x-vertex">
    varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }
</script>
<script id="fragmentShader" type="x-shader/x-fragment">
    uniform vec3 color1; uniform vec3 color2; uniform float scale; varying vec2 vUv; void main() { vec2 center = -1.0 + 2.0 * vUv; vec2 uv = floor(center.xy * scale); if(mod(uv.x + uv.y, 2.0) > 0.5){ gl_FragColor = vec4(color1, 1.0); }else{ gl_FragColor = vec4(color2, 1.0); } }
</script>

-->

<script id="vertexShader" type="x-shader/x-vertex">
      varying vec2 vUv;
      uniform float time;
      uniform float speed;
      uniform float scale;
      //varying float z;

      void main() {
        vUv = uv;

        //float z = scale;
        //float y = scale;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);

      }
  </script>
  
  <script id="fragmentShader" type="x-shader/x-fragment">

      uniform vec3 color1; 
      uniform vec3 color2;


      uniform float speed;
      uniform float scale;
      uniform float delta;

      uniform float time;
      varying vec2 vUv;
      uniform vec2 u_resolution;



      void main() {


        
        float delta = time * speed;

        vec2 center = -1.0 + 2.0 * vUv;

        vec2 uv = center.xy * scale;

        uv.y+=delta;

        gl_FragColor = vec4(color1, 1.0);
    
        if (floor(mod(uv.y, 2.0)) < 1.0) {
            if (mod(uv.x, 2.0) > 1.0)
                gl_FragColor = vec4(color2, 1.0);
        } else {
            if (mod(uv.x, 2.0) < 1.0)
                gl_FragColor = vec4(color2, 1.0);
        }

      }
  </script>
<script>
/*
 * Debug parameters.
 */
WebVRConfig = {
    /**
     * webvr-polyfill configuration
     */

    // Forces availability of VR mode.
    // FORCE_ENABLE_VR: true, // Default: false.
    // Complementary filter coefficient. 0 for accelerometer, 1 for gyro.
    //K_FILTER: 0.98, // Default: 0.98.
    // How far into the future to predict during fast motion.
    //PREDICTION_TIME_S: 0.040, // Default: 0.040 (in seconds).
    // Flag to disable touch panner. In case you have your own touch controls
    // TOUCH_PANNER_DISABLED: true, // Default: false.
    // Enable yaw panning only, disabling roll and pitch. This can be useful for
    // panoramas with nothing interesting above or below.
    YAW_ONLY: false, // Default: false.
    // Enable the deprecated version of the API (navigator.getVRDevices).
    //ENABLE_DEPRECATED_API: true, // Default: false.
    // Scales the recommended buffer size reported by WebVR, which can improve
    // performance. Making this very small can lower the effective resolution of
    // your scene.
    BUFFER_SCALE: 1, // default: 1.0
    // Allow VRDisplay.submitFrame to change gl bindings, which is more
    // efficient if the application code will re-bind it's resources on the
    // next frame anyway.
    // Dirty bindings include: gl.FRAMEBUFFER_BINDING, gl.CURRENT_PROGRAM,
    // gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING,
    // and gl.TEXTURE_BINDING_2D for texture unit 0
    // Warning: enabling this might lead to rendering issues.
    //DIRTY_SUBMIT_FRAME_BINDINGS: true // default: false
};
</script>
<!--
  A polyfill for Promises. Needed for IE and Edge.
  -->
<script src="node_modules/es6-promise/dist/es6-promise.js"></script>
    <script src="../../bower_components/three.js/build/three.js"></script>
    <script src="../../bower_components/three.js/examples/js/libs/ammo.js"></script>
    <script src="../../bower_components/three.js/examples/js/controls/OrbitControls.js"></script>
    <script src="../../bower_components/three.js/examples/js/Detector.js"></script>
    <script src="../../bower_components/three.js/examples/js/libs/stats.min.js"></script>
    <script src="../../bower_components/three.js/examples/js/ConvexObjectBreaker.js"></script>
    <script src="../../bower_components/three.js/examples/js/QuickHull.js"></script>
    <script src="../../bower_components/three.js/examples/js/geometries/ConvexGeometry.js"></script>
    <script src="../../bower_components/three.js/examples/js/shaders/CopyShader.js"></script>
    <script src="../../bower_components/three.js/examples/js/shaders/FXAAShader.js"></script>
    <script src="../../bower_components/three.js/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="../../bower_components/three.js/examples/js/postprocessing/RenderPass.js"></script>
    <script src="../../bower_components/three.js/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="../../bower_components/three.js/examples/js/postprocessing/OutlinePass.js"></script>
    <script src="../../bower_components/gsap/src/minified/TweenMax.min.js"></script>
    <script src="node_modules/three/examples/js/controls/VRControls.js"></script>
    <script src="node_modules/three/examples/js/effects/VREffect.js"></script>

    <script src="node_modules/webvr-polyfill/build/webvr-polyfill.js"></script>
    <script src="build/webvr-manager.js"></script>
    <script src="node_modules/howler/dist/howler.min.js"></script>
     <!--   <script>
            THREE.ShapeUtils.triangulateShape = ( function () {
                var pnlTriangulator = new PNLTRI.Triangulator();
                function removeDupEndPts(points) {

                    var l = points.length;

                    if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

                        points.pop();

                    }

                }

                return function triangulateShape( contour, holes ) {
                    // console.log("new Triangulation: PnlTri.js " + PNLTRI.REVISION );

                    removeDupEndPts( contour );
                    holes.forEach( removeDupEndPts );

                    return pnlTriangulator.triangulate_polygon( [ contour ].concat(holes) );
                };
            } )();
        </script>
        -->
<script>
var forceVR = true;//false; //true;
var debug = true;

var renderer, scene, camera, controls, effect, manager, loader, stats, title;
var playerblock, playerBody, playerState;
var pivot, player, player_sprite;
var mouse = new THREE.Vector2();
var uTime;
var helper;
var blasterArr = [];
var letterArr = [];
var explosionArr = [];
var enemyPool = [];
var blasterSpeed = .3; //5;
var info = document.getElementById('info');
var touchEnabled = false;
var gameOn = false;
var pressTimer = false;
var pressCounter = 0;

var stars = [];

var annie, hero;

var score_display = document.getElementById('score');
var score = 0;
var sound, getReady, explode, argh, bkgdMusic;

var textureLoader;
var clock = new THREE.Clock();
var playerVector = new THREE.Vector3();
var camVector = new THREE.Vector3();
var camDir = new THREE.Vector3();
var heroTexture;

var direction = new THREE.Vector3();

var mouseCoords = new THREE.Vector2();
var raycaster = new THREE.Raycaster();
var ballMaterial = new THREE.MeshPhongMaterial({
    color: 0x000000,
    wireframe: false,
    //transparent:true, opacity:0.5
});

var hemisphereLight, shadowLight;
var floorMaterial, floorPlane;
var floor = [];
//var checkerTexture;
var xA = 0;
var yA = 0;
var accX = 0;
var accY = 0;
var accZ = 0;

 var composer, effectFXAA, outlinePass;
    var selectedObjects = [];

// Physics variables
var gravityConstant = 0; //0.1; //7.8;
var collisionConfiguration;
var dispatcher;
var broadphase;
var solver;
var physicsWorld;
var margin = 0.05;

var convexBreaker = new THREE.ConvexObjectBreaker();

// Rigid bodies include all movable objects
var rigidBodies = [];

var pos = new THREE.Vector3();
var quat = new THREE.Quaternion();
var transformAux1 = new Ammo.btTransform();
var tempBtVec3_1 = new Ammo.btVector3(0, 0, 0);

var time = 0;

var objectsToRemove = [];
for (var i = 0; i < 500; i++) {
    objectsToRemove[i] = null;
}
var numObjectsToRemove = 0;

var impactPoint = new THREE.Vector3();
var impactNormal = new THREE.Vector3();

// Request animation frame loop function
var lastRender = 0;

var vrDisplay;

var accZsmooth = 0;
var accYsmooth = 0;
var factor = .98;

var _v3 = new THREE.Vector3;

var arrowArr = [];
 var group, textMesh1, textMesh2, textGeo, materials;

 var text = "VR",

        height = 20,
        size = 70,
        hover = 30,

        curveSegments = 4,

        bevelThickness = 20,
        bevelSize = 1.5,
        bevelSegments = 3,
        bevelEnabled = true,

        font = undefined,

        fontName = "Slukoni";//"optimer", // helvetiker, optimer, gentilis, droid sans, droid serif
        fontWeight = "Medium";//"bold"; // normal bold

    var mirror = false;

    var fontMap = {

        "helvetiker": 0,
        "optimer": 1,
        "gentilis": 2,
        "droid/droid_sans": 3,
        "droid/droid_serif": 4,
        "slukoni": 5

    };

    var weightMap = {

        "regular": 0,
        "bold": 1

    };


var Colors = {
    red: 0xf25346,
    white: 0xd8d0d1,
    brown: 0x59332e,
    pink: 0xF5986E,
    brownDark: 0x23190f,
    blue: 0x68c3c0,
};

// shader for checkerboard

var options  = {
                

        speed            : 10.0,

        segments         : 324,

        checker_color1     : '#76c876',

        checker_color2     : '#a7f9a7',

        scale            : 50,

      //  perlin_passes    : 1,

        wireframe        : true,

      //  floor_visible    : true

    };


var uniforms = {
      "time": {
          type: "f",
          value: 0.0
      },
      "speed": {
          type: "f",
          value: options.speed
      },

  
      "color1" : {
        type : "c",
        value : new THREE.Color(0x76c876)
      },
      "color2" : {
        type : "c",
        value : new THREE.Color(0xa7f9a7)
      },
     
      "scale" : {
        type : "f",
        value : options.scale,
        min : 1, // only used for dat.gui, not needed for production
        max : 100 // only used for dat.gui, not needed for production
      },
    }
var vertexShader = document.getElementById('vertexShader').text;
var fragmentShader = document.getElementById('fragmentShader').text;

var defines = {};
defines[ "USE_MAP" ] = "";
var checkerTexture = new THREE.ShaderMaterial({
    defines: defines,
    uniforms: uniforms,
    vertexShader: vertexShader,
    fragmentShader: fragmentShader,
    side: THREE.DoubleSide,
   // lights:true
        // doubleSide: true,
});



// custom global variables
var annie, hero; // animators




var volume = 0.4;

function loadBkgdMusic() {
    bkgdMusic = new Howl({
        src: ['audio/sh-theme.mp3'],
        volume: volume
    });
   // sound.play();

}

function playBkgdMusic() {
    bkgdMusic.play();
}

function loadBlaster() {
    blaster = new Howl({
        src: ['audio/fire.wav'],
        volume: volume
    });
   // sound.play();

}

function playBlaster() {
    blaster.play();
}

function loadExplode() {

    explode = new Howl({
        src: ['audio/bangSmall.wav'],
        volume: volume
    });
    //explode.play();

}

function playExplode() {
    explode.play();
}

function muteAll() {
    howler.mute();
}


function init() {

    setDebug(true)

    renderer = new THREE.WebGLRenderer({
        antialias: true,
        precision: "mediump"
    });
    renderer.setClearColor(0x333333);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;

    // Append the canvas element created by the renderer to document body element.
    document.body.appendChild(renderer.domElement);

    // Create a three.js scene.
    scene = new THREE.Scene();

    scene.background = new THREE.Color(0x333333);



    // Create a three.js camera.
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
    //var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 100);

    controls = new THREE.VRControls(camera);
    controls.standing = true;
    controls.standing = true;

    // Apply VR stereo rendering to renderer.
    effect = new THREE.VREffect(renderer);
    effect.setSize(window.innerWidth, window.innerHeight);

    // Create a VR manager helper to enter and exit VR mode.
    var params = {
        hideButton: false, // Default: false.
        isUndistorted: false // Default: false.
    };
    manager = new WebVRManager(renderer, effect, params);


    /*
        loader = new THREE.TextureLoader();
        //setPlayerTexture calls setupStage which triggers animate
        loader.load('img/Space_Harrier_player_sprite.png', setPlayerTexture);
    */
    




    setupStage();

    var loader2 = new THREE.TextureLoader();
    loader2.load('img/blaster.png', function(texture) {
        blasterMaterial = new THREE.SpriteMaterial({
            map: texture,
            color: 0xffffff
        });
        // createBlaster();

        // needs a delay??
        if (forceVR && manager.isVRCompatible) {
            manager.enterVRMode_();
            console.log(manager)
        }

    });
    
    /*
        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        renderer.domElement.appendChild(stats.domElement);
    */


    createLights();
    createTitleScreen();

    addSphere();
   // createLetter('V');
    
    // setupGround();

     // postprocessing
        composer = new THREE.EffectComposer(renderer);
        var renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);
        outlinePass = new THREE.OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
        outlinePass.edgeStrength = 50.0;
        outlinePass.edgeGlow = 0.0;
        outlinePass.edgeThickness = 1.0;
        outlinePass.pulsePeriod = 0;
        outlinePass.rotate = false;
        outlinePass.usePatternTexture = false;
        outlinePass.visibleEdgeColor = new THREE.Color(0xffffff)
        outlinePass.hiddenEdgeColor = new THREE.Color(0x190a05)
        composer.addPass(outlinePass);

        //

        effectFXAA = new THREE.ShaderPass(THREE.FXAAShader);
        effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
        effectFXAA.renderToScreen = true;
        composer.addPass(effectFXAA);

    window.addEventListener('resize', onResize, true);
    window.addEventListener('vrdisplaypresentchange', onResize, true);


}

function createTitleScreen(){
    var loader = new THREE.TextureLoader();
    loader.load('img/asteroid02.png', function(texture) {
      //  var titleTexture = texture;
      //  console.log(texture.image.width)// and texture.image.height
        var titleMaterial = new THREE.SpriteMaterial({
            map: texture,
            color: 0xffffff
        });

        title = new THREE.Sprite(titleMaterial);
        title.scale.set(2, 1, 1)
        title.position.set(0, controls.userHeight, -5)
        scene.add(title);


        TweenMax.to(title.position, 1,{

            z:-2,

            ease:"Power3.easeOut",
            onUpdate:function(){
               // no_geom.verticesNeedUpdate = true;
                
          //  console.log('tweened');
        }});

        loadFont();
    });
}

function removeTitleScreen(){
    for (var n=0; n<letterArr.length;n++){
        scene.remove(letterArr[n])
    }
    scene.remove(title)
}

function initPhysics() {

    // Physics configuration

    collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
    dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
    broadphase = new Ammo.btDbvtBroadphase();
    solver = new Ammo.btSequentialImpulseConstraintSolver();
    physicsWorld = new Ammo.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);
    physicsWorld.setGravity(new Ammo.btVector3(0, -gravityConstant, 0));

}

function addPlayer() {
    player = new Player("img/hero-spritesheet.png", 0, true);


    pivot = new THREE.Object3D();
    pivot.position.set(0, controls.userHeight, 0);
    scene.add(pivot);

    // createPlayer(playerTexture);

    createPlayerHelper();
}

function Explosion(vector) {

    var explosionTexture = new THREE.TextureLoader().load("img/explosion_sprite_small.png");
    var expSprite = new TextureAnimator(explosionTexture, 7, 1, 7, 75);
    expSprite.animBehavior = "loop";

    explosionblock = new THREE.Mesh(new THREE.BoxGeometry(.5, .5, .5, 1, 1, 1), createMaterial(0xff0000, true, 0));
    explosionblock.castShadow = true;
    explosionblock.receiveShadow = true;
    explosionblock.name = "explosion";




    //annie = new TextureAnimator( explosionTexture, 10, 1, 10, 75 ); // texture, #horiz, #vert, #total, duration.
   /* var explosionMaterial = new THREE.MeshBasicMaterial({
        map: explosionTexture,
        side: THREE.DoubleSide,
        color: 0xffffff
    });*/
   
        // var explosionGeometry = new THREE.PlaneGeometry(1.16, .78, 1, 1);
        //  var explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);

    var explosionMaterial = new THREE.SpriteMaterial({
        map: explosionTexture,
        color: 0xffffff
    });
     explosionMaterial.transparent = true;
    explosionMaterial.depthTest = true
    explosionMaterial.depthWrite = false
    explosionMaterial.polygonOffset = true
    explosionMaterial.polygonOffsetFactor = -4
    var explosion = new THREE.Sprite(explosionMaterial);


    // explosion.position.set(0,controls.userHeight,-5);
    explosion.scale.set(2, 2, 1.0); 
    explosionblock.position.copy(vector);
    scene.add(explosionblock);
    explosionblock.add(explosion)

    explosionArr.push(this);

    this.mesh = explosion;
    this.block = explosionblock;
    this.sprite = expSprite;
    this.start = 0;
    //  this.shadow = new Shadow(player.position);
    this.dist = Math.random() * 60;

    // this.flicker();

    this.update = function() {
      //  console.log('explosion update')

    }

    this.animate = function(state, loops) {
        // console.log('player animate')
        //this.tilesHorizontal =3;


    }

    this.flicker = function() {
        TweenMax.to(this.mesh.material, .1, {
            opacity: 0,
            delay: .4,
            repeat: 7,
            yoyo: true
        });
    }

    this.fadeOut = function() {
    //    console.log('fadeOut')
        var _this = this;
        TweenMax.to(this.mesh.material, .3, {
            opacity: 0,
            delay: .5,
            onComplete:function(){
                _this.destroy();
                        }
        });
    }


    this.destroy = function() {
       // console.log('destroy')
       // console.log(this)
        scene.remove(this.block);
        explosionArr.splice(this, 1);
        // console.log(enemyPool)

    }

    this.fadeOut();

}



function createPlayerHelper() {
    var r = 1;
    helper = new THREE.BoxHelper(new THREE.Mesh(new THREE.BoxGeometry(r, r, r)));
    helper.material.color.setHex(0x080808);
    helper.material.blending = THREE.AdditiveBlending;
    //helper.position.set(0, controls.userHeight, 0);
    helper.position.z = -1;
    helper.scale.set(.2, .2, .2);
    pivot.add(helper);

    if (debug == false) helper.visible = false;
}


function animate() {


    var deltaTime = clock.getDelta();

    //animate checkerboard texture
    uniforms.time.value = clock.getElapsedTime();

    if (gameOn){
      //  hero.update(700 * deltaTime);
        //  if (annie) annie.update(700 * deltaTime);
        for (var n = 0; n < explosionArr.length; n++) {
           // console.log(explosionArr[n])
            explosionArr[n].sprite.update(700 * deltaTime);

        }

        for (var n = 0; n < enemyPool.length; n++) {
           // console.log(explosionArr[n])
            enemyPool[n].update();


        }

        playerFollow();


    }


    if (pressTimer) {
        pressCounter++;
       // console.log(pressCounter)
        if (pressCounter > 200){
            resetGame();
            pressTimer=false;
        }
    }
    animateStars();

    updatePhysics(deltaTime);

    controls.update(deltaTime);

    time += deltaTime;

    outlinePass.selectedObjects = selectedObjects;
  //  console.log( outlinePass.selectedObjects)

    // Render the scene through the manager.
    manager.render(scene, camera);
    effect.render(scene, camera);
    composer.render();

    

    if (pivot) {
        pivot.rotation.copy(camera.rotation);
       // console.log(camera.rotation)
        pivot.updateMatrix();
    }


    // stats.update();

    vrDisplay.requestAnimationFrame(animate);
}

function playerFollow() {
    var camDir = camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(1);
    var camVect = new THREE.Vector3(camDir.x, camDir.y, camDir.z);


    // get mouse position and add some accelerometer
    var vector;
    if (touchEnabled) {
        vector = new THREE.Vector3(-accYsmooth, accZsmooth, -1).unproject(camera);


    } else {

        vector = new THREE.Vector3(-mouse.x * 10, -mouse.y * 10, -1).unproject(camera);
        //  vector = new THREE.Vector3(-mouse.x * 10 - accYsmooth, -mouse.y * 10 + accZsmooth, -1).unproject(camera);
    }


    var direction = camVect.clone().sub(playerblock.position).add(vector);

    var speed = 5;
    var xpos = direction.x * speed;
    var ypos = direction.y * speed;
    var zpos = direction.z * speed;


    playerBody.setLinearVelocity(new Ammo.btVector3(xpos, ypos, zpos));

}

function onResize(e) {
    effect.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

   // renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
        effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);

}



// Get the HMD, and if we're dealing with something that specifies
// stageParameters, rearrange the scene.
function setupStage() {
    navigator.getVRDisplays().then(function(displays) {

        if (displays.length > 0) {
            vrDisplay = displays[0];
            if (vrDisplay.stageParameters) {
                setStageDimensions(vrDisplay.stageParameters);
                if (forceVR && manager.isVRcompatible) {
                    manager.enterVRMode_();
                    console.log(manager)
                }
            }
            vrDisplay.requestAnimationFrame(animate);
        }
        //   console.log(vrDisplay.orientation_);
        // window.addEventListener("devicemotion", function(event) 

        // is mobile? has accelerometer?
        //if(window.DeviceMotionEvent) { 
        //   var util = new Util;
        //    console.log(util.isMobile)
        // bad mobile detection
        if (window.innerWidth < 769) {
            console.log('isDeviceMotion')

            window.addEventListener("devicemotion", function(event) {

                //accX = Math.round(event.accelerationIncludingGravity.x*10) / 10;  
                //accY = Math.round(event.accelerationIncludingGravity.y*10) / 10;  
                // accY = event.accelerationIncludingGravity.y;
                // if (manager.mode == 1){

                accZ = event.accelerationIncludingGravity.z;
                accY = event.accelerationIncludingGravity.y;
                accZsmooth = factor * accZsmooth + (1 - factor) * accZ;
                accYsmooth = factor * accYsmooth + (1 - factor) * accY;

/*
                if (gameOn){
                    if (accZsmooth < -1) {
                            player.animate('run')
                        
                    } else {
                       // player.animate('fly');
                        if (accYsmooth < -.15) {
                             player.animate('right')
                         } else if (accYsmooth >.15) {
                             player.animate('left')
                         } else {
                             player.animate('fly')
                         }
                       
                      
                    }
                }
*/
                //if VR mode
                if (manager.mode == 3) {
                    //  info.innerHTML += ' mode 1'
                    // info.innerHTML += ' player='+player.position;
                    //  ?????????????????????
                    //  accZsmooth =-7.75;
                    accYsmooth = accYsmooth*-1;


                    mouse.x = 0;
                    mouse.y = 0;

                }


                if (debug) {
                    info.innerHTML = 'accZ:' + accZ.toFixed(2) + ', accZsm:' + accZsmooth.toFixed(2) + ', accY:' + accYsmooth.toFixed(2);
                    info.innerHTML += ' mode:' + manager.mode;
                }

                

            }, true);



        }
    });

}
/*
function doOnOrientationChange() {
    switch(window.orientation) {  
      case -90 || 90:
        alert('landscape');
        break; 
      default:
        alert('portrait');
        break; 
    }
}
  
*/

function onDocumentKeyPress(event) {
  //  player.animate('run');
    var keyCode = event.which;
    console.log(keyCode)

    // press ''

    if (keyCode == 100) {

        if (debug == true) {
            setDebug(false);
        } else {
            setDebug(true);
        }

        event.preventDefault();

    }

}


function onDocumentMouseMove(event) {

    if (gameOn){
        event.preventDefault();

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

/*

        if (mouse.y > .3) {
            if (camera.rotation.x < 0.05 ){
                player.animate('run')
            }
        } else {
            player.animate('fly');
             if (mouse.x < -.4) {
                 player.animate('right')
             } else if (mouse.x > .4) {
                 player.animate('left')
             } else {
                 player.animate('fly')
             }
          
        }
        */
        /*
            mouseCoords.set(
                (event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1
            );
        */

        if (debug) info.innerHTML = 'x:' + mouse.x.toFixed(2) + ', y:' + mouse.y.toFixed(2);

    }
}




function createLights() {
    var ambientLight = new THREE.AmbientLight(0x707070);
    scene.add(ambientLight);

    var light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(-10, 18, 5);
    light.castShadow = true;
    var d = 14;
    light.shadow.camera.left = -d;
    light.shadow.camera.right = d;
    light.shadow.camera.top = d;
    light.shadow.camera.bottom = -d;

    light.shadow.camera.near = 2;
    light.shadow.camera.far = 50;

    light.shadow.mapSize.x = 1024;
    light.shadow.mapSize.y = 1024;

    scene.add(light);
}

function createParalellepipedWithPhysics(sx, sy, sz, mass, pos, quat, material) {

    var object = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1), material);
    var shape = new Ammo.btBoxShape(new Ammo.btVector3(sx * 0.5, sy * 0.5, sz * 0.5));
    shape.setMargin(margin);


    var ballBody = createRigidBody(object, shape, mass, pos, quat);

    return object;

}



function createObjects() {
    
/*
    pos.set(0, 1, -5);
    quat.set(0, 0, 0, 1);
    var brick = createParalellepipedWithPhysics(.6, .6, 1.2, 1000, pos, quat, createMaterial());


    brick.castShadow = true;
    brick.receiveShadow = true;
    brick.name = "brick";

    pos.set(Math.random()*4-2, Math.random()*10, Math.random()*10 - 5);
    quat.set(0, 0, 0, 1);
    var brick = createParalellepipedWithPhysics(.6, .6, 1.2, 1000, pos, quat, createMaterial());


    brick.castShadow = true;
    brick.receiveShadow = true;
    brick.name = "brick";
*/
    createAsteroidBelt(8);


}


function Player(img, xpos, sprite) {

    //var playerTexture = new THREE.TextureLoader().load( "img/player_small_128.png" );
   // var playerTexture = new THREE.TextureLoader().load(img);
   // if (sprite) hero = new TextureAnimator(playerTexture, 4, 4, 3, 75);
    //annie = new TextureAnimator( playerTexture, 10, 1, 10, 75 ); // texture, #horiz, #vert, #total, duration.

    pos.set(0, controls.userHeight, -1);
    quat.set(0, 0, 0, 1);

    var playerMass = 2000;

    var sx = .2;
    var sy = .2;
    var sz = .2;

  //  playerblock = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1), createMaterial(0xff0000, true));
     var pyramidGeometry = new THREE.CylinderGeometry(0, sy, sz, 3, false); 

    //playerblock = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1), createMaterial(0xff0000, false, .5));
    playerblock = new THREE.Mesh(pyramidGeometry,createMaterial(0xffffff, true));
   // playerblock.scale.set(1,3,1)
  //  playerblock.rotation.y = Math.PI/2;
    playerblock.castShadow = true;
    playerblock.receiveShadow = true;
    playerblock.name = "player";

    var innerblock = new THREE.Mesh(pyramidGeometry,createMaterial(0xffffff, false, .75));
    innerblock.scale.set(.8,.8,.8)
    playerblock.add(innerblock)



   // playerblock.visible = false;
/*
    var playerMaterial = new THREE.SpriteMaterial({
        map: playerTexture,
        color: 0xffffff
    });
    */
    /*
        var playerMaterial = new THREE.MeshBasicMaterial({
            map: playerTexture,
            side: THREE.DoubleSide,
            color: 0xffffff
        });
    
    playerMaterial.transparent = true;

    // playerMaterial.map.offset = new THREE.Vector2(0.25 * 1, 0);
    // playerMaterial.map.repeat = new THREE.Vector2(1 / 4, 1);
    //fixes flicker when planes intersect
    playerMaterial.depthTest = true
    playerMaterial.depthWrite = false
    playerMaterial.polygonOffset = true
    playerMaterial.polygonOffsetFactor = -4
        /// end fix
    */
    /// the actual character ////      
    // var playerGeometry = new THREE.PlaneGeometry(1, 1, 10, 10);
    //  var player = new THREE.Mesh(playerGeometry, playerMaterial);


    var playerShape = new Ammo.btBoxShape(new Ammo.btVector3(sx * 0.5, sy * 0.5, sz * 0.5));
    playerShape.setMargin(margin);

    /* var playerShape = new Ammo.btSphereShape(playerRadius);
     playerShape.setMargin(margin);
     */

    playerBody = createRigidBody(playerblock, playerShape, playerMass, pos, quat);
    playerBody.setFriction(0.9);

  


   // physicsBodies.push(playerBody);


  //  console.log(playerblock)
  //  console.log(playerblock.name)
  //  console.log(playerBody)




    /////////
    /*
      // playerblock = new THREE.Mesh(new THREE.SphereGeometry(playerRadius, 14, 10), ballMaterial);
        playerblock = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1), createMaterial(0xff0000, true));
        playerblock.castShadow = true;
        playerblock.receiveShadow = true;
        playerblock.name = "player";

        var playerMaterial = new THREE.SpriteMaterial({
            map: texture,
            color: 0xffffff
        });
        var player = new THREE.Sprite(playerMaterial);
        player.scale.set(.5, .5, 1.0); // imageWidth, imageHeight
        playerblock.add(player)
    */
    /////

    this.mesh = player;
    this.start = 0;
    //  this.shadow = new Shadow(player.position);
    this.dist = Math.random() * 60;

    this.update = function() {
     //   console.log('player update')

    }

    this.animate = function(state, loops) {
        // console.log('player animate')
        //this.tilesHorizontal =3;

       // console.log('state=' + state + ',pState=' + playerState)
       /*
        if (state != playerState) {
            hero.currentTile = 0;
            hero.numberOfTiles = 3;
           // console.error('state=' + state + ',pState=' + playerState)
            playerState = state;
            if (state == "fly") {
               // console.log("fly")

                hero.setFrame(0, 3, 'freeze');

            } else if (state == "left") {
              //  console.log("left")
                hero.setFrame(1, 3, 'freeze');

            } else if (state == "right") {
              //  console.log("right")
                hero.setFrame(2, 3, 'freeze');

            } else if (state == "run") {
              //  console.log("run")
                hero.setFrame(0, 2, 'loop');

            } else if (state == "fall") {
              // console.log("fall")
                hero.setFrame(0, 1, 'once');
                this.flicker();

            } else if (state == "die") {
              //+  console.log("die")
                    //this.tilesHorizontal =4;
                hero.numberOfTiles = 4;
                hero.setFrame(0, 0, 'once');
                this.flicker();

            }
        }
        */
    }

    this.flicker = function() {
        TweenMax.to(this.mesh.material, .1, {
            opacity: 0,
            delay: .4,
            repeat: 7,
            yoyo: true
        });
    }





    /*
      this.update = function(){
            this.mesh.position.y = 80 + Math.sin(this.start)*40;
            this.mesh.position.z = Math.cos(this.start)*this.dist;
            this.shadow.update();
            this.start+=options.speed;


      }

      this.destroy = function(){
        console.log('destroy')
        this.shadow.destroy();
        scene.remove(this.mesh);
        //playerPool.splice(this, 1);
       // console.log(enemyPool)

      }
      */
}

function addSphere() {

        // The loop will move from z position of -1000 to z position 1000, adding a random particle at each position. 
        for (var z = -1000; z < 1000; z += 20) {

            // Make a sphere (exactly the same as before). 
            var geometry = new THREE.SphereGeometry(0.5, 32, 32)
            var material = new THREE.MeshBasicMaterial({
                color: 0xffffff
            });
            var sphere = new THREE.Mesh(geometry, material)

            // This time we give the sphere random x and y positions between -500 and 500
            sphere.position.x = Math.random() * 1000 - 500;
            sphere.position.y = Math.random() * 1000 - 500;

            // Then set the z position to where it is in the loop (distance of camera)
            sphere.position.z = z;

            // scale it up a bit
            sphere.scale.x = sphere.scale.y = 2;

            //add the sphere to the scene
            scene.add(sphere);

            //finally push it to the stars array 
            stars.push(sphere);
        }
    }

function animateStars() {

        // loop through each star
        for (var i = 0; i < stars.length; i++) {

            star = stars[i];

            // and move it forward dependent on the mouseY position. 
            star.position.z += i / 10;

            // if the particle is too close move it to the back
            if (star.position.z > 1000) star.position.z -= 2000;

        }

    }

function createAsteroidBelt(num=8){
    var astMass = 1000;
   // var astHalfExtents = new THREE.Vector3(.5, 1, 0.07);
   // var astHalfExtents = new THREE.Vector3(1, 1, 1);
    var astHalfExtents = new THREE.Vector3( 2, 2, 2 );

    quat.set(0, 0, 0, 1);
    for (var i = 0; i < num; i++) {


        pos.x = Math.random() * 200 - 100;
        pos.y = Math.random() * 200 - 100;
        pos.z = Math.random() * 200 - 100;

        pos.set(0, 4, -0 * (0.5 - i / (num + 1)));

        pos.set(Math.random() * 60 - 30, 4, -10);

        // createOrb(astMass, astHalfExtents, pos, quat, createMaterial(0xB0B0B0));
        createAsteroid(astMass, astHalfExtents, pos, quat, createMaterial(0x111111));
    }
}

 function createAsteroid(mass, halfExtents, pos, quat, material) {

        var geom = new THREE.BoxGeometry( halfExtents.x * 2, halfExtents.y * 2, halfExtents.z * 2 )
     
     /*   var object = new THREE.Mesh( 
            new THREE.BoxGeometry( halfExtents.x * 2, halfExtents.y * 2, halfExtents.z * 2 ),
             material );
        */
     
     // var geom = new THREE.SphereGeometry(halfExtents.x * 2, 6, 6);

        var numVerts = geom.vertices.length;

        // console.log(numVerts);

        for (var i = 0; i < numVerts; i++) {

            geom.vertices[i].multiplyScalar(Math.random() * 2);

        }
        var object = new THREE.Mesh(geom, material);

        object.name = "asteroid";

        object.position.copy(pos);
        object.quaternion.copy(quat);

        selectedObjects.push(object);

        var direction = camera.position.clone();

        var speed = 5;
        var xpos = direction.x * speed;
        var ypos = direction.y * speed;
        var zpos = direction.z * speed;


        //object.setLinearVelocity(new Ammo.btVector3(xpos, ypos, zpos));
        //var target = camera.position.clone();
        var target = new THREE.Vector3(0, 0, 1);

        var obj = convexBreaker.prepareBreakableObject(object, mass, target, new THREE.Vector3(.2, .4, .3), true);
        createDebrisFromBreakableObject(object);

   

        //console.log(obj)
        /*
                    var camDir = camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(1);
            var camVect = new THREE.Vector3(camDir.x, camDir.y, camDir.z);


            // get mouse position and add some accelerometer
            var vector;
            if (touchEnabled) {
                vector = new THREE.Vector3(-accYsmooth, accZsmooth, -1).unproject(camera);


            } else {

                vector = new THREE.Vector3(-mouse.x * 10, -mouse.y * 10, -1).unproject(camera);
                //  vector = new THREE.Vector3(-mouse.x * 10 - accYsmooth, -mouse.y * 10 + accZsmooth, -1).unproject(camera);
            }

        */
        // var direction = camVect.clone().sub(playerblock.position).add(vector);




    }


function createRigidBody(object, physicsShape, mass, pos, quat, vel, angVel) {

    if (pos) {
        object.position.copy(pos);
    } else {
        pos = object.position;
    }
    if (quat) {
        object.quaternion.copy(quat);
    } else {
        quat = object.quaternion;
    }

    var transform = new Ammo.btTransform();
    transform.setIdentity();
    transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
    transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
    var motionState = new Ammo.btDefaultMotionState(transform);


    //////

    var localInertia = new Ammo.btVector3(0, 0, 0);
    physicsShape.calculateLocalInertia(mass, localInertia);

    var rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, physicsShape, localInertia);
    var body = new Ammo.btRigidBody(rbInfo);


    body.setFriction(0.5);

    if (vel) {
        body.setLinearVelocity(new Ammo.btVector3(vel.x, vel.y, vel.z));
    }
    if (angVel) {
        body.setAngularVelocity(new Ammo.btVector3(angVel.x, angVel.y, angVel.z));
    }

    object.userData.physicsBody = body;
    object.userData.collided = false;
    object.userData.hits= 0;


    scene.add(object);



    if (mass > 0) {
        rigidBodies.push(object);

        // Disable deactivation
        body.setActivationState(4);
    }

    var btVecUserData = new Ammo.btVector3(0, 0, 0);
    btVecUserData.threeObject = object;
    body.setUserPointer(btVecUserData);


    physicsWorld.addRigidBody(body);

    return body;
}

function createRandomColor() {
    return Math.floor(Math.random() * (1 << 24));
}

function createMaterial(color, wire= false, fade=1) {
    color = color || createRandomColor();
    return new THREE.MeshPhongMaterial({
        color: color,
        wireframe: wire,
        transparent:true,
        opacity: fade

    });
}

function initInput() {

    
    document.addEventListener('mousemove', onDocumentMouseMove, false);

    document.addEventListener('keypress', onDocumentKeyPress, false);
    window.addEventListener('touchstart', shoot, false);
    window.addEventListener('mousedown', shoot, false);
    window.addEventListener('touchend', endCounter, false);
    window.addEventListener('mouseup', endCounter, false);


}

function endCounter(){
    pressTimer = false;
    pressCounter = 0;

}

function shoot(e) {
    pressTimer = true;
    if (gameOn == false){
        startGame();
    }else{


        console.log(pressCounter)
        // alert(e)
        //alert(e.type);
        if (e.type == "touchstart") touchEnabled = true;
          e.preventDefault();
        //  e.stopPropagation();

        // console.log(playerBody)

        var dir = Math.random() * 2 - 1;

        var bulletDir = camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(20);
        //  var camVect = new THREE.Vector3(bulletDir.x, controls.userHeight, bulletDir.z);
        var bulletVect = new THREE.Vector3(bulletDir.x, bulletDir.y + controls.userHeight, bulletDir.z);

        var direction = bulletVect.clone().sub(playerblock.position).normalize();
        var length = direction.length();

        //  addArrowHelper(direction, length);

        // Creates a ball and throws it
        var ballMass = 35;
        var ballRadius = 0.4;

        // var ball = new THREE.Mesh(new THREE.SphereGeometry(ballRadius, 14, 10), ballMaterial);
        var ball = new THREE.Mesh(new THREE.SphereGeometry(ballRadius, 10, 10), createMaterial(0x33ffff, false));
        ball.castShadow = true;
        ball.receiveShadow = true;
        ball.name = "bullet";


        var ballShape = new Ammo.btSphereShape(ballRadius);
        ballShape.setMargin(margin);
        // pos.copy(raycaster.ray.direction);
        // pos.add(raycaster.ray.origin);

        pos.copy(direction);
        // pos.add(playerVector);
        pos.add(playerblock.position);


        quat.set(0, 0, 0, 1);
        var ballBody = createRigidBody(ball, ballShape, ballMass, pos, quat);

        ///  playerblock.position.copy(pos)


        // pos.copy(raycaster.ray.direction);
        pos.copy(direction);
        pos.multiplyScalar(30);
        ballBody.setLinearVelocity(new Ammo.btVector3(pos.x, pos.y, pos.z));

        playBlaster();
    }

}

function addArrowHelper(direction, length) {
    var arrowHelper = new THREE.ArrowHelper(direction, playerblock.position, length, 0xff0000);


    arrowHelper.time = lastRender;
    arrowArr.push(arrowHelper);
    scene.add(arrowHelper);
}


function setDebug(bool) {
    debug = bool;
    if (debug == false) {
        info.innerHTML = null;
    }
}


function setStageDimensions(stage) {

    // Place the cube in the middle of the scene, at user height.
    player.position.set(0, controls.userHeight, -1);
}

function updatePhysics( deltaTime ) {

            // Step world
            physicsWorld.stepSimulation( deltaTime, 10 );

            // Update rigid bodies
            for ( var i = 0, il = rigidBodies.length; i < il; i++ ) {
                var objThree = rigidBodies[ i ];
                var objPhys = objThree.userData.physicsBody;
                var ms = objPhys.getMotionState();
                if ( ms ) {

                    ms.getWorldTransform( transformAux1 );
                    var p = transformAux1.getOrigin();
                    var q = transformAux1.getRotation();
                    objThree.position.set( p.x(), p.y(), p.z() );
                    objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );

                    objThree.userData.collided = false;

                }
            }

            for ( var i = 0, il = dispatcher.getNumManifolds(); i < il; i ++ ) {

                var contactManifold = dispatcher.getManifoldByIndexInternal( i );
                var rb0 = contactManifold.getBody0();
                var rb1 = contactManifold.getBody1();

                var threeObject0 = Ammo.castObject( rb0.getUserPointer(), Ammo.btVector3 ).threeObject;
                var threeObject1 = Ammo.castObject( rb1.getUserPointer(), Ammo.btVector3 ).threeObject;

                if ( ! threeObject0 && ! threeObject1 ) {
                    continue;
                }

                var userData0 = threeObject0 ? threeObject0.userData : null;
                var userData1 = threeObject1 ? threeObject1.userData : null;

                var breakable0 = userData0 ? userData0.breakable : false;
                var breakable1 = userData1 ? userData1.breakable : false;

                var collided0 = userData0 ? userData0.collided : false;
                var collided1 = userData1 ? userData1.collided : false;

                if ( ( ! breakable0 && ! breakable1 ) || ( collided0 && collided1 ) ) {
                    continue;
                }

                var contact = false;
                var maxImpulse = 0;
                for ( var j = 0, jl = contactManifold.getNumContacts(); j < jl; j ++ ) {
                    var contactPoint = contactManifold.getContactPoint( j );
                    if ( contactPoint.getDistance() < 0 ) {
                        contact = true;
                        var impulse = contactPoint.getAppliedImpulse();
                        if ( impulse > maxImpulse ) {
                            maxImpulse = impulse;
                            var pos = contactPoint.get_m_positionWorldOnB();
                            var normal = contactPoint.get_m_normalWorldOnB();
                            impactPoint.set( pos.x(), pos.y(), pos.z() );
                            impactNormal.set( normal.x(), normal.y(), normal.z() );
                        }
                        break;
                    }
                }

                // If no point has contact, abort
                if ( ! contact ) {
                    continue;
                }

                // Subdivision

                var fractureImpulse = 250;

               // if ( breakable0 && !collided0 && maxImpulse > fractureImpulse ) {
                if ( breakable0 && !collided0 && maxImpulse>5 ) {
                    if (threeObject0.name=="bullet" || threeObject1.name=="bullet")
                    console.log('-----hit---------')
                    playExplode();
                    console.warn('max:'+maxImpulse+',fracture:'+fractureImpulse)
          

                    var debris = convexBreaker.subdivideByImpact( threeObject0, impactPoint, impactNormal , 1, 2, 1.5 );

                    var numObjects = debris.length;
                    console.log(debris.length)
                    if (debris.length==1){
                        objectsToRemove[ numObjectsToRemove++ ] = debris[0];
                    }else{
                        for ( var j = 0; j < numObjects; j++ ) {

                            console.log('break')
                            console.log(debris[j])
                            createDebrisFromBreakableObject( debris[ j ] );

                        }
                    }
                   // objectsToRemove[ numObjectsToRemove++ ] = threeObject1;

                    objectsToRemove[ numObjectsToRemove++ ] = threeObject0;
                    userData0.collided = true;
                }

               
/*
                if ( breakable1 && !collided1 && maxImpulse > fractureImpulse ) {

                    var debris = convexBreaker.subdivideByImpact( threeObject1, impactPoint, impactNormal , 1, 2, 1.5 );

                    var numObjects = debris.length;
                    for ( var j = 0; j < numObjects; j++ ) {

                        createDebrisFromBreakableObject( debris[ j ] );

                    }

                    objectsToRemove[ numObjectsToRemove++ ] = threeObject1;
                    userData1.collided = true;

                }
*/
            }

            for ( var i = 0; i < numObjectsToRemove; i++ ) {

                removeDebris( objectsToRemove[ i ] );

            }
            numObjectsToRemove = 0;

        }

function testCollisionRules(attacker, victim) {

    // console.log('break it')
    /*      //console.log(contactPoint)
    console.log(attacker.name + " hit " + victim.name);

    console.log(victim)
    console.log(attacker)
    console.log('----------')
*/
    if (attacker.name == "bullet") {
        console.warn(attacker.name + " hit " + victim.name);
    /*    if (victim.name != "ground") {
            victim.material = createMaterial()
            objectsToRemove[numObjectsToRemove++] = victim;
            objectsToRemove[numObjectsToRemove++] = attacker;
            playExplode();
            // addExplosion(victim.position);
            var exp = new Explosion(victim.position);
        }

        objectsToRemove[numObjectsToRemove++] = attacker;
        score++;
        score_display.innerHTML = score;

    } else {
        // console.log(attacker.name + " hit " + victim.name);
    }


    if (victim.name == "player" || attacker.name == "player") {

        
        if (attacker.name != "bullet" && victim.name != "tower" && victim.name != "brick") {
            console.error('OUCH!!!!!')
           // console.log(victim.name)
            console.log(attacker.name + " hit " + victim.name);
            console.log(victim.position)
            objectsToRemove[numObjectsToRemove++] = attacker;
            playArgh();
           // player.animate('fall');
        }
        */
    }
  

 //   attacker.material = createMaterial()


}

 function createParalellepipedWithPhysics(sx, sy, sz, mass, pos, quat, material) {

        var object = new THREE.Mesh(new THREE.BoxGeometry(sx, sy, sz, 1, 1, 1), material);
        var shape = new Ammo.btBoxShape(new Ammo.btVector3(sx * 0.5, sy * 0.5, sz * 0.5));
        shape.setMargin(margin);

        createRigidBody(object, shape, mass, pos, quat);

        return object;

    }

    function createDebrisFromBreakableObject(object) {

        object.castShadow = true;
        object.receiveShadow = true;
        object.name = "asteroid";

        var shape = createConvexHullPhysicsShape(object.geometry.vertices);
        shape.setMargin(margin);

        var body = createRigidBody(object, shape, 100, null, null, object.userData.velocity, object.userData.angularVelocity);

     //   var body = createRigidBody(object, shape, object.userData.mass, null, null, object.userData.velocity, object.userData.angularVelocity);

        selectedObjects.push(object);

        // Set pointer back to the three object only in the debris objects
        var btVecUserData = new Ammo.btVector3(0, 0, 0);
        btVecUserData.threeObject = object;
        body.setUserPointer(btVecUserData);

    }


function removeDebris(object) {

   // console.log(object)

    scene.remove(object);

    physicsWorld.removeRigidBody(object.userData.physicsBody);

}

function createConvexHullPhysicsShape(points) {

        var shape = new Ammo.btConvexHullShape();

        for (var i = 0, il = points.length; i < il; i++) {
            var p = points[i];
            this.tempBtVec3_1.setValue(p.x, p.y, p.z);
            var lastOne = (i === (il - 1));
            shape.addPoint(this.tempBtVec3_1, lastOne);
        }

        return shape;

    }

/*
function removePlayer() {

    //console.log(object)
    alert('removePlayer')

    scene.remove(playerblock);

    physicsWorld.removeRigidBody(playerBody);

}
*/


function TextureAnimator(texture, tilesHoriz, tilesVert, numTiles, tileDispDuration) {
    // note: texture passed by reference, will be updated by the update function.

    this.tilesHorizontal = tilesHoriz;
    this.tilesVertical = tilesVert;
    // how many images does this spritesheet contain?
    //  usually equals tilesHoriz * tilesVert, but not necessarily,
    //  if there at blank tiles at the bottom of the spritesheet. 
    this.numberOfTiles = numTiles;
    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(1 / this.tilesHorizontal, 1 / this.tilesVertical);



    // how long should each image be displayed?
    this.tileDisplayDuration = tileDispDuration;

    // how long has the current image been displayed?
    this.currentDisplayTime = 0;

    // which image is currently being displayed?
    this.currentTile = 0;

    this.animBehavior = false;
    /*
      this.setFrame = function( frame ){
        this.currentTile = frame;
        var currentColumn = this.currentTile % this.tilesHorizontal;
        texture.offset.x = currentColumn / this.tilesHorizontal;

      }
     */

    this.setFrame = function(xpos, ypos, state) {
        this.animBehavior = state;
        // console.log(xpos, ypos)
        var currentColumn = xpos % this.tilesHorizontal;
        texture.offset.x = currentColumn / this.tilesHorizontal;
        var currentRow = ypos % this.tilesVertical;
        //  console.log('currentRow =' + currentRow)
        texture.offset.y = currentRow / this.tilesVertical;

    }

    this.update = function(milliSec) {
        this.currentDisplayTime += milliSec;

        if (this.animBehavior == "once") {
            this.playOnce();
        } else if (this.animBehavior == "loop") {
            this.playLoop();
        }


    };

    this.playOnce = function() {
        while (this.currentDisplayTime > this.tileDisplayDuration) {
            this.currentDisplayTime -= this.tileDisplayDuration;
            if (this.currentTile < this.numberOfTiles - 1) {
                this.currentTile++;
                //   if (this.currentTile == this.numberOfTiles)
                //   this.currentTile = 0;
                var currentColumn = this.currentTile % this.tilesHorizontal;
                texture.offset.x = currentColumn / this.tilesHorizontal;
                //  var currentRow = Math.floor( this.currentTile / this.tilesHorizontal );
                // texture.offset.y = currentRow / this.tilesVertical;
            } else {
                //flash player
                //console.log(this.currentDisplayTime)
                // (Math.floor(this.currentDisplayTime)% 2 == 0)? this.opacity=.2 : this.opacity= 1;
            }
        }
    }

    this.playLoop = function() {
        while (this.currentDisplayTime > this.tileDisplayDuration) {

            this.currentDisplayTime -= this.tileDisplayDuration;
            this.currentTile++;
            if (this.currentTile == this.numberOfTiles)
                this.currentTile = 0;
            var currentColumn = this.currentTile % this.tilesHorizontal;
            texture.offset.x = currentColumn / this.tilesHorizontal;
            //  var currentRow = Math.floor( this.currentTile / this.tilesHorizontal );
            // texture.offset.y = currentRow / this.tilesVertical;
        }
    }



}

function loadFont() {

                var loader = new THREE.FontLoader();
                var typefile = 'fonts/' + fontName + '_' + fontWeight + '.typeface.json';
                console.log(typefile);
                loader.load( typefile, function ( response ) {

                    font = response;

                   // refreshText();

                    //generateLetters();
                    createLetter('V')
                    createLetter('R')

                } );

            }

function createLetter(letter, speed){
                console.log(letter)
                textGeo = new THREE.TextGeometry( letter, {

                    font: font,

                    size: size,
                    height: height,
                    curveSegments: curveSegments,

                    bevelThickness: bevelThickness,
                    bevelSize: bevelSize,
                    bevelEnabled: bevelEnabled,

                    material: 0,
                    extrudeMaterial: 1

                });

                textGeo.computeBoundingBox();
                textGeo.computeVertexNormals();


                var centerOffset = -0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );

              /*  textMesh1 = new THREE.Mesh( textGeo, materials );

                textMesh1.position.x = centerOffset;
               // textMesh1.position.y = hover+ height*8;
               // textMesh1.position.z = 0;

                textMesh1.rotation.x = 0;
                textMesh1.rotation.y = Math.PI * 2;
                */
                var xpos;
                if(letter=='R') {
                        xpos = .45; 
                    }else{
                        xpos=.1;
                    }

                var letter = new THREE.Mesh( textGeo, createMaterial( 0x333333 ) );
                letterArr.push(letter);

                scene.add(letter);

              //  selectedObjects.push(letter)
                
                    console.log(xpos)
                    letter.position.x = Math.random()*4- 2;
                    letter.position.y = Math.random()*8 - 4;
                    letter.position.z = Math.random()*20;

                    letter.rotation.x = (Math.PI/180)*(Math.random()*180);
                    letter.rotation.y = (Math.PI/180)*(Math.random()*180);
                    letter.rotation.z = (Math.PI/180)*(Math.random()*180);

                    letter.scale.set(.005,.005,.005)

                    var dur;
                    if (speed){
                        dur = speed;
                    }else{
                        dur = 1+ Math.random()*10;
                    }
                    var delay = Math.random();
                    dur = 1;

                    

                    TweenMax.to(letter.position, dur,{
                       // z:depth,
                        x:xpos,
                        y:1.1,
                        z:-2,
                        delay: 1,//delay,
                        ease:"Power3.easeOut",
                        onUpdate:function(){
                           // no_geom.verticesNeedUpdate = true;
                            
                      //  console.log('tweened');
                    }});

                    TweenMax.to(letter.rotation, dur,{
                       // z:depth,
                        x:0,
                        y:0,
                        z:0,
                        delay: 1,//delay,
                        ease:"Power3.easeOut",
                        onUpdate:function(){
                           // no_geom.verticesNeedUpdate = true;
                            
                      //  console.log('tweened');
                    }});
                  
            }

function cleanupPhysics(){

     for (var i = 0; i < rigidBodies.length; i++) {

        removeDebris(rigidBodies[i]);

    }
    rigidBodies = [];
    
}

function startGame(){
    gameOn = true;
   // playGetReady()
    addPlayer();
    createObjects();
    
   // document.getElementById('intro').style.display = "none";
    removeTitleScreen();
  //  player.animate('fly');
 

}

function resetGame(){
    gameOn = false;
  //  console.log(rigidBodies.length)
    cleanupPhysics();
    scene.remove(pivot);
   // camera.rotation.set(0,0,0)
   // document.getElementById('intro').style.display = "flex";
    createTitleScreen();
   // console.log(physicsWorld)
}

loadBkgdMusic();

//playBkgdMusic();
loadBlaster();
loadExplode();
init();
initPhysics();
initInput();
//createGround();
/*
addPlayer();
createObjects();
initInput();
*/

//addExplosion();

document.getElementById('reset').addEventListener('click', resetGame, false)

//
</script>

</html>
