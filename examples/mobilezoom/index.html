<!DOCTYPE html>
<html lang="en">
	<head>
		<title>hammer</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #fff;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;

				background-color: #fff;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				color:#000;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;

			}

			a {
				color: red;
			}


		</style>
	</head>

	<body>
		<div id="container"></div>
		<div id="info"></div>

		<script src="../../bower_components/jquery/dist/jquery.min.js"></script>
		<script src="../../bower_components/gsap/src/minified/TweenMax.min.js"></script>
		<script src="../../bower_components/three.js/build/three.js"></script>
		<script src="../../bower_components/three.js/examples/js/Detector.js"></script>
		<!--<script src="../../bower_components/three.js/examples/js/controls/TrackballControls.js"></script>-->
		<script src="../../bower_components/three.js/examples/js/libs/stats.min.js"></script>

		<script src="../../bower_components/hammerjs/hammer.js"></script>

		<script>
			var xpos = 0;
			var ypos = 0;

			var panelWidth = window.innerWidth;
			var panelHeight = window.innerHeight -35;
			
			var initZ = panelWidth;//window.screen.availWidth;
			//alert(initZ)
			var zpos = initZ;
			var maxZ = initZ+1400;
			//var initPan = 10;
			//var maxPan = 100;
			//var panInc = 10;
			var state = "ColumnView";
			var objects = [];
			
			var initPan = panelWidth;
			var panInc = 1;

			var panVert = panelHeight;
			var panHoriz = panelWidth;

			var gesture;

			var materialArr = [];
			var imgArrIdx = 0;
			var textureLoader;
			var raycaster;
			var mouse = new THREE.Vector2(), INTERSECTED;
			var objects = [];
			var activePanel;
			var enablePan = true;


			var imgArr = [
				"image1.jpg",
				"image2.jpg",
				"image3.jpg",
				"image4.jpg",
				"image5.jpg",
				"image6.jpg",
				"image7.jpg",
				"image8.jpg",
				"image9.jpg",
				"image10.jpg",
				"image11.jpg"
			]


		

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;

			var camera, controls, scene, renderer;

			var cross;

			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = initZ;//500;
/*
				controls = new THREE.TrackballControls( camera );

				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;

				controls.noZoom = false;
				controls.noPan = false;

				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;

				controls.keys = [ 65, 83, 68 ];

				controls.addEventListener( 'change', render );
*/
				// world

				scene = new THREE.Scene();
				//scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );
/*
				//var geometry = new THREE.CylinderGeometry( 0, 10, 30, 4, 1 );
				var geometry = new THREE.PlaneBufferGeometry( 20, 20 );
				var material =  new THREE.MeshPhongMaterial( { color:0xff0000, shading: THREE.FlatShading } );

				for ( var i = 0; i < 500; i ++ ) {

					var mesh = new THREE.Mesh( geometry, material );
					mesh.position.x = ( Math.random() - 0.5 ) * 1000;
					mesh.position.y = ( Math.random() - 0.5 ) * 1000;
					mesh.position.z = ( Math.random() - 0.5 ) * 1000;
					mesh.updateMatrix();
					mesh.matrixAutoUpdate = false;
					scene.add( mesh );

				}
*/

				
				var manager = new THREE.LoadingManager();
				manager.onProgress = function ( item, loaded, total ) {
				 // progressBar.style.width = (loaded / total * 100) + '%';
				 	console.log(item, loaded, total);
				};

				manager.onLoad = function (){
					console.log('all items loaded');
					if (imgArrIdx < imgArr.length) {
						loadImages();
					}else{
						createGridWall();
					}
				}

				manager.onError = function (){
					console.log('loading error');
				}


				// create a loader to get an image from a URL
				textureLoader = new THREE.TextureLoader(manager);
				// we've gotta set this to use cross-origin images
				textureLoader.crossOrigin = true;

				// load in the image
				
				loadImages();


				//createGridWall();
/*
				var grid = new THREE.GridHelper(100, 10);
		        scene.add(grid);
*/
				var axis = new THREE.AxisHelper(75);
    			scene.add(axis);  

				// lights

				light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 1, 1, 1 );
				scene.add( light );

				light = new THREE.DirectionalLight( 0x002288 );
				light.position.set( -1, -1, -1 );
				scene.add( light );

				light = new THREE.AmbientLight( 0x222222 );
				scene.add( light );


				// renderer

				renderer = new THREE.WebGLRenderer( { antialias: false } );
				renderer.setClearColor( 0xffffff );
				//renderer.setClearColor( scene.fog.color );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );

				stats = new Stats();
				container.appendChild( stats.dom );


				raycaster = new THREE.Raycaster();
/*
				TweenMax.to(camera.position ,2,{
					x:xpos,
					y:ypos,
					z:initZ,
					ease:"Power3.easeOut",
					//ease: Elastic.easeOut.config(2, 0.5),
					onInit:function(){
                  	 // console.log('start tween '+ xpos);
	                }
	            });
	            */

				//
				document.addEventListener( 'touchmove', onTouchMove, false );
				document.addEventListener( 'touchstart', onTouchStart, false );
				document.addEventListener( 'touchend', onTouchEnd, false );

				document.addEventListener( 'mousemove', onMouseMove, false );
				document.addEventListener( 'mousedown', onMouseDown, false );
				document.addEventListener( 'mouseup', onMouseUp, false );

				window.addEventListener( 'resize', onWindowResize, false );
				//

				render();

			}

			function loadImages(){
				
				textureLoader.load("images/"+imgArr[imgArrIdx], function(texture) {
				  // this code makes the texture repeat
				//  texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
				//  texture.repeat.set( 10, 10 );
				  // set the texture as the map for the material
				//  materialOne = texture;//new THREE.MeshLambertMaterial( {map: texture, side:THREE.DoubleSide } );

				  var repeatX, repeatY;
					texture.wrapS = THREE.ClampToEdgeWrapping;
					texture.wrapT = THREE.RepeatWrapping;
					//repeatX = panelWidth * textureSetting.h / (panelHeight * textureSetting.w);
					repeatX = panelWidth * 520 / (panelHeight * 311);
					repeatY = 1;
					texture.repeat.set(repeatX, repeatY);
					texture.offset.x = (repeatX - 1) / 2 * -1;
					//texture.offset.y=(repeatY) / 2 -.4;

				  materialArr.push(texture);
				  console.log("materialArr="+materialArr);
				  imgArrIdx++;
				


				
				 })
			}

			function createGridWall(){
				//var geometry = new THREE.BoxBufferGeometry( 20, 20, 20 );
					//var geometry = new THREE.PlaneBufferGeometry( 10, 10, 5 );
					var geometry = new THREE.PlaneBufferGeometry( panelWidth, panelHeight, 5 );
					//var geometry = new THREE.PlaneGeometry( 10, 10, 5 );

					//var objWidth = 10;
					var maxRow = 10;
					var maxCol = 8;
					var hspacing = panelWidth;//+10;
					var vspacing = panelHeight;//+10;
					var xoffset = - panelWidth/2;//((objWidth + hspacing)* maxRow)/2;
					var yoffset = 0;//- panelHeight/2;




					for (var i = 0; i < maxRow; i++) {
					     for (var j = 0; j < maxCol; j++) {
					      //	var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff, side: THREE.DoubleSide } ) );

					        
					      	var object = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( {map: materialArr[(i+j)%imgArr.length], side:THREE.DoubleSide } ));

					      	object.doubleSided = true;
					      	object.geometry.computeBoundingSphere(); // this isn't calculated automatically
							object.geometry.boundingSphere.center;

							object.material.fog = false;

							var xpos = ((hspacing * j) - hspacing/2) - xoffset;
							var ypos = (vspacing  * i)  - ((vspacing/2)*maxRow) - yoffset;
							//var zpos = Math.random() * 400 - 200;

							object.position.x = xpos;
							console.log(xpos+","+ypos);
							object.position.y = ypos;
							object.position.z = 0;
							object.origin = [xpos, ypos];
							scene.add( object );
							objects.push( object );
					     }
					 }


					// particleMaterial = new THREE.SpriteMaterial( { color: 0x0f0f0f, fog: true } );
			}

			function onMouseMove( event ) {

				event.preventDefault();

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				console.log(mouse.x)

			}

			function onTouchMove( event ) {

				event.preventDefault();

				mouse.x = ( event.touches[ 0 ].clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.touches[ 0 ].clientY / window.innerHeight ) * 2 + 1;

				console.log(mouse.x)

			}

			function onMouseDown( event ) {

				event.preventDefault();

			//	console.log(THREE.Vector3( 0, 0, -1 ).applyQuaternion( camera.quaternion ).add( camera.position ));

				mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

				raycaster.setFromCamera( mouse, camera );

				vector = new THREE.Vector3( 0, 0, -1 );
				vector.applyQuaternion( camera.quaternion ).add( camera.position );

				console.log(vector);

				scaledVector=vector.clone().multiplyScalar(0.95);

				console.log("scaled:"+scaledVector.y);

				var intersects = raycaster.intersectObjects( objects );

				if ( intersects.length > 0 ) {

					if (activePanel == intersects[ 0 ].object){
						activePanel = null;
						
						TweenMax.to(camera.position, 1, {
							x:intersects[0].object.origin[0],
							y:intersects[0].object.origin[1],
							z:0,
							delay: 0,
							//ease:"Power3.easeOut",
							ease: Back.easeInOut.config(.5),
							onUpdate:function(){
	                      //  console.log('tweened');

	                    	}
						});
						/*

						TweenMax.to(intersects[0].object.rotation, 1, {
							x:0,
							y:0,
							z:0,
							delay: 0,
							//ease:"Power3.easeOut",
							ease: Back.easeInOut.config(.5),
							onUpdate:function(){
	                      //  console.log('tweened');
	                    	}
						});
						*/

					}else{
						activePanel = intersects[ 0 ].object;
					}

					intersects[ 0 ].object.material.color.setHex( 0xe02323 );

					var newSphereGeom= new THREE.SphereGeometry(.5,.5,.5);
					var sphere= new THREE.Mesh(newSphereGeom, new THREE.MeshBasicMaterial({ color: 0x2266dd }));

					sphere.position.copy( intersects[ 0 ].point );
					sphere.scale.x = sphere.scale.y = 1;
					scene.add( sphere );

					//drawRayLine( raycaster );


				}

			}

			function onTouchStart( event ) {

				event.preventDefault();

			//	console.log(THREE.Vector3( 0, 0, -1 ).applyQuaternion( camera.quaternion ).add( camera.position ));

				mouse.x = ( event.touches[ 0 ].clientX / renderer.domElement.clientWidth ) * 2 - 1;
				mouse.y = - ( event.touches[ 0 ].clientY / renderer.domElement.clientHeight ) * 2 + 1;

				raycaster.setFromCamera( mouse, camera );

				vector = new THREE.Vector3( 0, 0, -1 );
				vector.applyQuaternion( camera.quaternion ).add( camera.position );

				console.log(vector);

				scaledVector=vector.clone().multiplyScalar(0.95);

				console.log("scaled:"+scaledVector.y);

				var intersects = raycaster.intersectObjects( objects );

				if ( intersects.length > 0 ) {

					if (activePanel == intersects[ 0 ].object){
						activePanel = null;
						
						TweenMax.to(camera.position, 1, {
							x:intersects[0].object.origin[0],
							y:intersects[0].object.origin[1],
							z:0,
							delay: 0,
							//ease:"Power3.easeOut",
							ease: Back.easeInOut.config(.5),
							onUpdate:function(){
	                      //  console.log('tweened');

	                    	}
						});
						/*
						TweenMax.to(intersects[0].object.rotation, 1, {
							x:0,
							y:0,
							z:0,
							delay: 0,
							//ease:"Power3.easeOut",
							ease: Back.easeInOut.config(.5),
							onUpdate:function(){
	                      //  console.log('tweened');
	                    	}
						});
						*/

					}else{
						activePanel = intersects[ 0 ].object;
					}

					intersects[ 0 ].object.material.color.setHex( 0xe02323 );

					var newSphereGeom= new THREE.SphereGeometry(.5,.5,.5);
					var sphere= new THREE.Mesh(newSphereGeom, new THREE.MeshBasicMaterial({ color: 0x2266dd }));

					sphere.position.copy( intersects[ 0 ].point );
					sphere.scale.x = sphere.scale.y = 1;
					scene.add( sphere );

					//drawRayLine( raycaster );


				}

			}

			function onMouseUp( event ) {

				event.preventDefault();
				if (activePanel){
					activePanel.material.color.setHex( 0xffffff);

				}

			}

			function onTouchEnd( event ) {

				event.preventDefault();
				if (activePanel){
					activePanel.material.color.setHex( 0xffffff);

				}

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			//	controls.handleResize();

				render();

			}

			function animate() {

				
				render();
				requestAnimationFrame( animate );
				//controls.update();

			}

			function render() {

				renderer.render( scene, camera );
				stats.update();

			}

			var myElement = document.getElementById('container');

			// create a simple instance
			// by default, it only adds horizontal recognizers
			//var mc = new Hammer(myElement);
			var mc = new Hammer.Manager(myElement);

			var pinch = new Hammer.Pinch();
			var pan = new Hammer.Pan();
			var press = new Hammer.Press();
			var tap = new Hammer.Tap({
			  taps: 1
			});

			pinch.recognizeWith([pan]);

			// add to the Manager
			mc.add([pinch, pan, tap, press]);

			// let the pan gesture support all directions.
			// this will block the vertical scrolling on a touch-device while on the element
			mc.get('pan').set({ direction: Hammer.DIRECTION_ALL });

			mc.on("panend", function(ev) {
			    info.textContent = gesture;//ev.type +" gesture detected.";
			    if (enablePan) moveCamera(gesture);
			});

			// listen to events...
			mc.on("panleft panright panup pandown", function(ev) {
				gesture = ev.type;
			   // info.textContent = ev.type +" gesture detected.";
			   // moveCamera(ev.type);
			});

			mc.on("tap", function(ev) {
			    info.textContent = ev.type +" gesture detected.";
			    state = 'ColumnView';
			    panInc = 1;
			   // console.log("activePanel.position.x="+activePanel.position.x)
			    zoomCamera(activePanel.position.x, activePanel.position.y, initZ);
			});

			mc.on("pinch press", function(ev) {
			    info.textContent += ev.type +" ";
			    state = 'GridView';
			    panInc = 3;
			    enablePan=false;
			    zoomCamera(xpos, ypos, maxZ);
			});

			function moveCamera(gesture){
				console.log(gesture)
				if (gesture == 'panleft'){
					xpos += panHoriz *panInc;

				} else if (gesture == 'panright') {
					xpos -= panHoriz*panInc;
				} else if (gesture == 'panup') {
					ypos -= panVert*panInc;
				} else if (gesture == 'pandown') {
					ypos += panVert*panInc;
				} 


				TweenMax.to(camera.position ,.5,{
					x:xpos,
					y:ypos,
					z:zpos,
					ease:"Power3.easeOut",
					onInit:function(){
                  	  console.log('start tween '+ xpos);
	                }
	            });
			}

			function zoomCamera(x,y,z){
				xpos=x;
				ypos=y;
				zpos=z;
				

				TweenMax.to(camera.position ,.5,{
					x:xpos,
					y:ypos,
					z:zpos,
					ease:"Power3.easeOut",
					//ease: Elastic.easeOut.config(2, 0.5),
					onComplete:function(){
                  	  if (z==maxZ) enablePan=true;
	                }
	            });
			}
		

		</script>

	</body>
</html>