<!DOCTYPE html>
<html lang="en">
	<head>
		<title>hammer</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #fff;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;

				background-color: #fff;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				color:#fff;
				background-color: black;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;

			}

			a {
				color: red;
			}


		</style>
	</head>

	<body>
		<div id="container"></div>
		<div id="info"></div>

		<script src="../../bower_components/jquery/dist/jquery.min.js"></script>
		<script src="../../bower_components/gsap/src/minified/TweenMax.min.js"></script>
		<script src="../../bower_components/three.js/build/three.js"></script>
		<script src="../../bower_components/three.js/examples/js/Detector.js"></script>
		<!--<script src="../../bower_components/three.js/examples/js/controls/TrackballControls.js"></script>-->
		<script src="../../bower_components/three.js/examples/js/libs/stats.min.js"></script>

		<script src="../../bower_components/hammerjs/hammer.js"></script>

		<script>
			var xpos = 0;
			var ypos = 0;
			var maxRow = 10;
			var maxCol = 8;

			var panelWidth = window.innerWidth;
			var panelHeight = window.innerHeight -35;
			
			var initZ = panelWidth;//+1200;//+1400;//+200;//window.screen.availWidth;
			//alert(initZ)
			var zpos = initZ;
			var maxZ = initZ+1400;
			//var initPan = 10;
			//var maxPan = 100;
			//var panInc = 10;
			var state = "ColumnView";
			var objects = [];
			
			var initPan = panelWidth;
			var panInc = 1;

			var panVert = panelHeight;
			var panHoriz = panelWidth;

			var gesture;

			var materialArr = [];
			var imgArrIdx = 0;
			var textureLoader;
			var raycaster;
			var mouse = new THREE.Vector2(), INTERSECTED;
			var objects = [];
			var pickedPanel;
			var activeCol = 1;
			var activeRow = 1;
			var enablePan = true;
			var groupArr = [];

		
			var focusTile = 1;


			var imgArr = [
				"image1.jpg",
				"image2.jpg",
				"image3.jpg",
				"image4.jpg",
				"image5.jpg",
				"image6.jpg",
				"image7.jpg",
				"image8.jpg",
				"image9.jpg",
				"image10.jpg",
				"image11.jpg"
			]


		

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;

			var camera, controls, scene, renderer;

			var cross;

			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = initZ;//500;
/*
				controls = new THREE.TrackballControls( camera );

				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;

				controls.noZoom = false;
				controls.noPan = false;

				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;

				controls.keys = [ 65, 83, 68 ];

				controls.addEventListener( 'change', render );
*/
				// world

				scene = new THREE.Scene();
				//scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );
/*
				//var geometry = new THREE.CylinderGeometry( 0, 10, 30, 4, 1 );
				var geometry = new THREE.PlaneBufferGeometry( 20, 20 );
				var material =  new THREE.MeshPhongMaterial( { color:0xff0000, shading: THREE.FlatShading } );

				for ( var i = 0; i < 500; i ++ ) {

					var mesh = new THREE.Mesh( geometry, material );
					mesh.position.x = ( Math.random() - 0.5 ) * 1000;
					mesh.position.y = ( Math.random() - 0.5 ) * 1000;
					mesh.position.z = ( Math.random() - 0.5 ) * 1000;
					mesh.updateMatrix();
					mesh.matrixAutoUpdate = false;
					scene.add( mesh );

				}
*/

				
				var manager = new THREE.LoadingManager();
				manager.onProgress = function ( item, loaded, total ) {
				 // progressBar.style.width = (loaded / total * 100) + '%';
				 	console.log(item, loaded, total);
				};

				manager.onLoad = function (){
					console.log('all items loaded');
					if (imgArrIdx < imgArr.length) {
						loadImages();
					}else{
						//createGridWall();
						//createGridColumns();
						createGridWall2();
					}
				}

				manager.onError = function (){
					console.log('loading error');
				}


				// create a loader to get an image from a URL
				textureLoader = new THREE.TextureLoader(manager);
				// we've gotta set this to use cross-origin images
				textureLoader.crossOrigin = true;

				// load in the image
				
				loadImages();


				//createGridWall();

				var grid = new THREE.GridHelper(100, 10);
		        scene.add(grid);

				var axis = new THREE.AxisHelper(100);
    			scene.add(axis);  

				// lights

				light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 1, 1, 1 );
				scene.add( light );

				light = new THREE.DirectionalLight( 0x002288 );
				light.position.set( -1, -1, -1 );
				scene.add( light );

				light = new THREE.AmbientLight( 0x222222 );
				scene.add( light );


				// renderer

				renderer = new THREE.WebGLRenderer( { antialias: false } );
				renderer.setClearColor( 0xffffff );
				//renderer.setClearColor( scene.fog.color );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );

				stats = new Stats();
				container.appendChild( stats.dom );


				raycaster = new THREE.Raycaster();

				getCameraFocus();
/*
				TweenMax.to(camera.position ,2,{
					x:xpos,
					y:ypos,
					z:initZ,
					ease:"Power3.easeOut",
					//ease: Elastic.easeOut.config(2, 0.5),
					onInit:function(){
                  	 // console.log('start tween '+ xpos);
	                }
	            });
	            */

				//
				document.addEventListener( 'touchmove', onTouchMove, false );
				document.addEventListener( 'touchstart', onTouchStart, false );
				document.addEventListener( 'touchend', onTouchEnd, false );

				document.addEventListener( 'mousemove', onMouseMove, false );
				document.addEventListener( 'mousedown', onMouseDown, false );
				document.addEventListener( 'mouseup', onMouseUp, false );

				window.addEventListener( 'resize', onWindowResize, false );
				//

				render();

			}

			function loadImages(){
				
				textureLoader.load("images/"+imgArr[imgArrIdx], function(texture) {
				  // this code makes the texture repeat
				//  texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
				//  texture.repeat.set( 10, 10 );
				  // set the texture as the map for the material
				//  materialOne = texture;//new THREE.MeshLambertMaterial( {map: texture, side:THREE.DoubleSide } );

				  var repeatX, repeatY;
					texture.wrapS = THREE.ClampToEdgeWrapping;
					texture.wrapT = THREE.RepeatWrapping;
					//repeatX = panelWidth * textureSetting.h / (panelHeight * textureSetting.w);
					repeatX = panelWidth * 520 / (panelHeight * 311);
					repeatY = 1;
					texture.repeat.set(repeatX, repeatY);
					texture.offset.x = (repeatX - 1) / 2 * -1;
					//texture.offset.y=(repeatY) / 2 -.4;

				  materialArr.push(texture);
				  console.log("materialArr="+materialArr);
				  imgArrIdx++;
				


				
				 })
			}

			function createGridWall(){
				//var geometry = new THREE.BoxBufferGeometry( 20, 20, 20 );
					//var geometry = new THREE.PlaneBufferGeometry( 10, 10, 5 );
					var geometry = new THREE.PlaneBufferGeometry( panelWidth, panelHeight, 5 );
					//var geometry = new THREE.PlaneGeometry( 10, 10, 5 );

					//var objWidth = 10;
					var maxRow = 10;
					var maxCol = 8;
					var hspacing = panelWidth;//+10;
					var vspacing = panelHeight;//+10;
					var xoffset =  panelWidth/2;//((objWidth + hspacing)* maxRow)/2;
					var yoffset = 0;//- panelHeight/2;




					for (var i = 0; i < maxRow; i++) {
					     for (var j = 0; j < maxCol; j++) {
					      //	var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff, side: THREE.DoubleSide } ) );
					      	if(i==0){
					      		var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff, side: THREE.DoubleSide } ) );
					      	}else{
					      		var object = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( {map: materialArr[(i+j)%imgArr.length], side:THREE.DoubleSide } ));
					      	}
					        
					      	

					      	object.doubleSided = true;
					      	object.geometry.computeBoundingSphere(); // this isn't calculated automatically
							object.geometry.boundingSphere.center;
							object.material.transparent = true

							object.material.fog = false;

							var xpos = ((hspacing * j) - hspacing/2) - xoffset;
							var ypos = (vspacing  * i)  - ((vspacing/2)*maxRow) - yoffset;
							//var zpos = Math.random() * 400 - 200;

							object.position.x = xpos;
							console.log(xpos+","+ypos);
							object.position.y = ypos;
							object.position.z = 0;
							object.origin = [xpos, ypos];
							scene.add( object );
							objects.push( object );
					     }
					    
					 }


					// particleMaterial = new THREE.SpriteMaterial( { color: 0x0f0f0f, fog: true } );
			}


			function createGridWall2(){
				//var geometry = new THREE.BoxBufferGeometry( 20, 20, 20 );
					//var geometry = new THREE.PlaneBufferGeometry( 10, 10, 5 );
					var geometry = new THREE.PlaneBufferGeometry( panelWidth, panelHeight, 5 );
					//var geometry = new THREE.PlaneGeometry( 10, 10, 5 );

					//var objWidth = 10;
					
					var hspacing = panelWidth;//+10;
					var vspacing = panelHeight;//+10;
					var xoffset =  panelWidth/2;//((objWidth + hspacing)* maxRow)/2;
					var yoffset = panelHeight/2;//- panelHeight/2;




					for (var i = 0; i < maxCol; i++) {

						var group = new THREE.Group();
						group.name = "col"+i;
						scene.add( group );
						var xpos = hspacing*i;
						group.position.x =xpos;
							group.position.y = 0;
							group.position.z = 0;
							
							 
						//console.log(group.name +" x:"+group.position.x)
						

					     for (var j = 0; j < maxRow; j++) {
					      //	var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff, side: THREE.DoubleSide } ) );
					      	if(j==0){
					      		var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff, side: THREE.DoubleSide } ) );
					      	}else{
					      		var object = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( {map: materialArr[(i+j)%imgArr.length], side:THREE.DoubleSide } ));
					      	}
					        
					      	

					      	object.doubleSided = true;
					      	object.geometry.computeBoundingSphere(); // this isn't calculated automatically
							object.geometry.boundingSphere.center;
							object.material.transparent = true

							object.material.fog = false;

							//var xpos = ((hspacing * j));// - hspacing/2) - xoffset;
							var ypos = (-vspacing  * j);// - ((vspacing/2)*maxRow) + yoffset;
							//var zpos = Math.random() * 400 - 200;

							

							object.position.x = 0;//xpos;
							object.position.y = ypos;
							object.position.z = 0;
							object.origin = [xpos, ypos];
							group.add(object);
							console.log(group.name +" x:"+group.position.x)
							//scene.add( object );
							objects.push( object );
					     }
					  	 scene.add( group );  
					  	 groupArr.push(group);
					 }


					// particleMaterial = new THREE.SpriteMaterial( { color: 0x0f0f0f, fog: true } );
			}


			function createGridColumns(){
				//var geometry = new THREE.BoxBufferGeometry( 20, 20, 20 );
					//var geometry = new THREE.PlaneBufferGeometry( 10, 10, 5 );
					var geometry = new THREE.PlaneBufferGeometry( panelWidth, panelHeight, 5 );
					//var geometry = new THREE.PlaneGeometry( 10, 10, 5 );

					//var objWidth = 10;
					var maxRow = 10;
					var maxCol = 8;
					var hspacing = panelWidth;//+10;
					var vspacing = panelHeight;//+10;
					var xoffset =  panelWidth/2;//((objWidth + hspacing)* maxRow)/2;
					var yoffset = 0;//- panelHeight/2;




					for (var i = 0; i < maxCol; i++) {
						var group = new THREE.Group();
						group.name = "col"+i;
						console.log(group.name)
						group.position.x = 0;//hspacing*i;
							group.position.y = 0;
							group.position.z = 0;


					     for (var j = 0; j < maxRow; j++) {
					      //	var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff, side: THREE.DoubleSide } ) );
					      	if(i==maxCol-1){
					      		var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff, side: THREE.DoubleSide } ) );
					      	}else{
					      		var object = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( {map: materialArr[(i+j)%imgArr.length], side:THREE.DoubleSide } ));
					      	}
					        
					      	

					      	object.doubleSided = true;
					      	object.geometry.computeBoundingSphere(); // this isn't calculated automatically
							object.geometry.boundingSphere.center;
							object.material.transparent = true

							object.material.fog = false;

							var xpos = ((hspacing * j) - hspacing/2) - xoffset;
							var ypos = (vspacing  * i)  - ((vspacing/2)*maxRow) - yoffset;
							//var zpos = Math.random() * 400 - 200;

							

							object.position.x = xpos;
							object.position.y = 0;//ypos;
							object.position.z = 0;
							object.origin = [xpos, ypos];
							group.add(object);
							//scene.add( object );
							objects.push( object );
					     }
					  	 scene.add( group );   
					 }


					// particleMaterial = new THREE.SpriteMaterial( { color: 0x0f0f0f, fog: true } );
			}



			function onMouseMove( event ) {

				event.preventDefault();

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				//console.log(mouse.x)

			}

			function onTouchMove( event ) {

				event.preventDefault();

				mouse.x = ( event.touches[ 0 ].clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.touches[ 0 ].clientY / window.innerHeight ) * 2 + 1;

				//console.log(mouse.x)

			}

			function onMouseDown( event ) {

				event.preventDefault();

			//	console.log(THREE.Vector3( 0, 0, -1 ).applyQuaternion( camera.quaternion ).add( camera.position ));

				mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

				raycaster.setFromCamera( mouse, camera );

				//vector = new THREE.Vector3( 0, 0, -1 );
				//vector.applyQuaternion( camera.quaternion ).add( camera.position );

				var intersects = raycaster.intersectObjects( objects );

				if ( intersects.length > 0 ) {

					if (pickedPanel == intersects[ 0 ].object){

						pickedPanel = null;

						console.log(intersects[0].object.origin[0])

						
						TweenMax.to(camera.position, 1, {
							x:intersects[0].object.origin[0],
							y:intersects[0].object.origin[1],
							z:0,
							delay: 0,
							//ease:"Power3.easeOut",
							ease: Back.easeInOut.config(.5),
							onUpdate:function(){
	                      //  console.log('tweened');

	                    	}
						});
						/*

						TweenMax.to(intersects[0].object.rotation, 1, {
							x:0,
							y:0,
							z:0,
							delay: 0,
							//ease:"Power3.easeOut",
							ease: Back.easeInOut.config(.5),
							onUpdate:function(){
	                      //  console.log('tweened');
	                    	}
						});
						*/

					}else{
						pickedPanel = intersects[ 0 ].object;
						//INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
					}

					//intersects[ 0 ].object.material.color.setHex( 0xe02323 );
					//intersects[ 0 ].object.material.color = new THREE.Color(0,1,0,.3)

					/*
					TweenMax.to(intersects[ 0 ].object.material.color, 10,{
						r: 10, 
						g: 0, 
						b: 0,
						delay: 0,
						//yoyo:true,
						//repeat: 1,
						ease:"Power3.easeOut",
						onComplete:function(){
	                       console.log('tweened');
	                    }
					 });
					 */
					

					TweenMax.to(intersects[ 0 ].object.material, .3, {
						opacity: 0.75,
						ease:"Power3.easeOut",
						onComplete:function(){
	                      // console.log('tweened');
	                    }
					});

					


				}

			}

			function onTouchStart( event ) {

				event.preventDefault();

			//	console.log(THREE.Vector3( 0, 0, -1 ).applyQuaternion( camera.quaternion ).add( camera.position ));

				mouse.x = ( event.touches[ 0 ].clientX / renderer.domElement.clientWidth ) * 2 - 1;
				mouse.y = - ( event.touches[ 0 ].clientY / renderer.domElement.clientHeight ) * 2 + 1;

				raycaster.setFromCamera( mouse, camera );

			//	vector = new THREE.Vector3( 0, 0, -1 );
			//	vector.applyQuaternion( camera.quaternion ).add( camera.position );

				var intersects = raycaster.intersectObjects( objects );

				if ( intersects.length > 0 ) {

					if (pickedPanel == intersects[ 0 ].object){
						pickedPanel = null;
						
						TweenMax.to(camera.position, 1, {
							x:intersects[0].object.origin[0],
							y:intersects[0].object.origin[1],
							z:0,
							delay: 0,
							//ease:"Power3.easeOut",
							ease: Back.easeInOut.config(.5),
							onUpdate:function(){
	                      //  console.log('tweened');

	                    	}
						});
						/*
						TweenMax.to(intersects[0].object.rotation, 1, {
							x:0,
							y:0,
							z:0,
							delay: 0,
							//ease:"Power3.easeOut",
							ease: Back.easeInOut.config(.5),
							onUpdate:function(){
	                      //  console.log('tweened');
	                    	}
						});
						*/

					}else{
						pickedPanel = intersects[ 0 ].object;
					}

					//intersects[ 0 ].object.material.color.setHex( 0xe02323 );

					TweenMax.to(intersects[ 0 ].object.material, .3, {
						opacity: 0.5,
						ease:"Power3.easeOut",
						onComplete:function(){
	                       console.log('tweened');
	                    }
					});

				}

			}

			function onMouseUp( event ) {

				event.preventDefault();
				if (pickedPanel){
					//pickedPanel.material.color.setHex( 0xffffff);
					//TweenMax.reverse()
				/*	TweenMax.to(pickedPanel.material.color, 200,{
						r: 255, 
						g: 255, 
						b: 255,
						delay: 0,
						ease:"Power3.easeOut"
					 });
				*/
					TweenMax.to(pickedPanel.material, .3, {
						opacity: 1,
						ease:"Power3.easeOut",
						onComplete:function(){
	                       console.log('tweened');
	                    }
					});

				}

			}

			function onTouchEnd( event ) {

				event.preventDefault();
				if (pickedPanel){
					//pickedPanel.material.color.setHex( 0xffffff);
					TweenMax.to(pickedPanel.material, .3, {
						opacity: 1,
						ease:"Power3.easeOut",
						onComplete:function(){
	                       console.log('tweened');
	                    }
					});

				}

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			//	controls.handleResize();

				render();

			}

			function animate() {

				
				render();
				requestAnimationFrame( animate );
				//controls.update();

			}

			function render() {

				renderer.render( scene, camera );
				stats.update();

			}

			var myElement = document.getElementById('container');

			// create a simple instance
			// by default, it only adds horizontal recognizers
			//var mc = new Hammer(myElement);
			var mc = new Hammer.Manager(myElement);

			var pinch = new Hammer.Pinch();
			var pan = new Hammer.Pan();
			var press = new Hammer.Press();
			var tap = new Hammer.Tap({
			  taps: 1
			});

			pinch.recognizeWith([pan]);

			// add to the Manager
			mc.add([pinch, pan, tap, press]);

			// let the pan gesture support all directions.
			// this will block the vertical scrolling on a touch-device while on the element
			mc.get('pan').set({ direction: Hammer.DIRECTION_ALL });

			mc.on("panend", function(ev) {
			    info.textContent = gesture;//ev.type +" gesture detected.";
			    if (enablePan) moveCamera(gesture);
			});

			// listen to events...
			mc.on("panleft panright panup pandown", function(ev) {
				gesture = ev.type;
			   // info.textContent = ev.type +" gesture detected.";
			   // moveCamera(ev.type);
			});

			mc.on("tap", function(ev) {
			    info.textContent = ev.type +" gesture detected.";
			    state = 'ColumnView';
			    panInc = 1;
			    
			   // console.log("pickedPanel.position.x="+pickedPanel.position.x)
			   console.log(pickedPanel.origin[0])
			    zoomCamera(pickedPanel.origin[0], pickedPanel.position.y, initZ);
			});

			mc.on("pinch press", function(ev) {
				
			    info.textContent += ev.type +" ";
			    state = 'GridView';
			    panInc = 3;
			    enablePan=false;
			    zoomCamera(xpos, ypos, maxZ);
			});

			function moveCamera(gesture){
				console.log(gesture)
				var nextCol;
				if (gesture == 'panleft'){
					if (activeCol<maxCol-1) {
						xpos += panHoriz *panInc;

						// NOT RELIABLE - What about when you select from grid????
						//activeCol++;
						//moveColumn(activeCol,ypos);
						nextCol = activeCol
					}

				} else if (gesture == 'panright') {
					if (activeCol>0) {
						xpos -= panHoriz*panInc;
						// NOT RELIABLE - What about when you select from grid????
						//activeCol--;
						//moveColumn(activeCol-2,ypos)
						nextCol = activeCol-2
						
					}
				} else if (gesture == 'panup') {
					ypos -= panVert*panInc;
				} else if (gesture == 'pandown') {
					ypos += panVert*panInc;
				} 


				TweenMax.to(camera.position ,.5,{
					x:xpos,
					y:ypos,
					z:zpos,
					ease:"Power3.easeOut",
					onInit:function(){
						if (state =="ColumnView"){
                  	  		if (gesture == 'panleft' || gesture == 'panright') moveColumn(nextCol,ypos)
                  	  	}
                  	 // moveColumn(activeCol+1,ypos)
	                },
	                onComplete:function(){
	                	//getCameraFocus();
	                	if (state =="ColumnView"){
	                		if (gesture == 'panleft' || gesture == 'panright') {
	                			//resetOtherColumns(nextCol);
	                			resetColumns()
	                			
	                		}
	                		//if (gesture == 'panleft' || gesture == 'panright') resetColumn()
	                		getCameraFocus()
	                	} 
	                }
	            });
			}

			function zoomCamera(x,y,z){

				xpos=x;
				ypos=y;
				zpos=z;


				TweenMax.to(camera.position ,.5,{
					x:xpos,
					y:ypos,
					z:zpos,
					ease:"Power3.easeOut",
					onInit: function(){
						//if (state =="GridView") resetColumn()
					},
					//ease: Elastic.easeOut.config(2, 0.5),
					onComplete:function(){
                  	  if (z==maxZ) enablePan=true;
                  	  getCameraFocus();
                  	  
					
	                }
	            });
			}

			function moveColumn(n, dist){
				var object = groupArr[n];
				object.position.y = dist;

				
				/*
				TweenMax.to(object.position ,.5,{
					//x:xpos,
					y:dist,
					//z:zpos,
					ease:"Power3.easeOut",
					//ease: Elastic.easeOut.config(2, 0.5),
					onComplete:function(){
                  	  if (z==maxZ) enablePan=true;
                  	  
					
	                }
	            });
	            */
			}
/*
			function resetOtherColumns(n){
				for (var i = 0; i < groupArr.length; i++) {
					var object = groupArr[i];
					if (i!= n) object.position.y = 0;
				}
			}
*/

			
			function resetColumns(){
				for (var i = 0; i < groupArr.length; i++) {
					var object = groupArr[i];
					object.position.y = 0;
				}
				camera.position.y=0;
				ypos = 0;
			}

			function getCameraFocus(){
				var camX = camera.position.x;
				var camY = camera.position.y;
				var xInc = camX/panelWidth + 1;
				var yInc = -camY/panelHeight + 1;
				activeCol = xInc;
				activeRow = yInc
				focusTile = ((xInc * maxRow)-maxRow) + yInc;
				info.textContent = "X:" + xInc+", Y:" +yInc+", Tile:"+ focusTile + ", Col:"+activeCol;

			}
		

		</script>

	</body>
</html>